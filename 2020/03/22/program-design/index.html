<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C语言输入输出scanf参数可变的函数 1int scanf(const char * , ...); 第一个参数是格式字符串，后面的参数是变量的地址，函数作用是按照第一个参数指定的格式，将数据读入后面的变量 返回值  &gt;0 成功读入的数据个数 0 没有被赋值 EOF 第一个尝试输入的字符是EOF">
<meta property="og:type" content="article">
<meta property="og:title" content="程序设计">
<meta property="og:url" content="http://yoursite.com/2020/03/22/program-design/index.html">
<meta property="og:site_name" content="Hulieu">
<meta property="og:description" content="C语言输入输出scanf参数可变的函数 1int scanf(const char * , ...); 第一个参数是格式字符串，后面的参数是变量的地址，函数作用是按照第一个参数指定的格式，将数据读入后面的变量 返回值  &gt;0 成功读入的数据个数 0 没有被赋值 EOF 第一个尝试输入的字符是EOF">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-22T03:04:03.000Z">
<meta property="article:modified_time" content="2020-06-16T04:08:50.237Z">
<meta property="article:author" content="雨游璃风猫">
<meta property="article:tag" content="琉璃猫">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/03/22/program-design/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>程序设计 | Hulieu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="page-head"></div>
  
  <div id="main-body" class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hulieu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">似曾相识焰归来，小圆香径独徘徊</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>优雅的首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>本站的历程</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>随意的标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>严谨的分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>最终的归档</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>永远的朋友</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <!-- 切换背景（还在施工）-->
  <div class="control">
    <div class="control-gear" style="visibility: visible" onclick=open_control_menu()>
      <span id="open-control-menu"> &nbsp; 主题 | SCHEME 
        <i class="fa fa-cog faa-spin animated" aria-hidden="true" style="font-size: 16px;"></i>
      </span>
    </div>
    <div class="control-menu">
      <ul class="control-menu-list">
        <li id="saber-bg"> <i class="fa fa-bell" aria-hidden="true" onclick=saber_bg() title="默认背景"></i></li>
        <li id="white-bg"> <i class="fa fa-mouse" aria-hidden="true" onclick=white_bg() title="纯白背景"></i></li>
        <li id="cat-bg"> <i class="fa fa-cat" aria-hidden="true" onclick=cat_bg() title="猫咪背景"></i></li>
        <li id="sun-mode"> <i class="fa fa-sun" aria-hidden="true" onclick=sun_mode() title="日间模式"></i></li>
        <li id="dark-mode"> <i class="fa fa-moon" aria-hidden="true" onclick=dark_mode() title="夜间模式"></i></li>
        
      </ul>
      <!--
      <ul class="control-menu-list">
        <li id="totem-bg"> <i class="fa fa-bell" aria-hidden="true"></i></li>
        <li id="pixiv-bg"> <i class="fa fa-pizza-slice" aria-hidden="true"></i></li>
        <li id="white-bg"> <i class="fa fa-cog" aria-hidden="true"></i></li>
        <li id="KAdots-bg"> <i class="fa fa-car" aria-hidden="true"></i></li>
      </ul>
      -->
    </div>
  </div>
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/22/program-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="雨游璃风猫">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-22 11:04:03" itemprop="dateCreated datePublished" datetime="2020-03-22T11:04:03+08:00">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-16 12:08:50" itemprop="dateModified" datetime="2020-06-16T12:08:50+08:00">2020-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C语言输入输出"><a href="#C语言输入输出" class="headerlink" title="C语言输入输出"></a>C语言输入输出</h1><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>参数可变的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * , ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是格式字符串，后面的参数是变量的地址，函数作用是按照第一个参数指定的格式，将数据读入后面的变量</p>
<p>返回值</p>
<ul>
<li>>0 成功读入的数据个数</li>
<li>0 没有被赋值</li>
<li>EOF 第一个尝试输入的字符是EOF</li>
</ul>
<a id="more"></a>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>参数可变函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * , ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是格式字符串，后面的参数是待输出的变量，函数作用是按照第一个参数指定的格式，将后面的变量在屏幕上输出</p>
<p>返回值</p>
<ul>
<li>成功打印的字符数</li>
<li>返回负值为出错</li>
</ul>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">scanf</span>(<span class="string">"%d%c%s%lf%f"</span>,&amp;a,&amp;b,c,&amp;d,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %c %s %lf %e %f %d"</span>,a,b,c,d,e,e,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">gets</span><span class="params">(<span class="keyword">char</span> * s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从标准输入读取一行到字符串s</p>
<p>如果成功，返回值就是s 地址</p>
<p>如果失败，返回值是 NULL</p>
<p><u>调用时要确保s 指向的缓冲区足够大，否则可能发生内存访问错误</u></p>
<h2 id="sscanf和ssprint"><a href="#sscanf和ssprint" class="headerlink" title="sscanf和ssprint"></a>sscanf和ssprint</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> * format[, address, ...])</span></span>;</span><br><span class="line"><span class="comment">// 和scanf的区别在于，它是从buffer里读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format[, argument, ...])</span></span>;</span><br><span class="line"><span class="comment">// 和printf的区别在于，它是往buffer里输出数据</span></span><br></pre></td></tr></table></figure>
<h1 id="C语言高级内容"><a href="#C语言高级内容" class="headerlink" title="C语言高级内容"></a>C语言高级内容</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>定义形式：类型名 (* 指针变量名)(参数类型1, 参数类型2,…);</p>
<p>使用方法：可以用一个原型匹配的函数的名字给一个函数指针赋值。要通过函数指针调用它所指向的函数，写法为：函数指针名(实参表);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMin</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( a&lt;b )</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d"</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* pf)(<span class="keyword">int</span> ,<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>, y = <span class="number">5</span>;		</span><br><span class="line">    pf = PrintMin;   </span><br><span class="line">    pf(x,y);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用：qsort库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> ( * pfCompare)( <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>; <span class="comment">// base起始位置，nelem元素个数，width元素宽度</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;&#125; <span class="comment">// argc命令行参数个数，包括可执行程序本身的名字</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>六种运算符：&amp;，|，^，~，&lt;&lt;，&gt;&gt;</p>
<p>应用：交换a，b</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<h1 id="从C到C"><a href="#从C到C" class="headerlink" title="从C到C++"></a>从C到C++</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。 类型名 &amp; 引用名 = 某变量名; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">int</span> &amp; r = n;  <span class="comment">// r引用了 n, r的类型是 int &amp;</span></span><br></pre></td></tr></table></figure>
<p>定义引用时一定要将其初始化成引用某个变量。</p>
<p>初始化后，它就一直引用该变量，不会再引用别 的变量了。</p>
<p>引用只能引用变量，不能引用常量和表达式。</p>
<p><u>C语言&amp;取指，C++中&amp;引用</u></p>
<p>引用可以作为函数的返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> n;  &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    SetValue() = <span class="number">40</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">//输出： 40</span></span><br></pre></td></tr></table></figure>
<p><u>const T &amp; 和T &amp; 是不同的类型</u></p>
<p>T &amp; 类型的引用或T类型的变量可以用来初始化 const T &amp; 类型的引用。</p>
<p>const T 类型的常变量和const T &amp; 类型的引用则 不能用来初始化T &amp;类型的引用，除非进行强制类 型转换</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>第一种用法，分配一个变量：T是任意类型名，P是类型为T * 的指针。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T;</span><br></pre></td></tr></table></figure>
<p>第二种用法，分配一个数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T[N];</span><br></pre></td></tr></table></figure>
<p><u>使用new动态分配的内存空间，一定要用delete进行释放</u></p>
<p>使用delete释放动态分配的数组，要加[]，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p> 为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( a &gt; b) <span class="keyword">return</span> a; </span><br><span class="line">    <span class="keyword">return</span> b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载</p>
<p>函数重载使得函数命名变得简单。 </p>
<p>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>其作用就是指向成员函数所作用的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 等价于 void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; "hello" &lt;&lt; endl; &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>非静态成员函数</strong>中可以直接使用this来代表指向该函数作用的对象的指针。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; imag ; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i) &#123;&#125;</span><br><span class="line">    <span class="function">Complex <span class="title">AddOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real ++; <span class="comment">//等价于 real ++;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;Print(); <span class="comment">//等价于 Print</span></span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><strong>静态成员</strong>是在说明前面加了static关键字的成员。静态成员变量本质上是全局变量。</p>
<p><u>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份， 为所有对象共享。</u></p>
<p>sizeof 运算符不会计算静态成员变量。  </p>
<p>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象，因此静态成员不需要通过对象就能访问。</p>
<p>四种种访问静态成员的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::PrintTotal(); <span class="comment">// 类名::成员名</span></span><br><span class="line">CRectangle r; r.PrintTotal(); <span class="comment">// 对象名.成员名</span></span><br><span class="line">CRectangle * p = &amp;r; p-&gt;PrintTotal(); <span class="comment">// 指针-&gt;成员名</span></span><br><span class="line">CRectangle &amp; ref = r; <span class="keyword">int</span> n = ref.nTotalNumber; <span class="comment">// 引用.成员名</span></span><br></pre></td></tr></table></figure>
<p>必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。  </p>
<p><u>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</u></p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()&#123;</span><br><span class="line">    nTotalNumber --;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nTotalNumber &lt;&lt; <span class="string">","</span> &lt;&lt; nTotalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写缺陷是在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象  ，比如调用CRectangle类对象作为参数或作为返回值的函数时，并不会增加nTotalNumber，却会在这些对象消亡时调用析构函数。解决办法：写一个赋值构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CRectangle :: CRectangle(CRectangle &amp; r )&#123;</span><br><span class="line">    w = r.w; h = r.h;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>有<strong>成员对象</strong>的类叫<strong>封闭类</strong>。</p>
<p>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。</p>
<p>具体的做法就是：<u> 通过封闭类的构造函数的初始化列表 。</u> </p>
<p>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。</p>
<p>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。</p>
<p>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反  </p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CTyre() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre contructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CTyre() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CEngine() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine contructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CEngine() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CEngine engine;</span><br><span class="line">    CTyre tyre;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CCar( ) &#123; <span class="built_in">cout</span> &lt;&lt; “CCar contructor” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CCar() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CCar car;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">CEngine contructor</span></span><br><span class="line"><span class="comment">CTyre contructor</span></span><br><span class="line"><span class="comment">CCar contructor</span></span><br><span class="line"><span class="comment">CCar destructor</span></span><br><span class="line"><span class="comment">CTyre destructor</span></span><br><span class="line"><span class="comment">CEngine destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><u>封闭类的对象，如果是用默认复制构造函数初始化的，那么它里面包含的成员对象，也会用复制构造函数初始化。</u></p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元分为友元函数和友元类两种  </p>
<p><u>友元函数: 一个类的友元函数可以访问该类的私有成员。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> ;</span> <span class="comment">//提前声明 CCar类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">( CCar * pCar)</span> </span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar * pCar); <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar( CCar * pCar)&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>; <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。</p>
<p><u>友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><u>友元类之间的关系不能传递，不能继承。</u></p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加 const关键字 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sample Obj;</span><br></pre></td></tr></table></figure>
<p>常量对象只能使用构造函数、析构函数和有const 说明的函数(常量方法）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sample() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数。  </p>
<p>在<u>定义常量成员函数</u>和<u>声明常量成员函数</u>时都应该使用const 关键字  </p>
<p>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么， 最好将其写成常量成员函数。</p>
<p>两个函数，名字和参数表都一样，但是一个是const,一个不是，算重载。  </p>
<p>const成员函数可以修改的成员变量要加mutable</p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载的实质是函数重载</p>
<p>可以重载为普通函数，也可以重载为成员函数</p>
<p>把含运算符的表达式转换成对运算符函数的调用</p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">double</span> real,imag; </span><br><span class="line">    Complex( <span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i= <span class="number">0.0</span> ):real(r),imag(i) &#123;&#125; </span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp; c); </span><br><span class="line">&#125;; </span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; a, <span class="keyword">const</span> Complex &amp; b) &#123; </span><br><span class="line">    <span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag); <span class="comment">//返回一个临时对象 </span></span><br><span class="line">&#125; </span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp; c) &#123; </span><br><span class="line">    <span class="keyword">return</span> Complex(real - c.real, imag - c.imag); <span class="comment">//返回一个临时对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>赋值运算符“=”只能重载为成员函数</p>
<p>如不定义自己的赋值运算符，那么可能会导致浅拷贝。</p>
<h2 id="运算符重载为友元函数"><a href="#运算符重载为友元函数" class="headerlink" title="运算符重载为友元函数"></a>运算符重载为友元函数</h2><p>有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line">    <span class="keyword">double</span> real,imag; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Complex( <span class="keyword">double</span> r, <span class="keyword">double</span> i):real(r),imag(i)&#123; &#125;; </span><br><span class="line">    Complex <span class="keyword">operator</span>+( <span class="keyword">double</span> r );  <span class="comment">// c + 5</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (<span class="keyword">double</span> r,<span class="keyword">const</span> Complex &amp; c); <span class="comment">// 5 + c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流插入-提取运算符的重载"><a href="#流插入-提取运算符的重载" class="headerlink" title="流插入/提取运算符的重载"></a>流插入/提取运算符的重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; ostream::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    ... <span class="comment">// 输出n的代码</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载类型转换运算符"><a href="#重载类型转换运算符" class="headerlink" title="重载类型转换运算符"></a>重载类型转换运算符</h2><h2 id="自增-自减运算符重载"><a href="#自增-自减运算符重载" class="headerlink" title="自增/自减运算符重载"></a>自增/自减运算符重载</h2><p>前置运算符作为一元运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载为成员函数： </span></span><br><span class="line">T &amp; <span class="keyword">operator</span>++(); </span><br><span class="line">T &amp; <span class="keyword">operator</span>--(); </span><br><span class="line"><span class="comment">// 重载为全局函数： </span></span><br><span class="line">T1 &amp; <span class="keyword">operator</span>++(T2); </span><br><span class="line">T1 &amp; <span class="keyword">operator</span>--(T2);</span><br></pre></td></tr></table></figure>
<p>后置运算符作为二元运算符重载，多写一个没用的参数int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载为成员函数： </span></span><br><span class="line">T <span class="keyword">operator</span>++(<span class="keyword">int</span>); </span><br><span class="line">T <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 重载为全局函数： </span></span><br><span class="line">T1 <span class="keyword">operator</span>++(T2,<span class="keyword">int</span> ); </span><br><span class="line">T1 <span class="keyword">operator</span>--( T2,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>但是在没有后置运算符重载而有前置重载的情况下，在vs中，obj++ 也调用前置重载，而dev则令 obj ++ 编译出错</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>C++不允许定义新的运算符</p>
<p>重载不改变优先级顺序</p>
<p>重载(),[],-&gt;,=时，重载函数必须声明为类的成员函数。</p>
<h1 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h1><p>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量 和成员函数。</p>
<p>派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public 。</p>
<p>在派生类的各个成员函数中，不能访问 基类中的private成员。</p>
<h2 id="继承关系和复合关系"><a href="#继承关系和复合关系" class="headerlink" title="继承关系和复合关系"></a>继承关系和复合关系</h2><p>继承：B继承A，A是基类，B对象也是A对象</p>
<p>复合：C中有成员变量k，k是D对象</p>
<h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p> 派生类可以定义一个和基类成员同名的成员，这叫 覆盖。</p>
<p>在派生类中访问这类成员时，缺省的情况是 访问派生类中定义的成员。要在派生类中访问由基 类定义的同名成员时，要使用作用域符号::。</p>
<h2 id="类的保护成员"><a href="#类的保护成员" class="headerlink" title="类的保护成员"></a>类的保护成员</h2><p>基类的private成员：可以被下列函数访问 </p>
<ul>
<li>基类的成员函数 </li>
<li>基类的友员函数 </li>
</ul>
<p>基类的protected成员：可以被下列函数访问 </p>
<ul>
<li>基类的成员函数 </li>
<li>基类的友员函数 </li>
<li>派生类的成员函数可以访问<strong>当前对象的基类</strong>的保护成员</li>
</ul>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>构造函数不能访问基类的private变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> nLegs; <span class="keyword">int</span> nColor; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> nType; </span><br><span class="line">    Bug (<span class="keyword">int</span> legs, <span class="keyword">int</span> color); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span>:</span> <span class="keyword">public</span> Bug <span class="comment">// FlyBug是Bug的派生类 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> nWings; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">    FlyBug(<span class="keyword">int</span> legs,<span class="keyword">int</span> color, <span class="keyword">int</span> wings); </span><br><span class="line">&#125;;</span><br><span class="line">Bug::Bug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color) &#123; nLegs = legs; nColor = color; &#125;</span><br><span class="line"><span class="comment">//正确的FlyBug构造函数： </span></span><br><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color, <span class="keyword">int</span> wings):Bug( legs, color) &#123; nWings = wings; &#125;</span><br></pre></td></tr></table></figure>
<p>在创建派生类的对象时，需要调用基类的构造函数：初始化派 生类对象中从基类继承的成员。在执行一个派生类的构造函数 之前，总是先执行基类的构造函数。</p>
<p>调用基类构造函数的两种方式 </p>
<ul>
<li>显式方式：在派生类的构造函数中，为基类的构造函数提供参数. </li>
<li>隐式方式：在派生类的构造函数中，省略基类构造函数时， 派生类的构造函数则自动调用基类的默认构造函数.</li>
</ul>
<p>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</p>
<p>封闭派生类对象构造先基类构造函数，然执行对象成员的构造函数，最后执行自己的构造函数。析构时与之相反。</p>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><p>派生类的对象可以赋值给基类对象 </p>
<p>派生类对象可以初始化基类引用</p>
<p>派生类对象的地址可以赋值给基类指针</p>
<p>如果派生方式是 private或protected，则上述三条不可行</p>
<p><u>protected继承时，基类的public成员和protected成员成为派生类的protected成员。</u></p>
<p><u>private继承时，基类的public成员成为派生类的private成员，基类的protected成员成 为派生类的不可访问成员</u></p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h2><p>类的定义中，有virtual关键字的成员函数是虚函数</p>
<p>virtual关键字只用在类定义的函数声明中，写函数体时不用。</p>
<p>通过基类指针调用基类和派生类中的同名同参虚函数时: </p>
<ul>
<li>若该指针指向一个基类的对象，那么被调用是基类的虚 函数；</li>
<li>若该指针指向一个派生类的对象，那么被调用的是派生 类的虚函数。</li>
</ul>
<p>这种机制就叫做<strong>“多态”</strong>。</p>
<p>两种表现形式</p>
<ul>
<li><p>派生类的指针可以赋给基类指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    CDerived ODerived; </span><br><span class="line">    CBase * p = &amp; ODerived; </span><br><span class="line">    p -&gt; SomeVirtualFunction(); <span class="comment">//调用哪个虚函数取决于p指向哪种类型的对象 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类的对象可以赋给基类引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    CDerived ODerived; </span><br><span class="line">    CBase &amp; r = ODerived; </span><br><span class="line">    r.SomeVirtualFunction(); <span class="comment">//调用哪个虚函数取决于r引用哪种类型的对象 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><u>在非构造函数，非析构函数的成员 函数中调用虚函数，是多态!!!</u></p>
<p>在构造函数和析构函数中调用虚函数，不是多态。编 译时即可确定，调用的函数是自己的类或基类中定义 的函数，不会等到运行时才决定调用自己的还是派生 类的函数。</p>
<p>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</p>
<p><u>虚函数的访问权限根据基类定义所决定。</u></p>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><p>“多态”的关键在于通过基类指针或引用调用 一个虚函数时，编译时不确定到底调用的是基类还 是派生类的函数，运行时才确定——这叫<strong>“动态联编”</strong>。</p>
<p><u>多态实现的关键 —- 虚函数表</u></p>
<p>每一个有虚函数的类（或有虚函数的类的派生类） 都有一个虚函数表，该类的任何对象中都放着虚函数 表的指针。虚函数表中列出了该类的虚函数地址。</p>
<p>多态的函数调用语句被 编译成一系列根据基类指 针所指向的（或基类引用 所引用的）对象中存放的 虚函数表的地址，在虚函 数表中查找虚函数地址， 并调用虚函数的指令。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>   &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::Func"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A  &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::Func"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">	A a; </span><br><span class="line">	A * pa = <span class="keyword">new</span> B(); </span><br><span class="line">	pa-&gt;Func(); <span class="comment">//若是64位程序,指针为8字节，则应为long long </span></span><br><span class="line">	<span class="keyword">long</span> * p1 = (<span class="keyword">long</span> * ) &amp; a; </span><br><span class="line">	<span class="keyword">long</span> * p2 = (<span class="keyword">long</span> * ) pa; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; * p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; * p2 &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	* p2 = * p1; </span><br><span class="line">	pa-&gt;Func(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// B::Func</span></span><br><span class="line"><span class="comment">// A::Func</span></span><br></pre></td></tr></table></figure>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。但是，删除一个派生类的对象时，应该先调用派生类的析构函 数，然后调用基类的析构函数。 </p>
<p>解决办法：把基类的析构函数声明为virtual </p>
<p>派生类的析构函数可以virtual不进行声明</p>
<ul>
<li>通过基类的指针删除派生类对象时，首先调用派生类的析构函 数，然后调用基类的析构函数 </li>
<li>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成 虚函数。</li>
</ul>
<p>或者，一个类打算作为基类使用，也应该将析构函数定义 成虚函数。 </p>
<p><u>注意：不允许以虚函数作为构造函数</u></p>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>纯虚函数：没有函数体的虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br></pre></td></tr></table></figure>
<p>包含纯虚函数的类叫抽象类</p>
<p>不能创建抽象类的对象</p>
<p>抽象类只能作为基类来派生新类</p>
<p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部 不能调用纯虚函数。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>输入输出相关的类</p>
<p>istream/ostream/iostream 流类</p>
<p>ifstream/ofstream/fstream 文件类</p>
<h2 id="标准流对象"><a href="#标准流对象" class="headerlink" title="标准流对象"></a>标准流对象</h2><p>输入流cin从键盘读入</p>
<p>输出流cout、cerr、clog向屏幕输出（缺省情况下三者一样）</p>
<p>可以被重新向为向文件读/写数据</p>
<p>可以用如下方法判输入流结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;x)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果从键盘输入，则在单独一行输入ctrl+z代表输入流结束</p>
<h2 id="istream类成员函数"><a href="#istream类成员函数" class="headerlink" title="istream类成员函数"></a>istream类成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> bufSize)</span></span>;</span><br><span class="line"><span class="comment">// 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到‘\n’ 为止（哪个先到算哪个）</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> bufSize,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">// 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到delim字 符为止（哪个先到算哪个）</span></span><br></pre></td></tr></table></figure>
<p>两个函数都会自动在buf中读入数据的结尾添加\0’。</p>
<p>‘\n’或 delim都不会被读入buf，但会被从输入流中取走。如果输入流中 ‘\n’或delim之前的字符个数达到或超过了bufSize个，就导致读 入出错，其结果就是：虽然本次读入已经完成，但是之后的读入就 都会失败了</p>
<p>可以用 <code>if(!cin.getline(…))</code> 判断输入是否结束</p>
<p><code>bool eof();</code>判断输入流是否结束 </p>
<p><code>int peek();</code> 返回下一个字符,但不从流中去掉. </p>
<p><code>istream &amp; putback(char c);</code>将字符ch放回输入流 </p>
<p><code>istream &amp; ignore( int nCount = 1, int delim = EOF );</code> 从流中删掉最多nCount个字符，遇到EOF时结束。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"test.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件 </span></span><br><span class="line">freopen(“t.txt”,“r”,<span class="built_in">stdin</span>);  <span class="comment">//cin被改为从 t.txt中读取数据</span></span><br></pre></td></tr></table></figure>
<h2 id="流操纵算子"><a href="#流操纵算子" class="headerlink" title="流操纵算子"></a>流操纵算子</h2><p><u>使用流操纵算子需要 <code>#include &lt;iomanip&gt;</code></u></p>
<p>整数流的基数：流操纵算子dec,oct,hex </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; “\n” <span class="comment">// a </span></span><br><span class="line">    &lt;&lt; dec &lt;&lt; n &lt;&lt; “\n”  <span class="comment">// 10</span></span><br><span class="line">    &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>指定输出浮点数有效位数（非定点方式输出）/小数点后有效位数（定点方式输出）：</p>
<p>precision是成员函数，调用方式为<code>cout.precision(5);</code></p>
<p>setprecision是流操作算子，调用方式为<code>cout&lt;&lt;setprecision(5);</code></p>
<p><code>setiosflags(ios::fixed)</code>定点输出模式</p>
<p><code>resetiosflags(ios::fixed)</code>非定点输出模式</p>
<p>设置域宽的流操作算子：</p>
<p>setw是流算子<code>cin&gt;&gt;setw(4);</code></p>
<p>width是成员函数<code>cin.width(5);</code></p>
<p><u>宽度设置有效性是一次性的，在每次读入和 输出之前都要设置宽度。</u></p>
<p>其他操作算子</p>
<p><code>showpos</code>显示正负号/<code>noshowpos</code>不显示正负号</p>
<p><code>left</code>、<code>right</code>、<code>internal</code>左/右/中</p>
<p><code>scientific</code>科学计数法</p>
<p>用户自定义算子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">tab</span><span class="params">(ostream &amp;output)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> output &lt;&lt; <span class="string">'\t'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这是因为iostream对&lt;&lt;进行了重载</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt;(  ostream &amp; ( * p ) ( ostream &amp; ) ) ;</span><br></pre></td></tr></table></figure>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p><code>#include&lt;fstream&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"clients.dat"</span>, ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ios::out</code> 删除原有内容 <code>ios::app</code>保留原有内容</p>
<p>也可以先出创建ofstream对象，再用<code>open</code>函数打开</p>
<p><code>tellp()</code>获得指针位置</p>
<p><code>seekp(location)</code>将指针移到location处</p>
<p><code>seekp(location, ios::beg)</code>从开头数，<code>seekp(location, ios::cur)</code>从当前数，<code>seekp(location, ios::end)</code>从结尾数</p>
<p>location可以是负数</p>
<p>关闭文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"1.dat"</span>, ios::in)</span></span>;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"1.dat"</span>, ios::out)</span></span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>二进制读文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span> <span class="params">(<span class="keyword">char</span>* s, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 将文件读指针指向的地方的n个字节内容，读入到内存地址s，然后将文件读指针向后移动n字节</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 将内存地址s处的n个字节内容，写入到文件中写指针指向的位置， 然后将文件写指针向后移动n字节</span></span><br></pre></td></tr></table></figure>
<p><u>二进制文件和文本文件的区别</u></p>
<p>Linux,Unix下的换行符号：‘\n’  (ASCII码:  0x0a) </p>
<p>Windows 下的换行符号：‘\r\n’  (ASCII码： 0x0d0a)    endl 就是 ‘\n’ </p>
<p>Mac OS下的换行符号： ‘\r’  (ASCII码：0x0d)</p>
<p>二进制和Linux下一致</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp; <span class="title">x</span>,<span class="title">T</span> &amp; <span class="title">y</span>) &#123;</span> </span><br><span class="line">    T tmp = x; </span><br><span class="line">    x = y; </span><br><span class="line">    y = tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以不通过参数实例化函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Inc</span>(<span class="title">T</span> <span class="title">n</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Inc&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>)/<span class="number">2</span>;  <span class="comment">//输出 2.5 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一 条函数调用语句</p>
<ol>
<li>先找参数完全匹配的普通函数(非由模板实例化而得的函数)。 </li>
<li>再找参数完全匹配的模板函数。 </li>
<li>再找实参数经过自动类型转换后能够匹配的普通函数。 </li>
<li>都找不到，则报错。</li>
</ol>
<p>匹配模板函数时，不进行类型自动转换</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    T1 key;  <span class="comment">//关键字 </span></span><br><span class="line">    T2 value;     <span class="comment">//值 </span></span><br><span class="line">    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Pair</span>&lt;T1,T2&gt;:</span>:<span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span> <span class="comment">//Pair的成员函数 operator &lt; </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> key &lt; p.key;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器由类模板生成类的过程叫类模板的实例化。</p>
<p>由类 模板实例化得到的类，叫模板类。</p>
<p><u>同一个类模板的两个模板类是不兼容的。</u></p>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数： <code>template &lt;class T, int size&gt;</code></p>
<h2 id="类模板和派生"><a href="#类模板和派生" class="headerlink" title="类模板和派生"></a>类模板和派生</h2><p>类模板从类模板派生</p>
<p>类模板从普通类派生</p>
<p>类模板从模板类派生</p>
<p>普通类从模板类派生</p>
<h2 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h2><p> 函数、类、类的成员函数作为类模板的友元 </p>
<p>函数模板作为类模板的友元 </p>
<p>函数模板作为类的友元 </p>
<p>类模板作为类模板的友元</p>
<h1 id="标准模板库（STL）"><a href="#标准模板库（STL）" class="headerlink" title="标准模板库（STL）"></a>标准模板库（STL）</h1><p>C++ 语言的核心优势之一就是便于软件的重用</p>
<p>C++中有两个方面体现重用：</p>
<ol>
<li><p>面向对象的思想：继承和多态，标准类库</p>
</li>
<li><p>泛型程序设计(generic programming) 的思想： 模板机制，以及标准模板库 STL</p>
</li>
</ol>
<p>将一些常用的数据结构（比如链表，数组，二叉树）和算法（比如排序，查找）写成模板，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。</p>
<p><strong>标准模板库 (Standard Template Library) </strong>就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。</strong></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>容器</strong>：可容纳各种数据类型的通用数据结构，是类模板</p>
<p><strong>迭代器：</strong>可用于依次存取容器中元素，类似于指针</p>
<p><strong>算法：</strong>用来操作容器中的元素的函数模板</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>对象被插入容器中时，被插入的是对象的一个<strong>复制品</strong>。许多算法，比如排序，查找，要求对容器中的元素进行比较，有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该重载 == 和 &lt; 运算符。</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>vector, deque, list</p>
<p><strong>vector</strong></p>
<p>头文件<code>&lt;vector&gt;</code></p>
<p>动态数组。元素在内存连续存放。随机存取任何元素都能在<strong>常数时间</strong>完成。在尾端增删元素具有较佳的性能</p>
<p><strong>deque</strong></p>
<p>头文件<code>&lt;deque&gt;</code></p>
<p>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成(但次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</p>
<p>所有适用于 vector的操作都适用于 deque。</p>
<p>deque还有 push_front（将元素插入到前面） 和 pop_front(删除最前面的元素）操作。</p>
<p><strong>list</strong></p>
<p>头文件<code>&lt;list&gt;</code></p>
<p>双向链表。元素在内存<strong>不连续存放</strong>。在任何位置增删元素都能在常数时间完成。<strong>不支持随机存取。</strong></p>
<p> 除了具有所有顺序容器都有的成员函数以外，还支持8个成员函数：</p>
<ul>
<li>push_front: 在前面插入</li>
<li>pop_front:  删除前面的元素</li>
<li>sort:    排序 ( list 不支持 STL 的算法 sort)</li>
<li>remove:    删除和指定值相等的所有元素</li>
<li>unique:   删除所有和前一个元素相同的元素</li>
<li>merge:    合并两个链表，并清空被合并的那个</li>
<li>reverse:    颠倒链表</li>
<li>splice:   在指定位置前面插入另一链表中的一个或多个元素,并在另一链表中删除被插入的元素</li>
</ul>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>元素是排序的</p>
<p>插入任何元素，都按相应的排序规则来确定其位置</p>
<p>在查找时具有非常好的性能</p>
<p>通常以平衡二叉树方式实现，插入和检索的时间都是 O(log(N))</p>
<p>set, multiset, map, multimap</p>
<p>内部元素有序排列，新元素插入的位置取决于它的值，查找速度快。</p>
<p>除了各容器都有的函数外，还支持以下成员函数：</p>
<ul>
<li>find: 查找等于某个值 的元素(x小于y和y小于x同时不成立即为相等)</li>
<li>lower_bound : 查找某个下界</li>
<li>upper_bound : 查找某个上界</li>
<li>equal_range : 同时查找上界和下界</li>
<li>count :计算等于某个值的元素个数(x小于y和y小于x同时不成立即为相等)</li>
<li>insert: 用以插入一个元素或一个区间</li>
</ul>
<p><strong>set/multiset</strong></p>
<p>头文件<code>&lt;set&gt;</code> </p>
<p>区别在于是否允许存储相同元素</p>
<p>multiset的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, </span></span><br><span class="line"><span class="class">	        <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multiset</span> &#123;</span> …… &#125;;</span><br></pre></td></tr></table></figure>
<p>Pred类型的变量决定了multiset 中的元素，“一个比另一个小”是怎么定义的。multiset运行过程中，比较两个元素x,y的大小的做法，就是生成一个 Pred类型的变量，假定为 op,若表达式op(x,y) 返回值为true,则 x比y小。 Pred的缺省类型是<code>less&lt;Key&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; </span><br><span class="line">&#123; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ; &#125; <span class="keyword">const</span>;   &#125;;</span><br></pre></td></tr></table></figure>
<p>multiset用法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">multiset</span>&lt;A&gt; a;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;A, less&lt;A&gt;&gt; a;</span><br></pre></td></tr></table></figure>
<p>由于less模板默认&lt;比较大小，所以A不可比较时需要重载&lt;</p>
<p><strong>map/multimap</strong></p>
<p>头文件<code>&lt;map&gt;</code></p>
<p>map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。</p>
<p>pair模板如下，map/multimap里放着都是pair模板类的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">     <span class="keyword">typedef</span> _T1 first_type;  </span><br><span class="line">     <span class="keyword">typedef</span> _T2 second_type; </span><br><span class="line">     _T1 first;               </span><br><span class="line">     _T2 second;              </span><br><span class="line">     pair(): first(), second() &#123; &#125;</span><br><span class="line">     pair(<span class="keyword">const</span> _T1&amp; __a, <span class="keyword">const</span> _T2&amp; __b)</span><br><span class="line">     : first(__a), second(__b) &#123; &#125;</span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">U1</span>, <span class="title">class</span> _<span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;_U1, _U2&gt;&amp; __<span class="title">p</span>)</span></span><br><span class="line"><span class="class">:</span> first(__p.first), second(__p.second) &#123; &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>multimap定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">		 <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span> &#123;</span> </span><br><span class="line">	….</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type; </span><br><span class="line">	…….	</span><br><span class="line"> &#125;;    <span class="comment">//Key 代表关键字的类型</span></span><br></pre></td></tr></table></figure>
<p>multimap中的元素由 &lt;关键字,值&gt;组成，每个元素是一个pair对象，关键字就是first成员变量,其类型是Key</p>
<p>multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 <code>less&lt;Key&gt;</code> 定义关键字的“小于”关系。</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>stack, queue, priority_queue</p>
<ul>
<li>push 插入元素</li>
<li>pop 弹出元素</li>
<li>top 返回栈顶元素的引用</li>
</ul>
<p><strong>stack</strong></p>
<p>头文件<code>&lt;stack&gt;</code></p>
<p>后进先出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> = <span class="title">deque</span>&lt;T&gt; &gt;  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span> </span><br><span class="line">	…..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可用 vector, list, deque来实现。缺省情况下，用deque实现。用 vector和deque实现，比用list实现性能好。</p>
<p><strong>queue</strong></p>
<p>头文件<code>&lt;queue&gt;</code></p>
<p>先进先出</p>
<p>和stack 基本类似，可以用 list和deque实现。缺省情况下用deque实现。</p>
<p><strong>priority_queue</strong></p>
<p>头文件<code>&lt;queue&gt;</code></p>
<p>优先级队列。最高优先级元素总是第一个出列</p>
<p>和 queue类似，可以用vector和deque实现。缺省情况下用vector实现。</p>
<p>priority_queue 通常用堆排序技术实现，保证最大的元素总是在最前面。即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的引用。默认的元素比较器是 <code>less&lt;T&gt;</code>。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>begin 第一个元素的迭代器</p>
<p>end 最后一个元素后面的迭代器</p>
<p>rbegin 最后一个元素的迭代器</p>
<p>rend 第一个元素前面的迭代器</p>
<p>erase</p>
<p>clear</p>
<p>front 第一个元素的引用</p>
<p>back 最后一个元素的引用</p>
<p>push_back</p>
<p>pop_back</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>用于指向顺序容器和关联容器中的元素</p>
<p>迭代器用法和指针类似</p>
<p>有const 和非 const两种</p>
<p>通过迭代器可以读取它指向的元素</p>
<p>通过非const迭代器还能修改其指向的元素</p>
<p>定义一个容器类的迭代器的方法可以是：</p>
<p> <code>容器类名::iterator  变量名;</code></p>
<p>或：</p>
<p> <code>容器类名::const_iterator 变量名;</code></p>
<p>访问一个迭代器指向的元素：</p>
<p> <code>* 迭代器变量名</code></p>
<p>迭代器可以执行++，—</p>
<p>可以判断是否相等</p>
<p>如果是随机访问迭代器，可以+i，-i， p[i]，可以判断大小</p>
<p>容器适配器（stack、queue、priority_queue）不支持迭代器</p>
<p>vector/deque 随机访问，list/set/map 双向</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法就是一个个<strong>函数模板</strong>, 大多数在<code>&lt;algorithm&gt;</code> 中定义</p>
<p>STL中提供能在各种容器中通用的算法，比如查找，排序等</p>
<p>算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找</p>
<p>有的算法返回一个迭代器。比如 find() 算法，在容器中查找一个元素，并返回一个指向该元素的迭代器</p>
<p>算法可以处理容器，也可以处理普通数组</p>
<p><strong>find</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
<p>first 和 last 这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first,last)。区间的起点是位于查找范围之中的，而终点不是。find在[first,last)查找等于val的元素</p>
<p>用 == 运算符判断相等</p>
<p>函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last</p>
<p><strong>STL中“大”“小” 的概念</strong></p>
<p>关联容器内部的元素是从小到大排序的</p>
<p>有些算法要求其操作的区间是从小到大排序的，称为“有序区间算法”，例如<code>binary_search</code></p>
<p>有些算法会对区间进行从小到大排序，称为“排序算法”，例如<code>sort</code></p>
<p>还有一些其他算法会用到“大”，“小”的概念</p>
<p>使用STL时，在缺省的情况下，以下三个说法等价：</p>
<ul>
<li>x比y小</li>
<li>表达式“x&lt;y”为真</li>
<li>y比x大</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>是个对象，但是用起来看上去象函数调用，实际上也执行了函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyAverage</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3 )</span> </span>&#123; <span class="comment">//重载 () 运算符</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2+a3) / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> CMyAverage average;  <span class="comment">//函数对象</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// average.operator()(3,2,3) 用起来看上去象函数调用 输出 2.66667</span></span><br></pre></td></tr></table></figure>
<p>STL里有以下模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">val</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure>
<p>pr 就是个函数对象。</p>
<p>对[first,last)中的每个迭代器 I, </p>
<p>执行 val = pr(val,* I) ,返回最终的val。</p>
<p>Pr也可以是个函数。</p>
<p><strong>greater 函数对象类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;&#123; </span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x &gt; y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//binary_function定义：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span> </span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type; </span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>STL中的算法大致可以分为以下七类：</p>
<ul>
<li><p>不变序列算法</p>
<p>此类算法不会修改算法所作用的容器或对象，适用于所有容器。它们的时间复杂度都是O(n)的。</p>
<p>min、max、for_each、count、count_if、find、find_if、find_end、find_first_of、adjacent_find，search、search_n、equal</p>
</li>
<li><p>变值算法</p>
<p>此类算法会修改源区间或目标区间元素的值。值被修改的那个区间，不可以是属于关联容器的。</p>
<p>for_each、copy、copy_backward、transform、swap_ranges、fill、fill_n、generate、replace、replace_if、replace_copy、replace_copy_if</p>
</li>
<li><p>删除算法</p>
<p>删除算法会删除一个容器里的某些元素。这里所说的“删除”，并不会使容器里的元素减少，其工作过程是：将所有应该被删除的元素看做空位子，然后用留下的元素从后往前移，依次去填空位子。元素往前移后，它原来的位置也就算是空位子，也应由后面的留下的元素来填上。最后，没有被填上的空位子，维持其原来的值不变。删除算法不应作用于关联容器。</p>
<p>remove、remove_if、remove_copy、remove_copy_if、unique、unique_copy</p>
</li>
<li><p>变序算法</p>
<p>变序算法改变容器中元素的顺序，但是不改变元素的值。变序算法不适用于关联容器。此类算法复杂度都是O(n)的。</p>
<p>reverse、reverse_copy，rotate（左移）、next_permutation（下一个排列）、prev_permutation、random_shuffle（需要预设随机种子）、partition</p>
</li>
<li><p>排序算法</p>
<p>排序算法比前面的变序算法复杂度更高，一般是O(n×log(n))。排序算法需要随机访问迭代器的支持，因而不适用于关联容器和list。</p>
<p>sort（快排）、stable_sort（归并）、partial_sort（部分排序，直到最小的n个元素就位）、nth_element、make_heap、push_heap、pop_heap、sort_heap</p>
</li>
<li><p>有序区间算法</p>
<p>有序区间算法要求所操作的区间是已经从小到大排好序的，而且需要随机访问迭代器的支持。所以有序区间算法不能用于关联容器和list。</p>
<p>binary_search、includes、lower_bound、upper_bound、merge、set_union、set_intersection、set_difference、</p>
</li>
<li><p>数值算法</p>
</li>
</ul>
<p>大多重载的算法都是有两个版本的，其中一个是用“==”判断元素是否相等，或用“&lt;”来比较大小；而另一个版本多出来一个类型参数“Pred”，以及函数形参“Pred op”,该版本通过表达式“op(x,y)”的返回值是ture还是false，来判断x是否“等于”y，或者x是否“小于”y。如下面的有两个版本的min_element:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last)</span></span>;</span><br><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last, Pred op)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++11特性"></a>C++11特性</h1><p>统一的是初始化方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;  mp&#123;&#123;<span class="number">1</span>, <span class="string">"a"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"b"</span>&#125;&#125;; </span><br><span class="line"><span class="built_in">string</span> str&#123;<span class="string">"Hello World"</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    A(<span class="keyword">int</span> m,<span class="keyword">int</span> n):i(m),j(n) &#123; &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A * pa = <span class="keyword">new</span> A &#123;<span class="number">3</span>,<span class="number">7</span>&#125;; </span><br><span class="line">    A a[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量默认初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1234</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>auto关键字：用于定义变量，编译起可以自动判断变量的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span></span><br></pre></td></tr></table></figure>
<p>decltype 关键字：求表达式的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span></span><br></pre></td></tr></table></figure>
<p>智能指针shared_ptr：通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返 回的指针,此后ptr就可以像 T<em> 类型的指针一样来使用，即 </em>ptr 就是用new动态分配的那 个对象，而且不必操心释放内存的事。多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当 无shared_ptr托管该指针时，delete该指针。 <u>shared_ptr对象不能托管指向动态分配的数组的指针，否则程序运行会出错</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sp1(<span class="keyword">new</span> A(<span class="number">2</span>)); <span class="comment">//sp1托管A(2) </span></span><br><span class="line">    sp1.reset();           <span class="comment">//sp1放弃托管 A(2) </span></span><br><span class="line">    A * q = <span class="keyword">new</span> A(<span class="number">3</span>); </span><br><span class="line">    sp1.reset(q); <span class="comment">// sp1托管q </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于范围的for循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ary[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp; e: ary)  </span><br><span class="line">        e*= <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : ary) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右值引用和move语义：一般来说，不能取地址的表达式，就是右值， 能取地址的，就是左值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;; </span><br><span class="line">A &amp; r = A(); <span class="comment">// error , A()是无名变量，是右值 </span></span><br><span class="line">A &amp;&amp; r = A(); <span class="comment">//ok, r 是右值引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MoveSwap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>)   &#123;</span> </span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(<span class="built_in">move</span>(a))</span></span>; <span class="comment">// std::move(a)为右值，这里会调用move constructor </span></span><br><span class="line">    a = <span class="built_in">move</span>(b);    <span class="comment">// move(b)为右值，因此这里会调用move assigment </span></span><br><span class="line">    b = <span class="built_in">move</span>(tmp);  <span class="comment">// move(tmp)为右值，因此这里会调用move assigment </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无序容器(哈希表) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; </span></span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; turingWinner; <span class="comment">//图灵奖获奖名单</span></span><br></pre></td></tr></table></figure>
<p>正则表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">"b.?p.*k"</span>)</span></span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_match(<span class="string">"bopggk"</span>,reg) &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符](参数表) -&gt;返回值类型 &#123; 语句组 &#125;</span><br><span class="line"><span class="comment">// “-&gt;返回值类型”也可以没有， 没有则编译器自动判断返回值类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[] 不使用任何外部变量 </span></span><br><span class="line"><span class="comment">[=] 以传值的形式使用所有外部变量 </span></span><br><span class="line"><span class="comment">[&amp;] 以引用形式使用所有外部变量 </span></span><br><span class="line"><span class="comment">[x, &amp;y] x 以传值形式使用，y 以引用形式使用 </span></span><br><span class="line"><span class="comment">[=,&amp;x,&amp;y] x,y 以引用形式使用，其余变量以传值形式使用 </span></span><br><span class="line"><span class="comment">[&amp;,x,y] x,y 以传值的形式使用，其余变量以引用形式使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>多线程 </p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="C-11高级特性"><a href="#C-11高级特性" class="headerlink" title="C++11高级特性"></a>C++11高级特性</h1><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>static_cast、reinterpret_cast、const_cast和dynamic_cast</p>
<p>static_cast用来进用行比较“自然”和低风险的转换，比 如整型和实数型、字符型之间互相转换。static_cast不能来在不同类型的指针之间互相转换，也不 能用于整型和指针之间的互相转换，也不能用于不同类型的 引用之间的转换。</p>
<p>reinterpret_cast用来进行各种不同类型的指针之间的转换、不同 类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间 的转换。转换的时候，执行的是逐个比特拷贝的操作。</p>
<p>const_cast用来进行去除const属性的转换。将const引用转换成同类型的非 const引用，将const指针转换为同类型的非const指针时用它。</p>
<p>dynamic_cast专门用于将多态基类的指针或引用，强 制转换为派生类的指针或引用，而且能够检查转换的 安全性。对于不安全的指针转换，转换结果返回NULL 指针。 </p>
<p>dynamic_cast不能用于将非多态基类的指针或引用， 强制转换为派生类的指针或引用</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;... <span class="keyword">throw</span> ...&#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>C++标准库中有一些类代表异常，这些类都是从exception类派生而来</p>
<p>bad_typeid</p>
<p>bad_cast</p>
<p>bad_alloc</p>
<p>ios_base::failure</p>
<p>logic_error/out_of_range</p>
<h2 id="运行时类型检查"><a href="#运行时类型检查" class="headerlink" title="运行时类型检查"></a>运行时类型检查</h2><p> C++运算符typeid是单目运算符，可以在程序运行过程中获取一个表达式的值的 类型。typeid运算的返回值是一个type_info类的对象，里面包含了类型的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; //要使用typeinfo，需要此头文件</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1) int is: "</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">int</span>).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) int is: in</span></span><br></pre></td></tr></table></figure>
<h2 id="Boost-Any"><a href="#Boost-Any" class="headerlink" title="Boost.Any"></a>Boost.Any</h2><p> 实现任意类型的存储 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">any a = <span class="number">10</span>;        <span class="comment">// 存储一个 int  </span></span><br><span class="line">a = <span class="built_in">string</span>(“hello world”); <span class="comment">// 存储字符串  </span></span><br><span class="line">a = myclass(); <span class="comment">// 存储自己的对象  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; any_cast&lt;<span class="keyword">int</span>&gt;(a); <span class="comment">// 转换为需要的类型</span></span><br></pre></td></tr></table></figure>
<p>关于 any_cast </p>
<p> 存储的类型与转换的类型不一致会抛出bad_any_cast </p>
<p>指针版不一致返回空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/any.hpp&gt; </span></span></span><br><span class="line"><span class="comment">//成员函数： </span></span><br><span class="line">any(); </span><br><span class="line">~any(); </span><br><span class="line">any(<span class="keyword">const</span> any&amp;); </span><br><span class="line">any&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> any&amp;); </span><br><span class="line"><span class="function">any&amp; <span class="title">swap</span><span class="params">(any&amp;)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt; any(<span class="keyword">const</span> ValueType&amp;); </span><br><span class="line">any&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ValueType&amp;); </span><br><span class="line"><span class="comment">// 独立函数： </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt; </span><br><span class="line"><span class="function">ValueType <span class="title">any_cast</span><span class="params">(<span class="keyword">const</span> any&amp;)</span></span>; <span class="comment">// Throw bad_any_cast </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> ValueType* <span class="title">any_cast</span><span class="params">(<span class="keyword">const</span> any*)</span></span>; <span class="comment">// Return NULL </span></span><br><span class="line"><span class="function">ValueType* <span class="title">any_cast</span><span class="params">(any*)</span></span>;</span><br></pre></td></tr></table></figure>
<p><u> 抽象基类 + 模板派生 = 编译时的多态</u></p>
<h2 id="多文件共享全局变量"><a href="#多文件共享全局变量" class="headerlink" title="多文件共享全局变量"></a>多文件共享全局变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span></span><br></pre></td></tr></table></figure>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>一个类可以有多个直接基类，这叫多继承 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>多继承可能导致二义性，因此需要把直接基类继承base声明为<strong>虚拟基类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span> : </span><br><span class="line">    <span class="keyword">int</span> va;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A  &#123;  <span class="keyword">int</span> vb;    &#125;;     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A  &#123;  <span class="keyword">int</span> vc;    &#125;;         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;  <span class="keyword">int</span>  vd ; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>调用C函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">c_func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>python调用C++</p>
<p>编译成动态链接库c.so，然后拷贝到调用它的python程序的文件夹下: g++ -o c.so -shared -fPIC c.cpp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes </span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> * <span class="comment"># c类型库 </span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">libc = CDLL(<span class="string">'c.so'</span>) <span class="comment">#装入动态链接库 </span></span><br><span class="line">libc.cpp_func1(c_char_p(bytes(<span class="string">"this高达"</span>,encoding=<span class="string">"utf-8"</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(#define XXX/#undef XXX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XXX/#<span class="meta-keyword">ifndef</span> XXX</span></span><br><span class="line">...</span><br><span class="line">(#<span class="keyword">else</span> ...)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="STL-Review"><a href="#STL-Review" class="headerlink" title="STL(Review)"></a>STL(Review)</h1><p>六大部件</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; vi(ia, ia+<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 容器vector，分配器allocator（可以不写）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_if(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">                    not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>))));</span><br><span class="line">    <span class="comment">// 算法count_if 迭代器.begin .end </span></span><br><span class="line">    <span class="comment">// 函数适配器negator binder 函数less</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><p>Set/Map 都是用红黑树实现的 </p>
<p>单向列表<code>forward_list</code>（和GNU_C中的<code>slist</code>完全一样），只有<code>push_front</code></p>
<p><code>array</code>无法扩充，<code>vector</code>两倍扩充</p>
<p><code>deque</code>是一个本质是map到buffer的一些指针，</p>
<p><code>unordered_multimap</code>相当于hash_map</p>
<p><code>hash_set</code> <code>hash_map</code> <code>hash_multiset</code> <code>hash_multimap</code>并不是规范C++语言，但在编译器中实现（注意include的头文件位置） </p>
<p>容器分类：</p>
<p>序列式容器：</p>
<ul>
<li>array</li>
<li>vector<ul>
<li>heap<ul>
<li>priority_queue</li>
</ul>
</li>
</ul>
</li>
<li>list</li>
<li>slist（非标准）</li>
<li>dequeue（分段连续）<ul>
<li>stack</li>
<li>queue</li>
</ul>
</li>
</ul>
<p>关联式容器</p>
<ul>
<li>rb_tree（非公开）<ul>
<li>set</li>
<li>map</li>
<li>multiset</li>
<li>multimap</li>
</ul>
</li>
<li>hashtable（非公开、非标准）<ul>
<li>hash_set</li>
<li>hash_map</li>
<li>hash_multiset</li>
<li>hash_multimap</li>
</ul>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>GNU2.9</strong> sizeof=4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中list node定义为（这里void pointer是有明显问题的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中list iterator定义为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    </span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer operato r-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;node=(link_type)((*node).next);<span class="keyword">return</span> *<span class="keyword">this</span>&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;self tmp=*<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125; </span><br><span class="line">    <span class="comment">// tmp=*this 并不会调用重载的*，因为赋值操作被重载，this被解释为参数 </span></span><br><span class="line">    <span class="comment">// __list_iterator(const iterator&amp; x): node(x.node)&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 之后++*this 也不会调用重载的*，因为*this已被解释为参数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GNU4.9</strong></p>
<p>修改了iterator和node的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc=<span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">list</span>: <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;_Tp&gt; iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iterator 定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span>&#123;</span></span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">    _List_node_base* _M_prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span>:</span> <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">    _Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list的父类定义<code>_List_base</code>有成员<code>_List_impl&lt;_Tp,_A&gt;</code>继承自<code>_A&lt;List_node&lt;_Tp&gt;&gt;</code></p>
<p><u>list的实际实现是<strong>双向、环状</strong>的，为了符合“前闭后开”的要求。</u></p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>两倍扩张</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)&#123;</span><br><span class="line">        construct(finish, x);</span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert_aux(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux(iterator <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)&#123; <span class="comment">// 和push_back里的检查是一样的</span></span><br><span class="line">        construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        copy_backward(<span class="built_in">position</span>, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *<span class="built_in">position</span> = x_copy</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        iterator new_start = data_allocator::allocate(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            new_finish = uninitialized_copy(start, <span class="built_in">position</span>, new_start);</span><br><span class="line">            construct(new_finish, x);</span><br><span class="line">            ++new_finish;</span><br><span class="line">            new_finish = uninitialized_copy(<span class="built_in">position</span>, finish, new_finish); <span class="comment">//拷贝安插点之后的内容，因为insert也可能需要扩充</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁原vector</span></span><br><span class="line">        destroy(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector的iterator（GNU4.9：舍近求远）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span> : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Vector_Base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, <span class="built_in">vector</span>&gt; iterator;</span><br><span class="line">    <span class="comment">// _M_current:_Tp* 本质与GNU2.9相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>TR1版本（C++1之后）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    </span><br><span class="line">    value_type _M_instance[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">// 长度为0的默认为1</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GNU4.9中的定义方式本质与之相同，变得更加复杂，但没有明显好处</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//support for zero-sized array</span></span><br><span class="line">    <span class="keyword">typedef</span> _GLIIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line">    <span class="keyword">typename</span> _AT_Type::_Type _M_elems;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">array_traits</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp _Type[_Nm];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">100</span>] b; <span class="comment">// fail</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T[<span class="number">100</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>看上去连续，其实是分段的：多个buffer（或者称为node）</p>
<p>有一个中控（称为map）维护这些buffer，map是个vector</p>
<p>iterator分为四格：cur,first,last,node（前三个都是指向node中的位置）</p>
<p><code>deque&lt;T&gt;::insert()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">position</span>.cur == start.cur)&#123;</span><br><span class="line">        push_front(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">position</span>.cur == finish.cur)&#123;</span><br><span class="line">        push_back(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert_aux(<span class="built_in">position</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)&#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>)&#123;</span><br><span class="line">        push_front(front());</span><br><span class="line">        ...</span><br><span class="line">        copy(front2, pos1, front1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        push_back(back());</span><br><span class="line">        ...</span><br><span class="line">        copy_backward(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stack</code>和<code>queue</code>更像是适配器，底层默认deque实现。它们都不允许遍历，也不提供<code>iterator</code></p>
<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>例：以<code>rotate</code>函数为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(_ForwardIterator __first,</span></span></span><br><span class="line"><span class="function"><span class="params">                  _ForwardIterator __middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                  _ForwardITerator __last)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::__rotate(__first, __middle, __last,</span><br><span class="line">                  <span class="built_in">std</span>::__iterator_category(__first));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rotate</code>需要知道iterators的三个associated types：为了回答iterator的类型，在C++标准库中设计出5种，<code>iterator_category</code>，<code>difference_type</code>， <code>value_type</code>，<code>reference</code>， <code>pointer</code>，后两种在STL中从未使用过。</p>
<p>回答的方式：<code>typedef</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GNU2.9</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// necessary </span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GNU4.9</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type; <span class="comment">// necessary </span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>萃取机<code>traits</code></p>
<p>分辨iterator是class还是pointer</p>
<p>实现方法：<em>偏特化</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">sturct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const *T&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>标准库中有各式各样的萃取机</u></p>
<h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>除了默认的allocator之外还有</p>
<p>mt_allocator，debug_allocator，pool_allocator，bitmap_allocator，malloc_allocator，new_allocator，要<code>include&lt;ext\相应的头文件&gt;</code></p>
<p><u>分配器可以直接使用，但没有必要</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="keyword">int</span>&gt; alloc;</span><br><span class="line">p = alloc.allocate(<span class="number">1</span>); <span class="comment">// 1个元素</span></span><br><span class="line">alloc.deallocate(p, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>所有分配内存（包括<code>new</code>）都会归结到<code>malloc</code></p>
<p>由于malloc需要记录指针和<em>分配内存大小</em>，这是额外开销。但在容器中，利用元素大小相同这一点，G2.9 标准库 alloc对<code>allocator</code>的实现设计了16个链表，以节省这一部分开销。G4.9中命名为pool_allocator可以调用（不再是默认）。</p>
<h2 id="泛型编程（GP）"><a href="#泛型编程（GP）" class="headerlink" title="泛型编程（GP）"></a>泛型编程（GP）</h2><p>面向对象编程（OOP）把方法放进对象</p>
<p>泛型编程（GP）却将datas和methods分开</p>
<p><em>算法</em>通过<em>迭代器</em>确定操作范围，并通过<em>迭代器</em>取用<em>容器</em>元素。这样<em>算法</em>和<em>容器</em>可以独立开发。</p>
<p>所有的算法，最终涉及元素本身的操作，就是<u>比大小</u></p>
<p>Template模板（略）</p>
<p>Specialization特化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span>...&#125;</span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt;&#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
<p>Partial Specialization偏特化：可以特化一部分template（个数偏特化），也可以改变template</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span>...&#125;</span><br><span class="line"><span class="comment">// 偏特化为指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%90%89%E7%92%83%E7%8C%AB/" rel="tag"># 琉璃猫</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/20/complexity/" rel="prev" title="复杂性问题">
      <i class="fa fa-chevron-left"></i> 复杂性问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/08/cryptography/" rel="next" title="密码学">
      密码学 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C语言输入输出"><span class="nav-number">1.</span> <span class="nav-text">C语言输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scanf"><span class="nav-number">1.1.</span> <span class="nav-text">scanf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#printf"><span class="nav-number">1.2.</span> <span class="nav-text">printf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gets"><span class="nav-number">1.3.</span> <span class="nav-text">gets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sscanf和ssprint"><span class="nav-number">1.4.</span> <span class="nav-text">sscanf和ssprint</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C语言高级内容"><span class="nav-number">2.</span> <span class="nav-text">C语言高级内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数指针"><span class="nav-number">2.1.</span> <span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行参数"><span class="nav-number">2.2.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算"><span class="nav-number">2.3.</span> <span class="nav-text">位运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从C到C"><span class="nav-number">3.</span> <span class="nav-text">从C到C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">3.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态内存分配"><span class="nav-number">3.2.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数"><span class="nav-number">3.3.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数重载"><span class="nav-number">3.4.</span> <span class="nav-text">函数重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类和对象"><span class="nav-number">4.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针"><span class="nav-number">4.1.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态成员"><span class="nav-number">4.2.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员对象和封闭类"><span class="nav-number">4.3.</span> <span class="nav-text">成员对象和封闭类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#友元"><span class="nav-number">4.4.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量成员函数"><span class="nav-number">4.5.</span> <span class="nav-text">常量成员函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符重载"><span class="nav-number">5.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值运算符的重载"><span class="nav-number">5.1.</span> <span class="nav-text">赋值运算符的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载为友元函数"><span class="nav-number">5.2.</span> <span class="nav-text">运算符重载为友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流插入-提取运算符的重载"><span class="nav-number">5.3.</span> <span class="nav-text">流插入&#x2F;提取运算符的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载类型转换运算符"><span class="nav-number">5.4.</span> <span class="nav-text">重载类型转换运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自增-自减运算符重载"><span class="nav-number">5.5.</span> <span class="nav-text">自增&#x2F;自减运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">5.6.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承和派生"><span class="nav-number">6.</span> <span class="nav-text">继承和派生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承关系和复合关系"><span class="nav-number">6.1.</span> <span class="nav-text">继承关系和复合关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖"><span class="nav-number">6.2.</span> <span class="nav-text">覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的保护成员"><span class="nav-number">6.3.</span> <span class="nav-text">类的保护成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#派生类的构造函数"><span class="nav-number">6.4.</span> <span class="nav-text">派生类的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#public继承的赋值兼容规则"><span class="nav-number">6.5.</span> <span class="nav-text">public继承的赋值兼容规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多态"><span class="nav-number">7.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数和多态"><span class="nav-number">7.1.</span> <span class="nav-text">虚函数和多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态的实现原理"><span class="nav-number">7.2.</span> <span class="nav-text">多态的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚析构函数"><span class="nav-number">7.3.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯虚函数和抽象类"><span class="nav-number">7.4.</span> <span class="nav-text">纯虚函数和抽象类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#输入输出"><span class="nav-number">8.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标准流对象"><span class="nav-number">8.1.</span> <span class="nav-text">标准流对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#istream类成员函数"><span class="nav-number">8.2.</span> <span class="nav-text">istream类成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定向"><span class="nav-number">8.3.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流操纵算子"><span class="nav-number">8.4.</span> <span class="nav-text">流操纵算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写"><span class="nav-number">8.5.</span> <span class="nav-text">文件读写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板"><span class="nav-number">9.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板"><span class="nav-number">9.1.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类模板"><span class="nav-number">9.2.</span> <span class="nav-text">类模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类模板和派生"><span class="nav-number">9.3.</span> <span class="nav-text">类模板和派生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类模板和友元"><span class="nav-number">9.4.</span> <span class="nav-text">类模板和友元</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准模板库（STL）"><span class="nav-number">10.</span> <span class="nav-text">标准模板库（STL）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">10.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">10.2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序容器"><span class="nav-number">10.2.1.</span> <span class="nav-text">顺序容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联容器"><span class="nav-number">10.2.2.</span> <span class="nav-text">关联容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器适配器"><span class="nav-number">10.2.3.</span> <span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员函数"><span class="nav-number">10.2.4.</span> <span class="nav-text">成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">10.3.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">10.4.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数对象"><span class="nav-number">10.5.</span> <span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法-1"><span class="nav-number">10.6.</span> <span class="nav-text">算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11特性"><span class="nav-number">11.</span> <span class="nav-text">C++11特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11高级特性"><span class="nav-number">12.</span> <span class="nav-text">C++11高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#强制类型转换"><span class="nav-number">12.1.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">12.2.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时类型检查"><span class="nav-number">12.3.</span> <span class="nav-text">运行时类型检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boost-Any"><span class="nav-number">12.4.</span> <span class="nav-text">Boost.Any</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多文件共享全局变量"><span class="nav-number">12.5.</span> <span class="nav-text">多文件共享全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多继承"><span class="nav-number">12.6.</span> <span class="nav-text">多继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">12.7.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件编译"><span class="nav-number">12.8.</span> <span class="nav-text">条件编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL-Review"><span class="nav-number">13.</span> <span class="nav-text">STL(Review)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器-1"><span class="nav-number">13.1.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">13.1.1.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">13.1.2.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-number">13.1.3.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">13.1.4.</span> <span class="nav-text">deque</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器-1"><span class="nav-number">13.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配器"><span class="nav-number">13.3.</span> <span class="nav-text">分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型编程（GP）"><span class="nav-number">13.4.</span> <span class="nav-text">泛型编程（GP）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="雨游璃风猫"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">雨游璃风猫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/husimplicity/husimplicity.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;husimplicity&#x2F;husimplicity.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tulongzikun@126.com" title="E-Mail → mailto:tulongzikun@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1364161141&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雨游璃风猫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/jquery.min.js"></script>
  <script src="/lib/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

<!-- 鼠标点击有小爱心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!-- 鼠标点击有社会主义核心价值观 -->
<!--<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.151/js/clicksocialvalue.js"></script> -->

<!-- 动态标签 -->
<script type="text/javascript" src="/js/dynamic-title.js"></script> 

<!-- 自定义的脚本 -->
<script type="text/javascript" src="/js/myjs.js"></script>