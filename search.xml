<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小刁猫的PS小本本</title>
    <url>/2020/09/13/photoshop/</url>
    <content><![CDATA[<ul>
<li>找问题对症下药</li>
<li>先整体后局部</li>
<li>先影调后色彩</li>
<li>反复微调</li>
</ul>
<a id="more"></a>
<p>Camera Raw</p>
<h3 id="相片校正"><a href="#相片校正" class="headerlink" title="相片校正"></a>相片校正</h3><ol>
<li>水平校正</li>
<li>镜头校正<ol>
<li>镜头校正</li>
<li>删除色差</li>
<li>要做到<strong>楼是竖直的</strong></li>
</ol>
</li>
<li>相机校准：场景设置</li>
</ol>
<h3 id="五个技术指标"><a href="#五个技术指标" class="headerlink" title="五个技术指标"></a>五个技术指标</h3><ol>
<li><p>黑白场</p>
<ol>
<li>白平衡：选取18%灰</li>
<li>ALT+调整黑/白 观察黑白场是否准确</li>
</ol>
</li>
<li><p>色彩还原</p>
</li>
<li><p>清晰度</p>
<ol>
<li>调整清晰度会影响曝光，加清晰度需要减曝光</li>
<li>锐化是处理<strong>局部</strong>清晰度，在最后做</li>
<li>锐化中ALT+蒙版 看锐化范围</li>
</ol>
</li>
<li><p>饱和度</p>
<ol>
<li>自然饱和度是处理若隐若现的地方，饱和度是整个图</li>
</ol>
</li>
<li><p>层次</p>
<p>丰富合理</p>
</li>
</ol>
<p>以上五点都是基于<strong>直方图</strong>的调整</p>
<p>全局操作：白平衡、对比度清晰度、饱和度、色温色调</p>
<h3 id="局部调整"><a href="#局部调整" class="headerlink" title="局部调整"></a>局部调整</h3><p>渐变滤镜：</p>
<ul>
<li>影响范围从<strong>边框</strong>开始</li>
</ul>
<p>径向滤镜/画笔</p>
<ul>
<li>局部</li>
</ul>
<h3 id="颜色调整"><a href="#颜色调整" class="headerlink" title="颜色调整"></a>颜色调整</h3><p>HSL工具</p>
<ol>
<li>色相/饱和度/明亮度</li>
<li><strong>目标调整工具</strong>：按住左右滑动调节（右边HSL选项卡决定调节内容）</li>
</ol>
<h3 id="调整色调"><a href="#调整色调" class="headerlink" title="调整色调"></a>调整色调</h3><ul>
<li>转换为黑白/将所有颜色饱和度设为最低</li>
<li>在黑白图中调整出更多层次</li>
</ul>
<p>最常见的是<strong>中长调</strong></p>
<p>常见的大师作品都是<strong>低长调</strong>或<strong>低中调</strong>，也有只有黑白两色<strong>黑白调</strong></p>
<h3 id="一些处理"><a href="#一些处理" class="headerlink" title="一些处理"></a>一些处理</h3><p>正片叠底：反选高光区域，正片叠底，调成低调</p>
<p>高ISO降噪：细节-减少杂色的明亮度和颜色+补黑色</p>
<p>接片：至少25%重叠，photomerge+ctrl T变形+内容识别填充+压缩代替剪切</p>
<p>lightroom：专业工具，配置复杂</p>
<p>ctrl+alt+shift+e 盖印</p>
]]></content>
      <categories>
        <category>小鱼干</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>轻兵器</title>
    <url>/2020/06/12/light-weapons/</url>
    <content><![CDATA[<h1 id="远古手枪"><a href="#远古手枪" class="headerlink" title="远古手枪"></a>远古手枪</h1><h2 id="柯尔特左轮"><a href="#柯尔特左轮" class="headerlink" title="柯尔特左轮"></a>柯尔特左轮</h2><p>左轮手枪是美国人塞缨尔柯尔特于1835年发明的，他在发明转轮手枪后，一方面不断改进，从1847年至1860年间，他共改进与推出12种转轮手枪。由于左轮手枪结构简单，操作灵活，很快受到各国官兵的喜爱，19世纪中期以后，这种枪更是风靡全球。</p>
<a id="more"></a>
<p><img src="柯尔特左轮.jpg" alt="柯尔特左轮"></p>
<p>自动手枪出现后，左轮手枪的一些弱点很快暴露出来，左轮手枪容弹量少，枪管与转轮之间有间隙，会漏气和冒烟，初速低，重新装填时间长，威力较小。所以，作为军队的正式装备，左轮手枪逐渐被自动手枪所代替。</p>
<p>但是，由于该枪有一个特殊优点——可靠，特别是对瞎火弹的处理既可靠又简捷，所以，美国和西方一些国家的警察对左轮手枪情有独钟，美国警察中90%的人爱用左轮手枪。</p>
<p>罗副机长喜欢的四星柯尔特左轮是Colt SAA（一种单动式左轮手枪），在西部片中极为闻名。</p>
<p><img src="柯尔特左轮.png" alt="罗副机长喜欢的四星柯尔特左轮"></p>
<h2 id="纳甘左轮（纳甘M1895）"><a href="#纳甘左轮（纳甘M1895）" class="headerlink" title="纳甘左轮（纳甘M1895）"></a>纳甘左轮（纳甘M1895）</h2><p>1895年比利时工业家莱昂·纳甘为俄罗斯研发的7发双动式左轮。相比于其他左轮手枪，纳甘左轮有特殊的气体密封式设计，增加了子弹的初速，并容许武器被抑制。</p>
<p>纳甘左轮被俄罗斯陆军广泛使用，也被苏联所采用。</p>
<p><img src="纳甘左轮.png" alt="为了不那么像狗粮就帮罗副机长升级了一下的纳甘左轮"></p>
<h1 id="早期手枪"><a href="#早期手枪" class="headerlink" title="早期手枪"></a>早期手枪</h1><p>最早的自动手枪主要是德国和奥匈帝国设计出来的。</p>
<h2 id="毛瑟C96"><a href="#毛瑟C96" class="headerlink" title="毛瑟C96"></a>毛瑟C96</h2><p>毛瑟C96手枪（Broomhandle Mauser / Mauser C96），又称驳壳枪，是一种由毛瑟在1896年推出的半自动手枪，因其枪套是一个木制的盒子，所以在中国称为“20响”、“盒子炮”或“匣子枪”。</p>
<p><img src="C96.png" alt="C96"></p>
<p>改进自博查特C93半自动手枪，利用短后坐原理提高了枪弹速度，但也导致大量火药在枪口爆燃，枪口上跳问题以及体积过大、使用起来笨重的问题。</p>
<p>毛瑟C96不如鲁格P08小巧，因而德德国军方仅仅象征性订购了15w支作为补充。但是C96被大量出口中国，1931年进行升级使其可以连发并配备20发长弹夹。</p>
<p>共生产了100w毛瑟C96，其中70%销往中国。</p>
<p>不过罗副机长眼里C96应该是这样的</p>
<p><img src="C96-2.png" alt="罗副机长眼中的C96"></p>
<h2 id="鲁格P08"><a href="#鲁格P08" class="headerlink" title="鲁格P08"></a>鲁格P08</h2><p>鲁格P08是博尔夏特手枪的改进型，1900年开始投入生产。鲁格P08于1908年被选为德军制式手枪并命名为Parabellum08，在德军服役30年之久。</p>
<p><img src="P08.jpg" alt="P08"></p>
<p>鲁格P08采用枪管短后坐式工作原理，其最大的特色是它的肘节式闭锁机。</p>
<p>鲁格P08手枪生产工艺要求极高，构造复杂，零部件较多，成本也高，由于不适合战争时期大量配备，在1938年被德国卡尔·瓦尔特武器制造厂生产的P38手枪取代。到1942年停止生产为止，德军制造了205万支鲁格P08。 </p>
<p>不过罗副机长眼里P08应该是这样的</p>
<p><img src="P08-2.png" alt="罗副机长眼中的P08"></p>
<h2 id="斯太尔M1912"><a href="#斯太尔M1912" class="headerlink" title="斯太尔M1912"></a>斯太尔M1912</h2><p>奥地利斯太尔M1912半自动手枪属早期自动装填手枪，设计师是捷克的伽列·科恩卡，曾参与莫辛纳甘的设计。</p>
<p><img src="斯太尔M1912.png" alt="斯太尔M1912"></p>
<p>斯太尔M1912改进自罗恩-斯塔尔M1907,在1912年装备奥匈帝国军队。</p>
<p>斯太尔1912是在一战和二战中被装备使用的一代名枪。不过，该枪采用的弹药和供弹具非主流产品，因此在二战后便沉寂了。</p>
<p>可惜了，罗副机长那里没有斯太尔M1912。</p>
<h2 id="FN-M1900"><a href="#FN-M1900" class="headerlink" title="FN M1900"></a>FN M1900</h2><p>美国的枪械设计师约翰·勃朗宁设计，由比利时国营赫斯塔尔公司大规模生产，又称FN勃朗宁M1900。</p>
<p><img src="M1900.gif" alt="M1900"></p>
<p>M1900是第一支有套筒的自动手枪，但是其套筒结构和后来的自动手枪有所区别，其复进簧在上，枪管在下。击发系统采用针式击发原理，结构比较简单，没有外露的击锤。</p>
<p>1909年刺杀日本首相伊藤博文、1918年刺杀列宁的都是M1900，萨拉热窝事件中使用的是M1910。</p>
<h2 id="柯尔特M1911"><a href="#柯尔特M1911" class="headerlink" title="柯尔特M1911"></a>柯尔特M1911</h2><p>也是美国人约翰·勃朗宁设计的.45 ACP口径的半自动手枪。M1911称为美军制式手枪达74年（1911-1985），后被M9取代。M1911及其1924的改进型M1911A1共生产了约270w，可能是累计产量最多的自动手枪。<strong>最明显的特征是套筒座后部伸出一个较大的角状突起。</strong></p>
<p><img src="M1911A1.jpg" alt=""></p>
<p>M1911采用了0.45ACP子弹，口径有11.43MM，初速只有246m/s，但是拥有极高的人体抑止力。</p>
<p>相比M1911，M1911A1主要的改进有</p>
<ul>
<li>加宽准星（帕特里奇瞄具）</li>
<li>加长击锤，使之容易被拇指扳动</li>
<li>缩短叩击距离，增加防滑纹</li>
</ul>
<p>毕竟世界名枪…了解一下原理</p>
<iframe src="//player.bilibili.com/player.html?aid=31403223&bvid=BV1JW411o7gn&cid=54887202&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>Colt M1911是罗副机长的第一把枪，不过大概被看成大写的狗粮了吧</p>
<p><img src="M1911.png" alt="罗副机长眼里的Colt M1911"></p>
<p>1980年代佩里·阿内特设计了<strong>灰熊温彻斯特马格努姆手枪</strong>，其实只是柯尔特M1911的特别加大型。</p>
<h2 id="PPK"><a href="#PPK" class="headerlink" title="PPK"></a>PPK</h2><p>德国卡尔·瓦尔特兵工厂1929年推出警用手枪（Polizei Pistole）PP手枪，1931年推出刑警用手枪（Polizei Pistole Kriminal）PPK手枪，PPK手枪比PP手枪短18mm。这两种手枪是二次大战前最先进的手枪，纳粹曾大量秘密配发，希特勒1945年也用PPK自尽，PPK也是007的代名词。</p>
<p><img src="PPK.png" alt="PPK"></p>
<p>PPK采用7.65mm/.32LR口径，初速280m/s，弹夹容量7发。PPK对无防护目标杀伤力巨大，但是穿透力不足。</p>
<p>下面是六星战神PPK，即使没有任何装备闪避值也达到了极高的100点，本身的光环又让她极为适合站在前排作为一个闪T，两者在一起，得到的自然而然的就是优秀的实用性<em>双倍的喜悦</em>。</p>
<p><img src="PPK-2.png" alt="罗副机长喜欢的女仆PPK"></p>
<h2 id="托卡列夫"><a href="#托卡列夫" class="headerlink" title="托卡列夫"></a>托卡列夫</h2><p>苏联装备的第一种半自动手枪，由费多尔·瓦西里耶维奇·托卡列夫设计，由图拉兵工厂生产，简称为TT手枪（也称为TT-33），用以取代纳甘左轮。</p>
<p>1930年托卡列夫以柯尔特M1911为蓝本进行改进，采用7.62mm口径，称为TT-30，后进一步改进的版本称为TT-33，两者都称为托卡列夫手枪。</p>
<p>战争初期的惨败导致生产能力不足，苏联转而用纳甘左轮弥补TT手枪数量不足。知道五十年代马卡洛夫PM手枪诞生后，TT-33于1952年正式停产。</p>
<p>但是托卡列夫优秀的穿透力和<strong>连续精确射击的能力、低廉的成本</strong>得到各国认可，匈牙利仿制为48M，波兰版本为wz.33，中国仿制为51式手枪（后来改进为54式）。</p>
<p><img src="TT33.png" alt="罗副机长的托卡列夫"></p>
<h2 id="马卡洛夫PM"><a href="#马卡洛夫PM" class="headerlink" title="马卡洛夫PM"></a>马卡洛夫PM</h2><p>1945年马卡列夫设计了PM手枪，1951年开始服役军队。</p>
<p>PM手枪的结构和德国沃尔特PP近似，但是也有很多鲜明特点，如零件总数少、尽可能一物多用。马卡洛夫手枪采用简单的自由后坐式工作原理，结构简单，性能可靠，成本低廉。</p>
<p>马卡洛夫的明显缺点是停止作用小和杀伤力低。</p>
<p><img src="PM.png" alt="罗副机长的马卡洛夫PM"></p>
<p>59式手枪是马卡洛夫PM手枪的仿制品。</p>
<p>1990年代后期研制的MP-448 Skyph手枪是马卡洛夫手枪的最新改进型，主要用于出口。</p>
<h2 id="维尔德Mk-II"><a href="#维尔德Mk-II" class="headerlink" title="维尔德Mk II"></a>维尔德Mk II</h2><p>维尔德Mk II是二战中研发的一款带有极强神秘色彩的微声手枪。</p>
<p>该枪作为战时研制出的微声武器，在外形方面突出了简单、实用、便于携带的特点。</p>
<p><img src="MK2.png" alt="维尔德Mk II本体"></p>
<h1 id="现代手枪"><a href="#现代手枪" class="headerlink" title="现代手枪"></a>现代手枪</h1><h2 id="PSM"><a href="#PSM" class="headerlink" title="PSM"></a>PSM</h2><p>PSM是应克格勃要求，由中央精密机械工程研究院1972年设计的紧凑型半自动手枪。</p>
<p>PSM的优点是尺寸非常小，枪身很薄，只有17毫米厚。但作为自卫武器则被批评为很不实用，停止作用和杀伤效果还是太低。在1990年代，PSM手枪倒是一度成为犯罪分子的喜爱，因为这种手枪容易隐藏且又能在近距离穿透警察穿着的软质防弹衣。</p>
<p>PSM手枪采用自由后坐式原理，枪管固定，套筒和底把均为钢结构。扳机为单/双动式，有一个外露击锤和一个滑动式的手动保险，手动保险柄可以解脱击锤的待击状态。</p>
<p><img src="PSM.png" alt="罗副机长的PSM"></p>
<h2 id="VP-70"><a href="#VP-70" class="headerlink" title="VP 70"></a>VP 70</h2><p>VP是德文“Volks Pistole”的缩写，意思是“人民手枪”；70是指正式公开的年份1970年，不过正式推出市场是在1973年。</p>
<p>由于VP70的自动方式为枪机自由后座，靠套筒的惯性和复进簧力来控制套筒的后座运动，加上套筒后坐行程短，当全自动发射时理论射速可达到每分钟2,200发，不易控制且子弹消耗快，所以采用<strong>3发点射</strong>的方式来控制射速和提高精确度。</p>
<p><img src="VP70.png" alt=""></p>
<h2 id="P7"><a href="#P7" class="headerlink" title="P7"></a>P7</h2><p><strong>Heckler &amp; Koch P7</strong>是德国黑克勒-科赫所生产的一种半自动手枪，该枪设计独特，采用了气体延迟反冲原理和独特的握把保险装置。</p>
<p>黑克勒-科赫在1971年所开发的HK4型手枪基础之上，重新设计了一种将握把保险装置移动到前部的手枪，并将其命名为PSP手枪，后来改名P7。</p>
<p>P7折叠了许多配件也大幅缩短了全枪的长度，因此对于便衣警察特别适用。</p>
<p><img src="P7.png" alt="罗副机长的P7"></p>
<h2 id="CZ75"><a href="#CZ75" class="headerlink" title="CZ75"></a>CZ75</h2><p>捷克的国营切斯卡·兹布罗约夫卡公司1975年生产的手枪。</p>
<p>本身没有什么特别出众的特殊的设计，但却是集多种手枪的优点于一身，手感舒适、性能可靠、精度良好，而且其造工独特，价格也不高。</p>
<p><img src="CZ75.jpg" alt="CZ75"></p>
<p>CZ 75被广泛仿制，包括意大利Tanfoglio系列、美国春田P9、中国NZ75，美国Bren Ten、英国的Splitfire等</p>
<p><img src="CZ75.png" alt="罗副机长的CZ75不知道为什么要拿着斧子"></p>
<h2 id="沙漠之鹰"><a href="#沙漠之鹰" class="headerlink" title="沙漠之鹰"></a>沙漠之鹰</h2><p>1980年由美国武器研究公司MRI发布、以色列军事工业公司定型的狩猎手枪。</p>
<p>沙漠之鹰威力极大，射程在100米以上。最初是.357口径，后又发布.44口径。</p>
<p>但是没有被作为军用手枪来列装，主要原因是空枪重达2kg，而且后坐力很大，结构复杂，难以适应恶劣的战场环境。当然，这不妨碍它在众多影片中出现。</p>
<p><img src="沙漠之鹰.jpg" alt="沙漠之鹰"></p>
<p><img src="沙漠之鹰.png" alt="罗副机长的沙漠之鹰"></p>
<h2 id="M9（伯莱塔92F）"><a href="#M9（伯莱塔92F）" class="headerlink" title="M9（伯莱塔92F）"></a>M9（伯莱塔92F）</h2><p>1985年由意大利伯莱塔公司研制的伯莱塔92F型手枪力压群雄，被美军选为新一代制式军用手枪、并在美军中重新命名为M9手枪，取代了M1911装备美军。<strong>M9的主要外形特点是口部外露一段枪管，而且套筒上方有一个很长的开孔，枪管几乎全部显露在外。M9和92F的主要区别是扳机护圈前部不光滑</strong>。</p>
<p><img src="M9.jpg" alt="M9"></p>
<p>M9手枪采用枪管短行程后座作用原理、闭锁方式为卡铁下沉式，单/双动扳机设计，以15发可拆式弹匣供弹，枪长217mm，重1.1kg(包括装弹弹夹），弹头初速390米/秒。</p>
<p>主要优点有体积小、重量轻、可靠性好等。双排弹匣容量大，但是压满子弹会导致弹力变弱。</p>
<p>美军在数十次战争中使用M9手枪，包括科索沃、波斯尼亚、索马里、<a href="https://baike.baidu.com/item/海地" target="_blank" rel="noopener">海地</a>、波斯湾、巴拿马等等，历经这些战争后，伯莱塔M9倍受赞誉。</p>
<p><img src="M9-2.png" alt="罗副机长眼中的大破M9"></p>
<p><strong>92式手枪</strong>是中国北方工业公司设计的半自动手枪。其研发约在1994年开始，92式的机械结构吸收了贝瑞塔92F／FS的设计，而在外型上则与HK USP相似。</p>
<p><img src="92.png" alt="罗副机长眼中的92式"></p>
<h2 id="格洛克17"><a href="#格洛克17" class="headerlink" title="格洛克17"></a>格洛克17</h2><p>1983年奥地利格洛克公司应奥地利陆军的要求研制的。现今发展出4种口径、8种型号，被40多个国家军队和警察装备。</p>
<p><img src="Glock17.jpg" alt="Glock17"></p>
<p>格洛克17正常装弹量是17发。</p>
<p>格洛克17及其衍生型都以其可靠性著称。因为坚固耐用和简单化的设计，它们能在一些极端的环境下正常工作，并且能使用相当多种类的子弹，更可改装成冲锋枪。它的零件也不多，因此维修相当方便，也因为后坐力小而增加人气。</p>
<p>下面虽然是三星，不过颇为稀有</p>
<p><img src="Glock17.png" alt="罗副机长的格洛克17"></p>
<h2 id="SIG-P226"><a href="#SIG-P226" class="headerlink" title="SIG P226"></a>SIG P226</h2><p>P226原本是瑞士/德国SIG公司为1980年代初期参与美国XM9手枪竞争计划而设计的，后来成为伯莱塔92F外唯一通过测试的手枪，但由于价格问题而被挤出局。2010年初美军正式列装，更名为MK25。</p>
<p>P226使用的SIG闭锁系统改进自由勃朗宁研制的闭锁系统，并被众多枪械制造商所仿制。</p>
<p><img src="P226.jpg" alt="P226"></p>
<p>另外1988年SIG公司为了加入大口径弹药市场，在P228基础上研发了P229型手枪。P229常被当做P226的便携版。</p>
<p><img src="P226.png" alt="罗副机长的P226不会缺席"></p>
<h2 id="Mk-23"><a href="#Mk-23" class="headerlink" title="Mk 23"></a>Mk 23</h2><p>1990年，美国特种作战司令部应要求研发一款0.45英寸口径的自动手枪。Mk23由枪械设计师海穆特·威尔多设计，黑克勒-科赫生产的一款半自动手枪。</p>
<p>Mk23是第一把被设定为“进攻型”的手枪，但是作战人员对它并不感兴趣，主要原因是它太大了，而且整个系统太昂贵。</p>
<p><img src="Mk23.png" alt="罗副机长的喵23"></p>
<p>由于Mk23标准太高，因此在1992-1993年推出了轻量化版本USP。USP使用了传统的勃朗宁闭锁式枪机，并被设计成单双动式。</p>
<p>1994年推出缩小版的USP，USP Compact</p>
<p><img src="USP_Compact.png" alt=""></p>
<h2 id="雅丽金PYa（MP443）"><a href="#雅丽金PYa（MP443）" class="headerlink" title="雅丽金PYa（MP443）"></a>雅丽金PYa（MP443）</h2><p>雅丽金手枪，也成为了MP443“乌鸦”手枪，于1993年由俄罗斯国内最大的手机生产商伊热夫斯克兵工厂研制。雅丽金的设计借鉴了运动手枪的结构复杂的弹夹卡笋。外形与SIG P226有相似之处。</p>
<p><img src="PYa.jpg" alt="雅丽金PYa"></p>
<p>雅丽金PYa被俄罗斯军队正式采用，但由于资金问题，只少量装备了特种部队。</p>
<p>另外，PYa有民用版本MP446“海盗”。不过罗副机长那儿只有二星…</p>
<p><img src="MP446.png" alt="罗副机长的MP446"></p>
<h2 id="瓦尔特-P99"><a href="#瓦尔特-P99" class="headerlink" title="瓦尔特 P99"></a>瓦尔特 P99</h2><p>瓦尔特公司在1988年推出了P88 9mm手枪，但可惜流行不起来。在1994年，瓦尔特公司以P88为基础重新设计一种适合平民自卫或执法人员使用的半自动手枪，并吸收了市场上许多新产品的研究成果。瓦尔特的新手枪在1996年对外公开，并命名为P99自动手枪。</p>
<p>P99采用枪管短后坐原理，其设计是仿照数十年前SIG Sauer P220手枪上的改进的勃朗宁式闭锁机构，通过底把内一块闭锁卡铁与枪管尾部下方的一个斜槽作用使枪管上下摆动而实现开锁和闭锁。</p>
<p>P99标准型的击发机构为单/双动式，第一发为双动，扳机扣力为4kg，后续的都为单动，扳机扣力为2kg。</p>
<p><img src="P99.png" alt="罗副机长的小萝莉P99"></p>
<h1 id="特殊手枪"><a href="#特殊手枪" class="headerlink" title="特殊手枪"></a>特殊手枪</h1><h2 id="SPP-1水枪"><a href="#SPP-1水枪" class="headerlink" title="SPP-1水枪"></a>SPP-1水枪</h2><p><strong>一般子弹在水中威力很小</strong>，为了在与敌方战斗蛙人对阵时有更大的战术优势，前苏联海军在1960年代后期要求中央精密机械研究所研制专门的水下手枪，该枪被命名为SPP-1，是“特种水下手枪”的缩写（Spetsialnyj Podvodnyj Pistolet）。</p>
<p>该枪于1971年开始装备前苏联海军的战斗蛙人部队。后来SPP-1经过改进，重新定型为SPP-1M，目前SPP-1M仍然被俄罗斯海军特种部队所装备，并通过俄罗斯政府控制的军事销售组织出口到其他国家。</p>
<p>SPP-1水下手枪使用专门的SPS水下弹药，发射一种又长又细的箭形弹头。使用40mm长的突缘瓶颈形水密弹壳，弹头由低碳钢制成，弹径4.5mm，长115mm，重12.8g。全弹长145mm，重17.5g。这种箭形弹的弹尖顶端是平的，它通过滑膛枪管发射，依靠流体力学效应来稳定，而由于发射药的爆发力比压缩空气强，因此SPP-1水下手枪在水底下的有效射程和穿透力比以往潜水员用的梭镖更强。在其有效射程内可轻易地穿透保暖潜水衣或5mm厚的塑料面罩后对潜水员造成严重创伤。</p>
<p>不过这种箭形弹在空气中飞行不太稳定，因此在水面上使用时有效射程很有限，通常只能应急时使用。</p>
<p><img src="SPP.png" alt="罗副机长的SPP-1"></p>
]]></content>
      <categories>
        <category>小鱼干</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>阿尔托莉雅的shell</title>
    <url>/2020/06/09/shell/</url>
    <content><![CDATA[<h3 id="切分数据集"><a href="#切分数据集" class="headerlink" title="切分数据集"></a>切分数据集</h3><p> <code>ls -l DATA_DIR | awk &#39;BEGIN{srand();} {printf &quot;%s %s\n&quot;, rand(), $0}&#39; | sort -k1n | awk &#39;{gsub($1FS,&quot;&quot;); print $0}&#39; | awk &#39;{print $9}&#39; | awk &#39;FNR&lt;=2000&#39; | xargs -i sudo mv DATA_DIR/{} TEST-DIR/.</code></p>
<p><code>ls -l DATA_DIR | awk &#39;BEGIN{srand();} {print rand(), $0}&#39; | sort -k1n | awk &#39;{print $10}&#39; | awk &#39;FNR&lt;=2000&#39; | xargs -i sudo mv DATA_DIR/{} TEST-DIR/.</code>【魏武精修版】</p>
<a id="more"></a>
<h3 id="杀幽灵的方法"><a href="#杀幽灵的方法" class="headerlink" title="杀幽灵的方法"></a>杀幽灵的方法</h3><p><code>ps aux | grep &quot;cuda 1&quot; | awk &#39;{print $2}&#39; | xargs kill -9</code></p>
<h3 id="批量重命名文件-注意，不能出现同名否则会覆盖）"><a href="#批量重命名文件-注意，不能出现同名否则会覆盖）" class="headerlink" title="批量重命名文件 (注意，不能出现同名否则会覆盖）"></a>批量重命名文件 (注意，不能出现同名否则会覆盖）</h3><p><code>c=0;for i in *.pdf;do mv -f $i $((c+=1)).pdf;done</code></p>
<h3 id="将图片批量转换为PDF"><a href="#将图片批量转换为PDF" class="headerlink" title="将图片批量转换为PDF"></a>将图片批量转换为PDF</h3><p><code>convert *.jpg a.pdf</code></p>
<h3 id="清理回收站"><a href="#清理回收站" class="headerlink" title="清理回收站"></a>清理回收站</h3><p><code>cd ~/.local/share/Trash； sudo su；rm -fr files/*</code></p>
<h3 id="合并pdf"><a href="#合并pdf" class="headerlink" title="合并pdf"></a>合并pdf</h3><p><code>pdftk *.pdf cat output 1.pdf</code></p>
<h3 id="看文件夹大小"><a href="#看文件夹大小" class="headerlink" title="看文件夹大小"></a>看文件夹大小</h3><p><code>sudo du -h --max-depth=1</code></p>
<h3 id="统计文件个数"><a href="#统计文件个数" class="headerlink" title="统计文件个数"></a>统计文件个数</h3><p><code>ls -al | wc -l | awk &#39;{print $1 -3}&#39;</code></p>
<h3 id="自动登录远程主机"><a href="#自动登录远程主机" class="headerlink" title="自动登录远程主机"></a>自动登录远程主机</h3><p>在本地运行命令:</p>
<p><code>ssh-keygen -t rsa</code> (连续三次回车,即在本地生成了公钥和私钥,不设置密码)</p>
<p><code>ssh xxx@xx.xx.xx.xx &quot;mkdir .ssh&quot;</code>(需要输入密码)</p>
<p><code>scp ~/.ssh/id_rsa.pub xxx@xx.xx.xx.xx:.ssh/id_rsa.pub</code> (需要输入密码)</p>
<p>在远程机的命令:</p>
<p><code>touch /root/.ssh/authorized_keys</code> (如果已经存在这个文件, 跳过这条)</p>
<p><code>cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</code> (将id_rsa.pub的内容追加到authorized_keys 中)</p>
<p>回到本地机器:</p>
<p><code>ssh xxx@xx.xx.xx.xx</code> (不需要密码, 登录成功)</p>
<h3 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h3><p>在tmux运行然后要退出但是让tmux在后台运行，使用<code>Ctrl+B d</code><br>要在命令行重新回到tmux，在命令行输入<code>tmux a</code><br>如果开了多个tmux session，在<code>tmux a</code>进入任意的tmux之后，使用<code>Ctrl+B s</code></p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>根目录：<code>export PYTHONPATH=pwd:$PYTHONPATH</code></p>
<p>访问服务器 Jupyter Notebook<br><code>ssh -L 8000:localhost:8888 xxxx@xx.xx.xx.xx</code> (8000是本地的port,随便换)</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>撤销commit: <code>git reset --soft HEAD</code><br>批量删除Branch: <code>git branch | grep -v &quot;master&quot; |xargs git branch -D</code><br>清楚无用Branch: <code>git remote prune origin</code><br>合并最近4次提交记录 <code>git rebase -i HEAD~4</code> (先合并 后提交)s</p>
]]></content>
      <categories>
        <category>小鱼干</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>现代物理有机化学</title>
    <url>/2020/05/25/modern-physics-chemistry/</url>
    <content><![CDATA[<h1 id="导论：分子结构和化学键模型"><a href="#导论：分子结构和化学键模型" class="headerlink" title="导论：分子结构和化学键模型"></a>导论：分子结构和化学键模型</h1><p>原子的<strong>Bohr模型</strong>认为电子在特定轨道上运行。原子轨道是解<strong>Schrodinger方程</strong>得来的。</p>
<p>薛定谔方程的解是波函数。包括四个量子数，<strong>主量子数</strong>（决定该原子的价层），<strong>角量子数</strong>（或者描述为spdf，定义空间分布），<strong>磁量子数</strong>（决定轨道在空间中的方向），<strong>自旋量子数</strong>（可以取$\pm 1/2$）</p>
<p><strong>能量最低原理</strong>要求电子填充能量较低的轨道，<strong>Pauli原理</strong>要求同一轨道需要<strong>自旋配对</strong>，<strong>洪特规则</strong>告诉我们<strong>简并轨道</strong>只需要逐个填充保持自选方向一致。</p>
<p><strong>Lewis结构</strong>和<strong>形式电荷</strong>只是一种记录方法。</p>
<p><strong>价电子互斥规则（VSEPR）</strong>：配基在空间上会尽量互相原理，这决定了分子的<strong>几何构型</strong>。孤对电子比较“大”一些，只是对观察现象的一个合理解释。</p>
<a id="more"></a>
<p>Pauling提出<strong>杂化</strong>理论，sp，sp2，sp3杂化轨道常用来解释有机分子的几何形状。杂化理论为键角偏差提供一个能替代VSEPR的解释：s成分减小，键角逐渐减小。</p>
<p>化学键理论主要有两种：<strong>价键理论（VBT）</strong>和<strong>分子轨道理论（MOT）</strong>。</p>
<p>价键理论中，相邻原子共享电子对形成分子。从价键理论和杂化过程派生而来<strong>$\sigma$键和$\pi$键</strong>的概念。两个原子之间的成键数目称为<strong>键级</strong>。分子轨道实际上是VBT/MOT混合模型的结果。</p>
<p>具有不均衡共享成键电子的共价键称为<strong>极性共价键</strong>。</p>
<p><strong>电负性</strong>：Pauling电负性是分子中一个原子吸电子的能力，Mulliken定义电负性是<strong>电子亲和势</strong>和<strong>离子势</strong>。<u>F是电负性最大的元素。</u></p>
<p><strong>静电势能面</strong>首先给分子一个表面，把每个原子当成半径等于其<strong>van der Waals</strong>半径的球。然后根据静电势对该表面着色。</p>
<p><strong>诱导效应</strong>是电负性更强的原子或基团通过$\sigma$键吸电子的现象。一些情况如1-氯代丁烷中会呈现电荷正负<em>交替变化</em>的模式。</p>
<p><strong>基团电负性</strong>：CH3基团和C是一样的，CF3与O相当，拥有完整正电荷有最强的基团电负性（如NH3+）</p>
<p><strong>杂化效应</strong>：一般而言，电负性sp&gt;sp2&gt;sp3。</p>
<p>电负性和杂化理论解释氨分子或水分子键角小于甲烷分子：孤对电子包含更多s轨道成分，这样与H形成的键包含更多p轨道成分，从而减小键角。</p>
<p><u>多数情况下，电负性和杂化理论比VSEPR更合理。</u></p>
<p><strong>键偶极</strong>是极性共价键相关的局部例句，定量计算用<strong>偶极矩$\mu$</strong>（是电荷与距离的乘积）。<strong>分子偶极矩</strong>是分子固有的明确属性。</p>
<p>在对分子电荷分布的完整描述中，有单极、偶极、四极、八极、十六极等。离子中单极占主导地位，中性分子一般忽略偶极之后的项。<u>最常见的四级矩是苯分子中的。</u></p>
<p><strong>共轭</strong>也被称作<strong>中介现象</strong>，苯环的Kekule式就是一个例子。共振结构越多分子越稳定，称之为<strong>共振能</strong>或者<strong>离域能</strong>。</p>
<p>共振结构合理的一些准则：原子满足惰性气体的电子构型，形成最大数目的共价键等等</p>
<p>键长的影响因素：</p>
<ul>
<li>多重键倾向于更短</li>
<li>杂化s性质越多，键长越短（有时候这个因素会被低估）</li>
<li>原子半径</li>
</ul>
<p><strong>极化率</strong>是一个单位电场梯度能诱导的偶极大小。极化率和电负性呈现负相关。</p>
<h2 id="现代理论"><a href="#现代理论" class="headerlink" title="现代理论"></a>现代理论</h2><p><strong>分子轨道理论</strong>认为电子位于高度离域的分子轨道中，这些轨道遍布整个分子。</p>
<p><strong>定性分子轨道理论（QMOT）</strong>是预测离域分子轨道的一系列规则（见Gimare，1979）</p>
<p>实例分析：平面型甲基</p>
<p>成键轨道ABC，非键轨道D，反键轨道E和另外两个</p>
<p><img src="ch3-1.png" alt=""></p>
<p>Walsh示意图：角锥形甲基</p>
<p>最大的变化是D是成键轨道。A的能量<em>少量</em>变低，BC能量升高。之后DE有相同的<em>对称性</em>，两者组合成D’E’。</p>
<p><img src="ch3-2.png" alt=""></p>
<p><strong>官能团</strong>的轨道称为<strong>基团轨道</strong>。甲基的基团轨道赋予了特定的名字（如上图），MH3的结构都是如此，而根据不同的M决定放入电子数目以及角锥形还是平面型。</p>
<p>Walsh示意图：CH2</p>
<p>分析方法是类似的。</p>
<p><img src="ch2.png" alt=""></p>
<p>游离态H2O两对孤对电子不等价证明了这一点。而在液态水中，由于其他分子的影响，体系对称性降低，C’和D可以组合成类似sp3的孤对电子轨道。</p>
<p>组合两个独立分子<em>全充满</em>轨道的结构都是<em>去稳定</em>的，称为<strong>闭壳层排斥</strong>。</p>
<p><strong>微扰理论</strong>：简并轨道的组合称为<strong>一阶微扰</strong>，非简并轨道的组合称为<strong>二阶微扰</strong>。</p>
<p>初始轨道之间能量差别越大，组合作用越弱，称为<strong>能阈定理</strong>。</p>
<p>分子组合实例分析：乙烷</p>
<p>主要C-C成键轨道是$\sigma(out)+\sigma(out)$分子轨道。</p>
<p><img src="c2h6.png" alt=""></p>
<p>乙烯分子中双键主要$\sigma$键是$\sigma(out)+\sigma(out)$，$\pi$键是$p+p$。<strong>LUMO</strong>是p轨道的反相组合。</p>
<p>实例分析：甲醛</p>
<p><img src="ch2o.png" alt=""></p>
<p>甲醛和乙烯是等电子体，结构相似。不同的是<strong>HOMO</strong>是$\pi(CH_2)-p_x$的孤对电子轨道，下面第二个也是孤对电子轨道。</p>
<p>完全离域甲醛应该有两个不同的孤对电子轨道。</p>
<p>甲醛分子作为羰基原型，注意到其$\pi^*$分子轨道可以预测亲核试剂会从背面进攻碳原子，而质子化将发生在氧原子上。</p>
<p>更复杂的烷烃：$CH_3(CH_2)_nCH_3$，其中C-C骨架处理方式和$H_2O$类似，用$\sigma(out)$轨道和p轨道形成$sp^3$杂化，而两端的甲基用$\sigma(out)$连接C-C骨架。</p>
<p>丙烯：甲基的$\pi(CH_3)$与烯烃的$\pi$轨道形成新的分子轨道。</p>
<p><img src="ch3chch2.png" alt=""></p>
<p><strong>三中心二电子键</strong>：缺电子的情况，如硼烷/碳正离子，会形成B-H-B这样的桥结构。</p>
<h2 id="反应中间体"><a href="#反应中间体" class="headerlink" title="反应中间体"></a>反应中间体</h2><p>碳正离子</p>
<p>两种类型：三配位碳正离子$R_3C$，五配位碳正离子$R_5C$/三中心二电子键</p>
<p>经典碳正离子的模式分子是甲基正离子，因为D轨道没有电子，它更容易形成平面构型。乙基正离子在液相/气相中会很快重排成一个C-H-C的桥结构。</p>
<p>非经典的碳正离子代表是$CH_5^+$可以看作角锥形$CH_3^+$的$\sigma(out)$和$H_2$的$\sigma$成键轨道连在一起，这里形成三中心二电子键结构。$CH_5^+$存在一个快速重排过程，使得5个H完全等同。</p>
<p>碳负离子</p>
<p>简单的角锥形碳负离子结构中，碳负离子的$\sigma(out)$有一对孤对电子，可以看成$sp^3$杂化。<em>翻转能垒</em>比较低，因此碳负离子表现出平面构型的性质。</p>
<p>几个因素可以显著增大碳负离子的<em>翻转能垒</em>，一个是形成<em>小环</em>，另一个是连接一个电负性强的取代基（此时更多电子得以稳定）。</p>
<p>自由基</p>
<p>甲基自由基有七个电子，单电子占据$\sigma(out)$轨道，所以他对于平面形/角锥形没有明显倾向。</p>
<p>另有<em>自由基正离子</em>，比如单电子氧化的烯烃。</p>
<p>碳烯（卡宾）</p>
<p>模式分子为<em>亚甲基</em>（$CH_2$），6个电子中两对占据AB，剩下两个占据C/D简并轨道。根据体系自旋状态，分为<em>三线态</em>和<em>单线态</em>。</p>
<p>简单烯烃倾向于三线态，适当引入取代基（N、O、卤素）可以改变这一倾向。</p>
<h1 id="张力和稳定性"><a href="#张力和稳定性" class="headerlink" title="张力和稳定性"></a>张力和稳定性</h1><h2 id="能量的类型"><a href="#能量的类型" class="headerlink" title="能量的类型"></a>能量的类型</h2><p><strong>Gibbs自由能</strong>：</p>
<p>只关心相对能量([]表示浓度)</p>
<script type="math/tex; mode=display">
K_{eq}=[B]/[A],\:ln(K_{eq})=\frac{-\Delta G}{RT}</script><p>自由能包括<strong>焓$\Delta H$</strong>和<strong>熵$\Delta S$</strong>两部分，他们的联系可以用Gibbs-Helmholtz方程式来表示</p>
<script type="math/tex; mode=display">
\Delta G=\Delta H-T\Delta S</script><p>焓是恒压不做工的情况下，分子不同组分热量的变化。考察的办法就是考察<strong>化学键强度</strong>的变化。</p>
<p>熵是体系混乱度，也就是自由度（包括平动/转动/振动自由度）。熵变在比较相似结构时通常很小，而在结构显著变化（如成环）时非常重要。</p>
<p>环化的熵损失随着环增大而增大（环己烷是个特例）。</p>
<p><strong>键解离能（BDE）</strong></p>
<p>与键强度相关的热力学量，定义</p>
<script type="math/tex; mode=display">
R-R\rightarrow R^*+R^*,\:\Delta H=BDE</script><p>一般结论：键长越短，键就越强。</p>
<p>卤代甲烷：F&gt;Cl&gt;Br&gt;I</p>
<p>杂化和共振：C(sp)-H&gt;C(sp2)-H&gt;C(sp3)-H</p>
<p>O-H是最强的化学键之一，因此羟基自由基具有很强的反应活性。</p>
<p><strong>键伸缩</strong></p>
<p><strong>简正模式</strong>是分子具有的振动自由度，每一项都有各自的<strong>基频</strong>，每一种基频都可以用一个<strong>势能函数</strong>来描述。</p>
<p>键伸缩的简单势能函数<strong>Morse势能函数</strong>描绘能力与原子间距离的关系。Morse势能函数的形状表明它是一个<strong>非简谐共振子</strong>。</p>
<p>化学键的伸缩收到Morse势能函数的限制，其振动的能量是量子化的。因此化学键不是Morse势能最低点，而是<strong>零点能（ZPE）</strong>。</p>
<p>可以认为化学键伸缩振动导致其均裂，BDE=ZPE和无限远点的差值。</p>
<p><strong>生成热和燃烧热</strong></p>
<p>总能量定义为断裂分子内所有化学键的能量，<strong>生成热</strong>定义为从组成元素形成分子放出的热量。生成热直接测定比较困难，可以通过CO2和H2O进行测定。</p>
<p>苯热力学不稳定，但是动力学是稳定的。</p>
<p><strong>基团加和法</strong></p>
<p>基团贡献也称为<strong>Benson增量</strong>。基团加和法的准确程度取决于到处基团贡献值的热力学实验数据的准确程度。</p>
<p>特定基团对熵也有固定的贡献值，但实验数据比较匮乏。</p>
<p>基团加和法可以计算有机分子的<strong>标准生成热</strong>，对环己烷的结果是准确的，但对其他环烷烃结果不尽如人意。因此需要引入<strong>张力能</strong>，这就是实验测定标准生成热和基团加成法的差值。</p>
<h2 id="反应中间体的热化学"><a href="#反应中间体的热化学" class="headerlink" title="反应中间体的热化学"></a>反应中间体的热化学</h2><p><strong>持久性</strong>是指寿命比较长，是动力学概念。<strong>稳定性</strong>是反应中间体的内在特性。</p>
<p>1900年Gomberg制备了三苯基甲基，这个自由基能够在室温溶液中永久稳定存在，其<u>影响<em>持久性</em>的主要因素是位阻效应</u>。</p>
<p>可以<strong>用氢负离子的亲和性（HIA）来衡量碳正离子的稳定性</strong>。定义如下</p>
<script type="math/tex; mode=display">
RH\rightarrow R^++H^-,\Delta H^-=HIA</script><p>裸露在气相中的<em>离子</em>迫切需要溶剂化，而小的离子增加碳原子可以缓解这种需求，所以正离子越大越稳定。而碳原子个数对自由基影响不明显。</p>
<p>气相中二级与一级碳正离子的区别比烯丙基的共轭效应重要的多。而烯丙基正离子比丙基正离子文登的多。</p>
<p>比较稳定的三级碳正离子在水中的寿命约为$10^{-10}$s。</p>
<p>衡量<strong>碳负离子</strong>的稳定性用下面的反应式</p>
<script type="math/tex; mode=display">
HA\rightarrow A^-+H^+</script><p>可以用$pK_a$（酸在水中平衡解离常数的负对数）来衡量稳定性</p>
<p>$pK_a$越大离子越不稳定</p>
<h2 id="基本构象分析"><a href="#基本构象分析" class="headerlink" title="基本构象分析"></a>基本构象分析</h2><h3 id="非环体系：扭转角的势能面"><a href="#非环体系：扭转角的势能面" class="headerlink" title="非环体系：扭转角的势能面"></a>非环体系：扭转角的势能面</h3><p>乙烷的交叉构象比重叠构象更稳定，两者相差3 kcal/mol。重叠构象的势能以<strong>扭转张力</strong>的形式存在。</p>
<p>丁烷中考察绕C2-C3键的<strong>扭转势能</strong>，对交叉式比邻交叉式稳定0.9 kcal/mol，这种作用叫<strong>临近排斥</strong>。</p>
<p>临近排斥对基团加成法的校正称为<strong>邻交叉校正</strong>，另一个常见的校正是<strong>顺式烯烃校正</strong>。顺式构型的烯烃标准生成热增加1 kcal/mol。</p>
<p>$CH_3-X$键的<strong>旋转能垒</strong>随X的增大而增加。孤对电子带来排斥作用要比C-H键的排斥作用小，所以C-O/C-N键的旋转能垒比C-C键低。</p>
<p>四烷基乙烷中则是对交叉式和邻交叉式<em>完全一样稳定</em>。</p>
<p>g+g（邻交叉式排布）戊烷作用会导致<strong>同侧戊烷张力</strong>，g+g比g-g不稳定约3 kcal/mol。与此相类似的一种现象是<strong>烯丙基张力</strong>，简称为A张力，因为这个原因，顺式烯烃倾向于线性构象。</p>
<h3 id="基本环形体系"><a href="#基本环形体系" class="headerlink" title="基本环形体系"></a>基本环形体系</h3><p>环丙烷张力能是27.5 kcal/mol，主要来自于偏离正常值的键角。</p>
<p>环丁烷平面构象会导致C-H发生不利的重叠，因此会发生折叠。两种折叠构象之间反转称为<strong>蝴蝶翻转</strong>，转化所需能垒很小。</p>
<p>环戊烷也会发生折叠，得到<strong>信封型构象</strong>和<strong>半椅型构象</strong>。这两种构象能量几乎相同，他们之间转化非常迅速，其能垒小于2 kcal/mol，这个转换称为<strong>伪旋转</strong>。</p>
<p>环己烷采用<strong>刚性的椅型构象</strong>。考虑邻交叉作用，因此推断平伏位置比直立位置的取代基更稳定。对大多数取代基而言，平伏位置比较有利，这种选择性的强弱叫做环己烷的<strong>A值</strong>。</p>
<p><img src="环己烷构象.png" alt="环己烷构象的转换（伪旋转）"></p>
<p>更大的环系：一般而言，环越大张力能越小。n=6时张力能很小是个特例。中等环的张力来源于<strong>跨环张力</strong>。</p>
<p>源自非标准键角的张力叫做<strong>键角张力（Baeyer张力）</strong>。环中张力一部分也来自扭转角，称为<strong>Pitzer张力</strong>。</p>
<p>大环中能垒通常比较小。</p>
<p>双环共享一个碳原子，称为<strong>螺环</strong>；共享两个碳原子，称为<strong>桥环</strong>，两个碳原子称为<strong>桥头碳</strong>。萘烷就是双环[4,4,0]癸烷。</p>
<p>小环中的烯键比非环体系中的烯键减稳定作用更大。</p>
<p><strong>Bredt规则</strong>判断双环体系中的桥头是否能引入烯键：桥环[a,b,c]烷烃中，三者之和下限为7。处于桥头位置，存在很大张力的烯键也称为<strong>反Bredt规则烯烃</strong>。</p>
<h2 id="电子效应"><a href="#电子效应" class="headerlink" title="电子效应"></a>电子效应</h2><h3 id="pi-体系的作用"><a href="#pi-体系的作用" class="headerlink" title="$\pi$体系的作用"></a>$\pi$体系的作用</h3><p>衡量烯烃稳定性的一种方法是测量它的<strong>氢化热</strong>，对于大多数常见烯烃而言，氢化热约为</p>
<p>-27.75 kcal/mol。</p>
<p>烯键的直接相连称为<strong>共轭</strong>，共轭可使$\pi$分子轨道在所有$sp^2$杂化的碳原子间<strong>离域</strong>。离域能够稳定$\pi$体系，但这一般不是个非常大的效应。</p>
<p><strong>芳香性</strong>的<strong>Huckel 4n+2规则</strong>，对任何具有4n+2个电子的碳氢化合物或者杂环化合物，如果形成完全的共轭的环状$\pi$体系，则具有芳香性。通常认为22个电子是芳香性体系的上限。</p>
<p>芳香性分子的稳定超乎想象。在化学性质上表现为易进行亲电取代反应，不易进行加成反应和氧化反应。</p>
<p>不完全共轭的环也可能有芳香性，称为<strong>同芳香性</strong>。</p>
<p>定量描述芳香性的稳定化能的一种分析方法是<strong>等键反应</strong>。据此推算芳香性对苯环的稳定化能为32 kcal/mol。</p>
<p>有4n个电子的$\pi$体系通常是不稳定的，称为<strong>反芳香性</strong>。</p>
<h3 id="杂原子影响"><a href="#杂原子影响" class="headerlink" title="杂原子影响"></a>杂原子影响</h3><p>键长效应：C-O和C-N键比C-C键短，这通常增加立体张力。</p>
<p>轨道效应：考虑为<strong>给体-受体相互作用</strong>，较高能量的占据轨道向较低能量的空轨道提供电子，产生稳定作用。</p>
<p>糖化学中的<strong>异头效应</strong>是反立体位阻的倾向，表现为糖苷键和缩醛碳原子上的链接倾向于直立而非平伏，这种倾向来源于环外C-O键与环内氧原子孤对电子处于反式。</p>
<h2 id="高张力分子"><a href="#高张力分子" class="headerlink" title="高张力分子"></a>高张力分子</h2><p>C-C键键长通常小于等于1.59A，超长的C-C键都是热力学不稳定的。造成超长C-C键长/超大C-C-C键角的首选方法是立体位阻（如六苯基乙烷）。</p>
<p>一些小环是热力学不稳定，但动力学稳定的（如四面体烷）。</p>
<p>旋转能垒特别大以至于能够分离不同构象异构体的称为<strong>阻转异构体</strong>。一种方法是造成大的立体位阻，如利用三苯烯构造的二甲基双三蝶烯。</p>
<h2 id="分子力学"><a href="#分子力学" class="headerlink" title="分子力学"></a>分子力学</h2><p>分子力学的基本概念就是：体系的总能量可以表示为若干独立能量项之和，包括键伸缩能，键角弯折能，二面角的扭转能等。<u>这个模型没有得到理论论证，因而分子力学被称为经验力场</u>。</p>
<p><strong>伸缩能</strong>定义为经典的Hooke势能+三次方项</p>
<script type="math/tex; mode=display">
E_r=\frac{k_r}2(r-r_0)^2+k'(r-r_0)^3</script><p><strong>键角的弯折</strong></p>
<script type="math/tex; mode=display">
E_\theta=\frac{k_\theta}2(\theta-\theta_0)^2+k_\theta'(\theta-\theta_0)^3</script><p><strong>二面角的扭曲</strong></p>
<script type="math/tex; mode=display">
E_\phi=\frac{k_\phi}2[B+cos(n\phi)]</script><p>B=1则交叉式优势，B=-1则重叠式优势，n是能垒多重度</p>
<p>现代力场中一般考察单重、双重、三重项之和。</p>
<p><strong>非键相互作用</strong></p>
<script type="math/tex; mode=display">
E_{nb}=\epsilon[(\frac{r^*}{r})^{12}-(\frac{r^*}{r})^6]</script><p>其中$\epsilon$和$r^*$取决于原子类型，r是原子间距离。注意到r大时为吸引，r小时为排斥。</p>
<p>其他还有<strong>交叉项、静电作用、氢键</strong>等等。</p>
<p><u>没有唯一的最好的立场。</u></p>
<p>得到合理地结构比得到值得信赖的相对能量容易。</p>
<p>主要预测气相中的性质。</p>
<p>比量子力学快得多。</p>
<h1 id="溶液"><a href="#溶液" class="headerlink" title="溶液"></a>溶液</h1><p>液体是<strong>短程有序</strong>，一个溶剂分子周围很好的发现一层距离最近的临近溶剂分子，但更多层分子距离不确定。</p>
<p>溶剂可以分为<strong>质子性</strong>和<strong>非质子性</strong>、<strong>极性</strong>和<strong>非极性</strong>。</p>
<p>一般通过介电常数$\epsilon$判断极性。</p>
<p>其他溶剂指标还有<strong>溶剂化显色作用</strong>，指溶剂诱导的生色团或荧光团的光谱形状/强度。常用两个标度，Z标度和$E_T$标度。</p>
<p>确定溶剂形成氢键能力的标度有$\alpha$标度测量溶剂对溶质作为氢键给体的能力，$\beta$标度测量溶剂对溶质作为氢键受体的能力。</p>
<p>溶剂的<strong>汽化热</strong>：水量值最大，表明其表面积的内聚力最大。另一个与汽化热相似的参数是<strong>内聚能密度</strong>。</p>
<p><strong>表面张力</strong>是关于溶剂内聚能的另一量度。</p>
<p>溶剂黏附于表面的能力称为<strong>润湿</strong>。溶剂与表面吸引力足够大时，溶剂在表面扩散，润湿表面。另一个相关现象是<strong>毛细管作用</strong>和<strong>弯月面</strong>。</p>
<p><strong>水</strong>具有高表面张力和高汽化热，这是因为O-H键高电荷极化引起的偶极-偶极吸引和氢键性质。完全氢键化的冰一旦融化，仅有15%的氢键被破坏，<strong>闪簇</strong>就是指液体水中短寿命类似冰的区域。</p>
<p>大多数溶液反应要求反应物被溶解（发生在<strong>均相溶液</strong>中）。</p>
<p>溶剂和溶质间的相互作用称为<strong>溶剂化能</strong>。考察溶剂间的溶剂化差异可以用<strong>转移自由能</strong>。</p>
<p>溶质周围溶剂区域称为<strong>群居区域</strong>，其结构与溶剂本身显著不同。带电荷和高极性溶质可以通过强的溶剂化作用诱导高介点性溶剂在其周围有序排列。</p>
<p><strong>相似相容</strong>是考虑溶解性的指导性原理。<strong>氢键</strong>对溶解性影响较大。</p>
<p>分子在溶剂中遭遇速率依赖于<strong>溶质流动性</strong>。</p>
<p>分子在溶剂中的<strong>扩散</strong>可以认为是布朗运动。扩散是由于<strong>浓度梯度</strong>引起的，有<strong>Fick扩散定律</strong>。</p>
<p>为了确定溶液的GFE（稳定性），定义了溶质的<strong>化学势</strong></p>
<script type="math/tex; mode=display">
\mu_A=\frac{\partial G}{\partial n_A}</script><p>从参照态变化后的化学式</p>
<script type="math/tex; mode=display">
\mu_A=\mu_A^-+RTln(a_A)</script><p>$a_A$是A的<strong>活度</strong>。稀的离子性溶液活度可以用<strong>Debye-Huckel理论</strong>计算。当化合物物质的量浓度接近于0时，活度近似于浓度。</p>
<p><strong>反应化学热</strong>：</p>
<script type="math/tex; mode=display">
\mu_B-\mu_A=\mu_B^--\mu_A^-+RT(ln(a_B)-ln(a_A))</script><p>活度一般认为与浓度相近，所以可以用平衡常数$K_{eq}=Q=[B]/[A]=a_B/a_A$得到A、B和溶剂的混合熵</p>
<script type="math/tex; mode=display">
\Delta G=-RTln(K_{eq})</script><p>利用<strong>van’t Hoff 分析</strong>重排$\Delta G=\Delta H-T\Delta S$得到</p>
<script type="math/tex; mode=display">
ln(K_{eq})=-\frac{\Delta H}{RT}+\frac{\Delta S}R</script><h2 id="结合力"><a href="#结合力" class="headerlink" title="结合力"></a>结合力</h2><h3 id="离子对吸引力"><a href="#离子对吸引力" class="headerlink" title="离子对吸引力"></a>离子对吸引力</h3><p><strong>离子对相互吸引力</strong>来自<strong>静电相互作用</strong>，其结合力可能远高于100 kcal/mol。当正负离子的静电吸引能量大于分开他们所需要的的热能时，称为存在<strong>离子对</strong>。</p>
<p>离子对的形成是和离子溶剂化竞争的行为，降低了溶液的GFE。离子对的能力和介质有关，从气相到有机溶剂后，离子对能力仍然会相当大，但在水里，作用会显著降低。</p>
<p><strong>聚离子</strong>的离子间作用更大一些。聚合物称为<strong>弱电解质</strong>。</p>
<p><strong>盐桥</strong>是蛋白质两个侧链间的离子对，负离子是羧酸跟，正离子是铵离子，外部盐桥贡献0~2 kcal/mol，内部盐桥贡献达3 kcal/mol。</p>
<h3 id="涉及偶极的静电作用"><a href="#涉及偶极的静电作用" class="headerlink" title="涉及偶极的静电作用"></a>涉及偶极的静电作用</h3><p>离子性溶质溶解于有偶极矩的溶剂中有<strong>离子-偶极相互作用</strong>，其与离子和偶极矩间距离r的平方成反比。</p>
<p>简单离子的溶剂化有一些趋势。溶剂化能如<strong>水合能</strong>（放热为负），离子越小，水合能越大。二价正离子的水合能远大于单价的正离子。同样，小的负离子具有较高的偶极吸引力。</p>
<p>一般小正离子溶剂化放热更多，但对于氢氧化物，趋势正好相反。</p>
<p>离子溶剂化的模型可以用<strong>Born方程</strong>计算</p>
<script type="math/tex; mode=display">
E=-(1-1/\epsilon)(q^2/8\pi\epsilon_0a)</script><p>$a$为离子半径。</p>
<p><strong>偶极-偶极相互作用</strong>与距离的三次方成反比</p>
<script type="math/tex; mode=display">
E=\frac{-\mu_1\mu_2(3\cos^2\theta-1)}{4\pi\epsilon\epsilon_0r^3}</script><p>相互作用为0时，$\theta\approx 54.7$，称为<strong>魔角</strong>。</p>
<h3 id="氢键"><a href="#氢键" class="headerlink" title="氢键"></a>氢键</h3><p>氢键是极性的给体键$Dn-H$和受体原子$:Ac$间的库伦作用。</p>
<p>几何因素对氢键强度影响不大。理想的几何形状是三个原子线性排列，但也允许明显的偏离。通过VSEPR理论更好地解释角度。</p>
<p>有两个受体时形成<strong>三中心氢键</strong>，也称为<strong>分叉型氢键</strong>。有两个给体或受体时，也称为<strong>螯合氢键</strong>。</p>
<p>溶剂强烈影响氢键的强度，因为给体和受体形成氢键之前已经溶剂化了。很多极性溶剂本身可以形成氢键，称为<strong>竞争性溶剂</strong>。</p>
<p>给体H上的电荷值越大，氢键越强。所以给体电负性越强，氢键越强。受体电负性越强，氢键越弱。</p>
<p>共振对氢键的增强也很重要。测定共振结构的贡献：参数Q。</p>
<p>极化增强的氢键（<strong>协同性氢键</strong>）指相邻的氢键基团协助$Dn-H$键的极化，增加其给体能力。比如水的三聚体。</p>
<p>氢键之间也有二级相互作用强化/弱化一级氢键。</p>
<p>氢键中的协同性：蛋白质中的$\alpha-$螺旋，每个氢键增强下一个氢键的稳定性。</p>
<p><strong>低障碍氢键、无障碍氢键</strong>都称为<strong>短-强氢键</strong>。</p>
<h3 id="pi-效应"><a href="#pi-效应" class="headerlink" title="$\pi$效应"></a>$\pi$效应</h3><p><strong>正离子-$\pi$相互作用</strong>强度与盐桥/氢键相当。这个作用在气相中最强，在有机溶剂中稍弱，在水中相当弱，但是水对其的弱化能力低于水对离子或氢键的弱化能力。</p>
<p><strong>极性-$\pi$相互作用</strong>也被称为<strong>苯氢键</strong>。</p>
<p><strong>芳香环-芳香环相互作用（$\pi$堆积）</strong>。对苯这样的简单体系，<strong>T-型（边对面型）</strong>排列优于堆积排列。而在一些复杂体系中，<strong>错位堆积（侧滑堆积）</strong>比较有利。</p>
<h3 id="诱导偶极相互作用"><a href="#诱导偶极相互作用" class="headerlink" title="诱导偶极相互作用"></a>诱导偶极相互作用</h3><p><strong>离子-诱导偶极作用</strong>是离子使得可极化的分子形成原来不存在的偶极矩。这种作用明显弱于离子与永久偶极矩之间的相互作用。与距离的4次方成反比。</p>
<p><strong>偶极-诱导偶极作用</strong>与距离的6次方成反比。</p>
<p><strong>诱导偶极-诱导偶极作用</strong>极其微小，但是描述范德华力/London色散力的一种方式。</p>
<h3 id="疏水效应"><a href="#疏水效应" class="headerlink" title="疏水效应"></a>疏水效应</h3><p>两种现象</p>
<ul>
<li>碳氢化合物在水中的低溶解性</li>
<li>有机物在水中的结合/簇集</li>
</ul>
<p>有机基团的<strong>疏水常数</strong>定义为</p>
<script type="math/tex; mode=display">
\pi=log(P/P_0)</script><p>其中$P_0$是有机分子在没有R时在辛醇和水中的分配比，P则是引入R时的分配比。</p>
<p>碳氢化合物的Gibbs转移自由能很大，所以在水中会尽量缩小暴露在外的表面积，有两种途径：改变形状和簇集。</p>
<p>常利用<strong>两亲性</strong>分子来研究簇集现象。这类分子也称为<strong>表面活性剂</strong>。如长链脂肪酸，长烷基链是<strong>亲脂/疏水</strong>的，羧基是亲水的，它会自发形成<strong>胶束</strong>，大致呈球形，碳氢尾巴朝内，羧基处于表面，这种结构只能在浓度达到一定值时产生，这个浓度称为<strong>临界胶束浓度</strong>。</p>
<p>自然界中更广泛存在的两亲分子是<strong>磷脂</strong>。磷脂不能形成胶束，但他们能够形成<strong>双分子层</strong>结构，最终形成<strong>囊泡</strong>。</p>
<p>疏水效应的物理起源</p>
<ul>
<li>水的高内聚能/高表面张力</li>
<li>相似相容</li>
</ul>
<h2 id="溶剂化计算建模"><a href="#溶剂化计算建模" class="headerlink" title="溶剂化计算建模"></a>溶剂化计算建模</h2><p>液体和固体一样是凝聚相，本质是<strong>多体问题</strong>，但是液体没有长城周期性。有两种策略可以模拟溶液：<strong>连续（隐含）介质模型</strong>和<strong>真实溶剂化模型</strong></p>
<h3 id="连续溶剂化模型"><a href="#连续溶剂化模型" class="headerlink" title="连续溶剂化模型"></a>连续溶剂化模型</h3><p>溶剂作为围绕在溶质周围的均相介质</p>
<p>溶剂为水的体系，发展出<strong>普遍化Born模型</strong>，</p>
<script type="math/tex; mode=display">
G_{solv}=G_{cav}+G_{vdw}+G_{pol}</script><p>$G_{cav}$是溶剂中形成空穴的能量，$G_{vdw}$是溶质-溶剂间的范德华力，最后一项是溶质-溶剂间的静电极化作用。</p>
<p>可以假设烷烃溶质的$G_{pol}$为0，</p>
<script type="math/tex; mode=display">
G_{cav}+G_{vdw}=\sum s_i(SA)_i</script><p>$s_i$是每类原子的参数，SA是其表面积。</p>
<p>水中的离子$G_{pol}$合并溶质离子间作用（库仑定律）和离子-溶剂作用（Born方程）得到</p>
<script type="math/tex; mode=display">
G_{pol}=-\frac12(1-1/\epsilon)\sum_i\sum_j(q_iq_j/f_{GB})</script><h3 id="真实溶剂化模型"><a href="#真实溶剂化模型" class="headerlink" title="真实溶剂化模型"></a>真实溶剂化模型</h3><p>水的模型有TIP4P模型和TIP3P模型。其他溶剂也有类似模型。</p>
<p>认为溶剂分子是刚性的。</p>
<p>可以使用<strong>Monte Carlo方法</strong>和<strong>分子力学</strong>得到液体体系的平均性质。</p>
<p>一个有用的分子力学方法是<strong>微扰方法</strong>。最近的发展称为<strong>统计微扰理论（SPT）/自由能微扰（FEP）</strong>，其基础是Zwanzig方程。</p>
<h1 id="分子识别和超分子化学"><a href="#分子识别和超分子化学" class="headerlink" title="分子识别和超分子化学"></a>分子识别和超分子化学</h1><p><strong>分子识别</strong>是受体分子和特定底物间选择性的非共价键结合。</p>
<h2 id="结合现象"><a href="#结合现象" class="headerlink" title="结合现象"></a>结合现象</h2><p>溶质-溶质相互作用时，一般把较大的看作<strong>主体（H)</strong>，另一个看作<strong>客体（G）</strong>。</p>
<p>结合常数$K_a$、解离常数$K_d$互为倒数</p>
<script type="math/tex; mode=display">
K_a=\frac{[H\cdot G]}{[H][G]}=1/K_d</script><p><strong>标准态的关联</strong>：稀释更有利于H和G的存在</p>
<p><strong>热容变化的影响</strong>：焓变</p>
<script type="math/tex; mode=display">
\Delta H=\Delta H +(T-298K)\Delta C_p</script><p>熵变</p>
<script type="math/tex; mode=display">
\Delta S=\Delta S+\Delta C_pln(T/298K)</script><p>结合van’t Hoff图</p>
<script type="math/tex; mode=display">
Rln(L)=-\Delta H(1/T)+\Delta C_pln(T)+\Delta S-\Delta C_p</script><p><strong>协同性</strong>：有正协同性和负协同性。客体A-B对主体的结合能分为三部分：A、B的<strong>内在结合能</strong>和<strong>连接Gibbs自由能</strong>。可以测定</p>
<script type="math/tex; mode=display">
\Delta G=RT ln(K_{AB}/K_AK_B)</script><p>A的结合以某种方式影响B的结合倾向，称为<strong>变构协同性</strong>，这在自然界非常普遍。另一种协同性称为<strong>多价性</strong>，正协同性与多价性相关。</p>
<p>237</p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Chemistry</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学</title>
    <url>/2020/04/08/cryptography/</url>
    <content><![CDATA[<h1 id="古典密码学"><a href="#古典密码学" class="headerlink" title="古典密码学"></a>古典密码学</h1><h2 id="几种古典密码"><a href="#几种古典密码" class="headerlink" title="几种古典密码"></a>几种古典密码</h2><p>移位密码（K=3即为凯撒密码）</p>
<script type="math/tex; mode=display">
e_k(x)=(x+K)\:mod\:26\\
d_k(y)=(x-K)\:mod\:26</script><p>代换密码</p>
<script type="math/tex; mode=display">
e_\pi(x)=\pi(x)\\
d_\pi(x)=\pi^{-1}(x)</script><a id="more"></a>
<p>仿射密码</p>
<script type="math/tex; mode=display">
e(x)=(ax+b)\:mod\:26\\
d(y)=a^{-1}(y-b)\:mod\:26\\
gcd(a,26)=1\:(保证a^{-1}唯一)</script><p>维吉尼亚密码</p>
<script type="math/tex; mode=display">
e(x_1,x_2,...,x_m)=(x_1+k_1,x_2+k_2,...,x_m+k_m)\\
d(y_1,y_2,...,y_m)=(y_1-k_1,y_2-k_2,...,y_m-k_m)</script><p>希尔密码</p>
<script type="math/tex; mode=display">
e(x)=xK\\
d(x)=yK^{-1}\\
K为Z_{26}上的m\times m可逆矩阵</script><p>置换密码</p>
<script type="math/tex; mode=display">
e_\pi(x_1,x_2,...,x_m)=(x_{\pi(1)},x_{\pi(2)},...,x_{\pi(m)})\\
d_\pi(y_1,y_2,...,y_m)=(y_{\pi^{-1}(1)},y_{\pi^{-1}(2)},...,y_{\pi^{-1}(m)})</script><p>流密码</p>
<p>自动秘钥密码</p>
<script type="math/tex; mode=display">
e_z(x)=(x+z)\:mod\:26\\
d_z(y)=(y-z)\:mod\:26\\
z_i=x_{i-1}，x_1=K</script><h2 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h2><p>常见攻击类型：</p>
<ul>
<li>唯密文攻击</li>
<li>已知明文攻击</li>
<li>选择明文攻击：有加密机访问权限</li>
<li>选择密文攻击：有解密机访问权限</li>
</ul>
<p>统计分析：</p>
<p>根据字母出现的频率（或者结合二元组出现频率）</p>
<p>维吉尼亚密码的分析：</p>
<p>Kasiski测试法，搜索长度至少为3的相同密文段，记录这些密文段到起始点之间的距离，猜测m为这些距离的最大公因子的因子</p>
<p>重合指数法，随机两个字母相等的概率（称为重合指数）为0.038，如果相隔为m，这个概率提高到0.065</p>
<p>希尔密码的分析：</p>
<p>需要至少m个不同的明-密文对</p>
<h1 id="Shannon理论"><a href="#Shannon理论" class="headerlink" title="Shannon理论"></a>Shannon理论</h1><p>1949年Claude Shannon发表的”Communication Theory of Secrecy Systems”</p>
<ul>
<li>计算安全性：度量破解所做的计算</li>
<li>可证明安全性：归入数学难题</li>
<li>无条件安全性</li>
</ul>
<p><strong>完善保密性</strong>定义为对任意明文x，密文y，有$P(x|y)=P(x)$</p>
<p>定义：密文空间C、明文空间P、密钥空间K</p>
<p>定理：如果密码体制满足|K|=|C|=|P|。那么这个密码体制是完善保密的，当且仅当每个密钥被使用的概率为1/|K|，且对$x\in P$，$y\in C$，存在唯一的密钥K，$e_K(x)=y$。</p>
<p>一个著名的完善保密的密码体制是”一次一密“，$P=C=K=(Z_2)^n$，加密和解密都是取异或。但是这个体制要求用n比特的密钥加密n比特的明文，且对已知明文攻击是脆弱的。</p>
<p>由于以概率$2^{-n}$发生的事件可以编码为长度为n的比特串，因此定义随机变量X的熵为</p>
<script type="math/tex; mode=display">
H(X)=-\sum P(x)log(x)</script><p><strong>Huffman算法</strong>找到了使得加权平均编码长度最小的<strong>单射</strong>编码l，他是无前缀的，并且</p>
<script type="math/tex; mode=display">
H(X)\leq l(f)<H(X)+1</script><p>熵的性质</p>
<ul>
<li>$H(X)\leq log(n)$</li>
<li>$H(X,Y)\leq H(X)+H(Y)$，(X、Y独立时取等号)</li>
<li>$H(X,Y)=H(Y)+H(X|Y)$</li>
<li>$H(X|Y)\leq H(X)$</li>
</ul>
<p>定义条件熵H(K|C)为密钥含糊度。那么</p>
<script type="math/tex; mode=display">
H(K|C)=H(K)+H(P)-H(C)</script><p>($H(K|C)=H(K,C)-H(C)=H(K,P,C)-H(C)=H(K,P)-H(C)=H(K)+H(P)-H(C)$)</p>
<p>自然语言L的熵定义为</p>
<script type="math/tex; mode=display">
H_L=\lim_{n\to\infty}\frac{H(P^n)}{n}</script><p>语言L的冗余度定义为</p>
<script type="math/tex; mode=display">
R_L=1-\frac{H_L}{log_2|P|}</script><p>英语中$H(P)=4.19$，$H(P^2)/2=3.90$，$1.0\leq H_L\leq 1.5$</p>
<p>定理：|C|=|P|且密钥是等概率选取的，那么给定长为n的密文串，伪密钥的期望数满足</p>
<script type="math/tex; mode=display">
\bar{s_n}\geq \frac{|K|}{|P|^{nR_L}}-1</script><p>($\bar{s_n}=\sum P(y)|K(y)|-1$，而$H(K|C)=H(K)+H(P^n)-H(C^n)\geq H(K)-nR_Llog_2|P|$)</p>
<p>定义<strong>唯一解距离</strong>为使得伪密钥期望等于0的n，记为$n_0$。这是给定足够时间下，分析者能唯一计算出密钥所需密文的平均量。</p>
<script type="math/tex; mode=display">
n\approx \frac{log_2|K|}{R_Llog_2|P|}</script><p><strong>乘积密码体制</strong>密钥$K=(K_1,K_2)$，定义加密解密如下</p>
<script type="math/tex; mode=display">
e_{(K_1,K_2)}(x)=e_{K_2}(e_{K_1}(x))\\
d_{(K_1,K_2)}(y)=d_{K_1}(d_{K_2}(y))</script><p>如果密码体制不是幂等的，那么多次迭代有可能提高安全性。</p>
<h1 id="分组密码和高级加密标准"><a href="#分组密码和高级加密标准" class="headerlink" title="分组密码和高级加密标准"></a>分组密码和高级加密标准</h1><p>大多数分组密码都是乘积密码：用K来生成$N_r$个<strong>轮密钥</strong>（也叫子密钥），轮密钥的列表就是<strong>密钥编排方案</strong>。通过这些轮密钥依次进行加密。</p>
<h2 id="代换-置换网络（SPN）"><a href="#代换-置换网络（SPN）" class="headerlink" title="代换-置换网络（SPN）"></a>代换-置换网络（SPN）</h2><script type="math/tex; mode=display">
\pi_s:\{0,1\}^l\to\{0,1\}^l\\
\pi_p:\{1,...,lm\}\to\{1,...,lm\}</script><p>均为置换，设$P=C=\{0,1\}^{lm}$，$K\subset(\{0,1\}^{lm})^{N_r+1}$是由K生成的密钥编排方案的集合。</p>
<p>每轮加密先用异或操作混入该轮密钥，再用$\pi_s$进行m次代换，再用$\pi_p$进行一次置换。（最后一轮只做异或操作）</p>
<h2 id="线性密码分析"><a href="#线性密码分析" class="headerlink" title="线性密码分析"></a>线性密码分析</h2><p>取值01的随机变量$P(X_i=1)=p_i$，定义<strong>偏差</strong>$e_i=p_i-1$</p>
<p>堆积引理：独立随机变量$X_i$，那么随机变量$X_1\oplus X_2\oplus … \oplus X_n$的偏差满足</p>
<script type="math/tex; mode=display">
e=2^{k-1}\prod_{j=1}^ke_k</script><p>对于一个置换$\pi_s:\{0,1\}^4\to\{0,1\}^4$，把每个相关的随机变量表示成如下形式</p>
<script type="math/tex; mode=display">
(\oplus_{i=1}^4a_iX_i)\oplus(\oplus_{i=1}^4b_iY_i)</script><p>设$N_L(a,b)$表示满足如下条件的8元组对(a,b),(x,y)的个数</p>
<script type="math/tex; mode=display">
(y_1,y_2,y_3,y_4)=\pi_S(x_1,x_2,x_3,x_4)\\
(\oplus_{i=1}^4a_iX_i)\oplus(\oplus_{i=1}^4b_iY_i)=0</script><p>该随机变量的偏差$e(a,b)=(N_L(a,b)-8)/16$</p>
<p>一个基于偏差为$e$的线性逼近的线性攻击想要成功所需要的的明-密文对数$T\approx ce^{-2}$</p>
<h2 id="差分分析"><a href="#差分分析" class="headerlink" title="差分分析"></a>差分分析</h2><p>定义$\Delta(x’)=\{(x,x^*|x\oplus x^*=x’\}$，则显然这个集合大小为$2^m$</p>
<p>定义</p>
<script type="math/tex; mode=display">
N_D(x',y')=|\{(x,x^*)\in \Delta(x'):\pi_s(x)\oplus\pi_s(x^*)=y'\}|</script><p>由此定义对应于差分$(a’,b’)$的扩散率</p>
<script type="math/tex; mode=display">
R_p(a',b')=\frac{N_D(a',b')}{2^m}(=P(b'|a'))</script><p>一个基于扩散率为e的差分攻击，需要4重组$(x,x^*,y,y^*)$的数量$T\approx ce^{-1}$</p>
<h2 id="数据加密标准"><a href="#数据加密标准" class="headerlink" title="数据加密标准"></a>数据加密标准</h2><p>DES是一种特殊的迭代密码，叫做<strong>Feistel型密码</strong>，每个状态$u^i$被分成长度相同的两部分$L^i$和$R^i$，轮函数g有如下形式</p>
<script type="math/tex; mode=display">
g(L^{i-1},R^{i-1},K^i)=(L^i,R^i)\\
L^i=R^{i-1},R^i=L^{i-1}\oplus f(R^{i-1},K^i)</script><p>显然Feistel型轮函数是可逆的，所以f不需要满足单射条件。</p>
<p>DES是16轮Feistel型密码，分组长度为64，密钥空间为$2^56$。</p>
<p>1998年56小时找到了DES密钥</p>
<h2 id="高级加密标准"><a href="#高级加密标准" class="headerlink" title="高级加密标准"></a>高级加密标准</h2><p>AES要求具有分组长度128，支持128、192、256的密钥长度，轮数依赖于密钥长度</p>
<p>最终<strong>Rijndael</strong>当选</p>
<p>前N-1轮，用S盒进行一次代换SubBytes，对State做一置换ShiftRows，再对State做一次操作MixColumns，然后进行AddRoundKey。最后一轮不用MixColumns。</p>
<p>目前来看，AES是安全的，不存在快于穷尽密钥搜索的攻击。</p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>四种模式</p>
<ul>
<li>密码本（ECB）</li>
<li>密码反馈（CFB）：$z_i=e_K(y_{i-1}),\:y_i=x_i\oplus z_i$</li>
<li>密码分组连接（CBC）：$y_i=e_K(y_{i-1}\oplus x_i)$</li>
<li>输出反馈（OFB）：$z_i=e_K(z_{i-1}),\:y_i=x_i\oplus z_i$</li>
</ul>
<p>ECB和OFB中，改变一个明文分组不影响其他密文分组，常用于信道不安全的通信，OFB常用于卫星通信。</p>
<p>CBC和CFB模式对于认证是有用的，能产生消息认证码MAC。</p>
<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><p>Hash函数安全性从三个问题来评估（这三个问题都是难解的才是稳固的）</p>
<ul>
<li>原像</li>
<li>第二原像</li>
<li>碰撞</li>
</ul>
<p>随机预言模型：理想的Hash函数，这个模型对x，随机选择Hash函数h，h(x)是完全随机的。</p>
<p>取q个点寻找原像的平均成功率$e=1-(1-1/M)^q$。（也是寻找第二原像的成功率）</p>
<p>取q个点寻找碰撞的成功率为$e=1-P_M^q/M^q$</p>
<p>可以估计$q\approx\sqrt{2Mln(1/(1-e))}$，（这就说明大约$\sqrt{M}$个随机元素计算有50%概率出现碰撞）</p>
<p>解决碰撞问题比原像问题和第二原像问题容易。碰撞问题可以很容易地转变为第二原像问题。任何能解决原像问题且概率为1的算法也能解决碰撞问题。</p>
<h2 id="迭代Hash函数"><a href="#迭代Hash函数" class="headerlink" title="迭代Hash函数"></a>迭代Hash函数</h2><p>输入一个比特串x，用公开算法构造串y，使得</p>
<script type="math/tex; mode=display">
|y|=0\:mod\:t</script><p>处理阶段必须保证x到y是单射（常见的是一个变换+padding）</p>
<p>然后以长度为m的公开初始值作为$z_0$，然后</p>
<script type="math/tex; mode=display">
z_i=compress(z_{i-1}||y_i)</script><h3 id="Merkle-DamgArd结构"><a href="#Merkle-DamgArd结构" class="headerlink" title="Merkle-DamgArd结构"></a>Merkle-DamgArd结构</h3><p>如果有抗碰撞的compress函数，则这样的迭代Hash函数也是抗碰撞的。先将x分成长为k-1的部分，得到y</p>
<script type="math/tex; mode=display">
z_1=0^{m+1}||y_1,g_1=compress(z_1)\\
for\:i\:in\:1\:to\:k\:do\:
z_{i+1}=g_i||1||y_{i+1},g_{i+1}=compress(z_{i+1})</script><p>以$g_{k+1}$为密文。</p>
<p>定理4.6：找到h的碰撞，则能找到compress函数的碰撞。（证明考察x长度mod t-1）</p>
<h3 id="安全Hash算法（SHA-1）"><a href="#安全Hash算法（SHA-1）" class="headerlink" title="安全Hash算法（SHA-1）"></a>安全Hash算法（SHA-1）</h3><p>要求$|x|\leq 2^{64} - 1$，则$l=|x|$长度最多为64比特</p>
<p>PADDING算法：</p>
<script type="math/tex; mode=display">
y=x||1||0^d||l</script><p>其中 |l|=64，padding的d = 447-|x| mod 512。把y分成512比特的分组</p>
<script type="math/tex; mode=display">
y=M_1||M_2||...||M_n</script><p><img src="sha1.png" alt=""></p>
<p>其中$f_i$是分组定义的函数，输入是三个字，输出是一个字，$K_i$是分组定义的常数。</p>
<p>之后还有新的Hash函数（SHA-256，SHA-384，SHA-512…）</p>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>一个消息的MAC计算为</p>
<script type="math/tex; mode=display">
h_k(x||x')=compress(h_K(x)||x')</script><p>对于攻击者来说，即使K是保密的，计算上式的值也是简单的事情。</p>
<h3 id="嵌套MAC和HMAC"><a href="#嵌套MAC和HMAC" class="headerlink" title="嵌套MAC和HMAC"></a>嵌套MAC和HMAC</h3><p>嵌套MAC是指合成两个带密钥的Hash组建立MAC算法。假定(X,Y,K,G)和(Y,Z,L,H)是Hash族，复合成Hash族$(X,Z,M,G\cdot H)$，其中$M=K\times L$。对所有的x</p>
<script type="math/tex; mode=display">
(g\cdot h )_{(K,L)}(x)=h_L(g_K(x))</script><p>这个结构中$|Y|\geq |Z|$是有限集，$|X|&gt;|Y|$或者为无限集。如果满足以下两个条件，嵌套MAC是安全的</p>
<ul>
<li>给定固定的密钥，作为MAC，(Y,Z,L,H)是安全的</li>
<li>给定固定的密钥，(X,Y,K,G)是碰撞稳定的</li>
</ul>
<p>直观上讲是通过安全的“小MAC”和碰撞固定的Hash族复合成安全的“大MAC”。考虑三种攻击</p>
<ul>
<li>对嵌套MAC的假冒</li>
<li>对小MAC的假冒</li>
<li>对Hash族的碰撞-探测</li>
</ul>
<p>HMAC是一个被提议作为FIPS标准的嵌套MAC算法。密钥记为K，ipad和opad是常数。定义</p>
<script type="math/tex; mode=display">
HMAC_K(x)=SHA-1(K\oplus opad||SHA-1((K\oplus ipad)||x))</script><h3 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h3><p>构造MAC的常用方式是基于固定的（公开的）初始化向量的CBC模式。每个密文分组在被K加密之前与下一组明文分组一起异或。</p>
<script type="math/tex; mode=display">
y_i=e_K(y_{i-1}\oplus x_i)</script><p>对CBC-MAC最好的通用攻击是碰撞攻击。</p>
<p>攻击细节如下：选择q个独立的、长度为t的比特串，记为$x_1^1,…,x_1^q$，随机选择$x_2^i$，/定义$x_3,…,x_n$是固定比特串，定义</p>
<script type="math/tex; mode=display">
x^i=x_1^i||x_2^i||...||x_n^i</script><p>那么如果$h_K(x_i)=h_K(x_j)$，则</p>
<script type="math/tex; mode=display">
y_1^i\oplus x_2^i=y_1^j\oplus x_2^j</script><p>那么攻击者定义</p>
<script type="math/tex; mode=display">
v=x_1^i||(x_2^i\oplus x_\delta)||...\\
w=x_2^j||(x_2^j\oplus x_\delta)||...</script><p>并请求v的MAC，这也就是w的MAC。</p>
<h3 id="无条件安全信息认证码"><a href="#无条件安全信息认证码" class="headerlink" title="无条件安全信息认证码"></a>无条件安全信息认证码</h3><p>假定一个密钥只产生一个认证表情，即攻击者至多只能进行一次查询</p>
<p>定义</p>
<script type="math/tex; mode=display">
payoff(x,y)=Pr[y=h_{K_0}(x)]=|\{k\in K|h_K(x)=y\}|/|K|</script><p>那么</p>
<script type="math/tex; mode=display">
pd_0=\max\{payoff(x,y)\}\\
pd_1=\max\{payoff(x',y';x,y):x\neq x',(x,y)至少在一个密钥下有效\}</script><p>定义<strong>强泛Hash函数族</strong>，如果对任意$x\neq x’$</p>
<script type="math/tex; mode=display">
|\{K|h_K(x)=y,h_K(x')=y'\}|=|K|/|Y|^2</script><p>定理：强泛(N,M)-Hash函数族的认证码的$pd_0=pd_1=1/M$。</p>
<p>显然，(N,M)-Hash函数族(X,Y,K,H)对任意指定x，存在y，使得</p>
<script type="math/tex; mode=display">
payoff(x,y)\geq 1/M</script><p>对每个(x,y)和x’，存在一个y’使得</p>
<script type="math/tex; mode=display">
payoff(x',y';x,y)\geq 1/M</script><p>故$pd_1\geq 1/M$，取等号的充要条件就是该Hash函数族是强泛的。</p>
<h1 id="RSA密码体系和整数因子分解"><a href="#RSA密码体系和整数因子分解" class="headerlink" title="RSA密码体系和整数因子分解"></a>RSA密码体系和整数因子分解</h1><p>公钥密码体系无法提供无条件安全性，因此我们只研究其计算安全性。</p>
<p><strong>Euclidean算法</strong></p>
<p>先计算r=gcd(a,b)，然后得到sa+tb=r，那么$b^{-1}=t\mod a$</p>
<p><strong>中国剩余定理</strong></p>
<script type="math/tex; mode=display">
x=a_i\:mod\:m_i</script><p>定义$M_i=M/m_i$，那么</p>
<script type="math/tex; mode=display">
x=\sum_{i=1}^n a_iM_iy_i\:mod\: M</script><p>其中$y_i=M_i^{-1}\mod m_i$</p>
<p><strong>Langrange</strong></p>
<p>n阶乘法群G的元素的阶整除n</p>
<p><strong>Fermat</strong></p>
<p>素数p，$b^p=b\mod p$</p>
<p><strong>Euler准则</strong></p>
<p>奇素数p，正整数a，那么a是模p的二次剩余当且仅当</p>
<script type="math/tex; mode=display">
a^{(p-1)/2}=1\:mod\:p</script><h2 id="RSA密码体系"><a href="#RSA密码体系" class="headerlink" title="RSA密码体系"></a>RSA密码体系</h2><p>n=pq，p,q为素数</p>
<script type="math/tex; mode=display">
K=\{(n,p,q,a,b):ab=1\:mod\:\phi(n)\}</script><p>定义</p>
<script type="math/tex; mode=display">
e_K(x)=x^b\:mod\:n\\
d_K(y)=y^a\:mod\:n</script><p>n和b是公钥，p、q、a是私钥。</p>
<p><strong>素性检测</strong></p>
<p>素数个数定理：小于等于N的素数个数$\pi(N)\approx N/ln(n)$</p>
<p><strong>判定问题的随机算法</strong></p>
<p>Monte Carlo算法总是给出一个回答，但不一定正确。<strong>偏是</strong>的Monte Carlo算法的“是”回答总是正确，“否”也许是不正确的。</p>
<p>Solovay-Strassen是对于合数问题一个<strong>偏是</strong>的Monte Carlo算法，具有错误概率1/2。</p>
<p>称n为对于基底a的伪素数，如果$(a/n)=a^{(n-1)/2}\mod n$。可以证明，n对至多1/2的a为伪素数。</p>
<p>Solovay计算x=(a/n)（利用二次互反律等），如果x=0则为合数，否则判断$x=a^{(n-1)/2}$。</p>
<p>Miller-Rabin算法是另一个合数问题的算法，也是<strong>偏是</strong>的，错误概率至多为1/4。</p>
<p>把n-1写成$2^km$，随机选取整数a，$1\leq a\leq n-1$，</p>
<script type="math/tex; mode=display">
b=a^m\:mod\:n</script><p>如果b=1，则n为素数，否则对重复k次</p>
<script type="math/tex; mode=display">
b=b^2\:mod\:n</script><p>每次如果b = -1，则n为素数。最后n为合数。</p>
<p><strong>模n的平方根</strong></p>
<p>假定</p>
<script type="math/tex; mode=display">
n=\prod_{i=1}^lp_i^{e_i}</script><p>那么同余方程</p>
<script type="math/tex; mode=display">
y^2=a\:mod\:n</script><p>当$(a/p_i)=1$对所有i成立时有$2^l$个解，其他情形下没有解。</p>
<h2 id="分解因子算法"><a href="#分解因子算法" class="headerlink" title="分解因子算法"></a>分解因子算法</h2><p>攻击RSA密码最明显的方式就是试图分解公开模数。对于大整数最有效的三种算法是</p>
<ul>
<li>二次筛法</li>
<li>椭圆曲线分解算法</li>
<li>数域筛法</li>
</ul>
<p>其他先驱的著名算法有Pollard的$\rho$方法和p-1算法，William的p+1算法、连分式算法、试除法等等。</p>
<p><strong>Pollard p-1算法</strong></p>
<p>a=2</p>
<p>for j = 2 to B do </p>
<p>$a=a^j\mod n$，计算a-1和n的最大公约数，如果都找不到则认定为素数。</p>
<p>合理性：n的素因子p，假定对每个素数$q|(p-1)$，q&lt;B，则有$(p-1)|B!$，此时$2^{B!}=1\mod p$</p>
<p>一个缺陷是B的选择，另一个缺陷是对q的要求，所以可以选择p=2p+1这样的安全素数</p>
<p><strong>Pollard $\rho$算法</strong></p>
<p>选择随机子集X，对不同的x1,x2，计算gcd(x1-x2, n)。这个方法成功当且仅当x mod p出现碰撞。当</p>
<script type="math/tex; mode=display">
|X|\approx 1.17\sqrt{p}</script><p>时，50%的概率至少有一个碰撞。但这种方法需要计算很多次gcd，因此考虑定义整系数多项式f，例如$f(x)=x^2+a$，考察序列</p>
<script type="math/tex; mode=display">
x_i=f(x_{i-1})\:mod\:n</script><p>那么如果$x_i=x_j\mod p$，那么$x_{i+d}=x_{j+d}\mod p$，那么图构成1~i的尾巴，和i~j的圈。因此我们取j=2i来寻找碰撞。</p>
<p><strong>Dixon随机平方算法</strong></p>
<p>假设找到$x^2=y^2\mod n$，且$x\neq \pm y\mod n$，那么</p>
<script type="math/tex; mode=display">
n|(x-y)(x+y)</script><p>因此gcd(x+y, n)是n的一个非平凡因子。</p>
<p>随机平方算法使用因子基B（b个最小素数的集合），找到几个整数z，使得$z^2\mod n$的所有素因子在B里，然后将这些z相乘使得B里素数都出现偶数次，由此导出一个期望的同余方程。</p>
<p>一些技巧是选取形如$j+[\sqrt{kn}]$的整数，因为这样平方和模n比较小， 有可能在B上完全分解。</p>
<p>称n是m-光滑的，如果n的任一素因子都小于等于m，$\phi(n,m)$定义为小于等于n且是m-光滑的正整数个数，如果$n&gt;&gt;m$</p>
<script type="math/tex; mode=display">
\frac{\phi(n,m)}{n}\approx \frac1{u^u},u=log(n)/log(m)</script><p>基B包含所有小于m的素数，约有b=m/ln(m)个，为了使算法成功，期望找到b个m光滑整数，测试$bu^u$个整数。通常期望运行时间</p>
<script type="math/tex; mode=display">
O(2^{c\sqrt{log_2(n)log_2(log_2(n))}})</script><p><strong>Pomerance二次筛法</strong></p>
<script type="math/tex; mode=display">
O(2^{(1+o(1))\sqrt{ln(n)ln(ln(n))}})</script><p><strong>椭圆曲线算法</strong></p>
<script type="math/tex; mode=display">
O(2^{(1+o(1))\sqrt{2ln(p)ln(ln(p))}})</script><p><strong>数域筛法</strong></p>
<script type="math/tex; mode=display">
O(2^{(1.92+o(1))(ln(n))^{1/3}(ln(ln(n)))^{2/3}})</script><h2 id="对RSA的其他攻击"><a href="#对RSA的其他攻击" class="headerlink" title="对RSA的其他攻击"></a>对RSA的其他攻击</h2><p><strong>计算$\phi(n)$</strong></p>
<p>可以看到这不比分解n简单。得到$\phi(n)$之后，构造关于p的二次方程即可</p>
<script type="math/tex; mode=display">
p^2-(n-\phi(n)+1)p+n=0</script><p><strong>解密指数</strong></p>
<p>如果解密指数a已知，那么n可以通过一个随机算法在多项式时间内分解。</p>
<p>可以有算法达到1/2的成功率</p>
<p><strong>Wiener低解密指数攻击</strong></p>
<p>假设前提</p>
<script type="math/tex; mode=display">
3a<n^{1/4},q<p<2q</script><p>满足这个前提的a可以使得解密时间减少75%</p>
<p>已知</p>
<script type="math/tex; mode=display">
0<n-\phi(n)=p+q-1<3q<3\sqrt{n}</script><p>假设</p>
<script type="math/tex; mode=display">
ab=1+t\phi(n)</script><p>考虑到$t&lt;a&lt;n^{1/4}$那么</p>
<script type="math/tex; mode=display">
|\frac bn-\frac ta|<\frac{3t}{a\sqrt{n}}<\frac1{an^{1/4}}<\frac1{3a^2}</script><p>因此t/a是b/n的近似，从<em>连分数理论</em>可知这样的近似是b/n连分数展开的<strong>收敛子</strong>。可以通过验证前几个收敛子判断。</p>
<h2 id="Rabin密码体制"><a href="#Rabin密码体制" class="headerlink" title="Rabin密码体制"></a>Rabin密码体制</h2><p>假定n=pq不能被分解，则这类体制对明文攻击是计算安全的</p>
<p>设n=pq，p,q为素数，定义</p>
<script type="math/tex; mode=display">
e_K(x)=x^2\:mod\:n\\
d_K(y)=\sqrt{y}\:mod\:n</script><p>一个明显的问题是加密不是单射。</p>
<p>解密可以<em>约化</em>到n的分解</p>
<p>Rabin Oracle Factoring(n)</p>
<p>选择$y=r^2\mod n$，计算$x=Rabin\:Decrypt(y)$，如果$x\neq\pm r\mod n$，那么$p=gcd(x+r,n)$。</p>
<h2 id="RSA语义安全"><a href="#RSA语义安全" class="headerlink" title="RSA语义安全"></a>RSA语义安全</h2><p>half(y)：判断y的明文和n/2的大小关系</p>
<p>parity(y)：判断y的明文二进制最后一位</p>
<p>RSA解密可以约化为half(y)/parity(y) 【二分查找】</p>
<blockquote>
<p>语义安全的公钥密码体制</p>
<p>正整数m,k，F为一族陷门单向置换，对任意$f\in F$，有$f:\{0,1\}^k\to\{0,1\}^k$，随机预言$G:\{0,1\}^k\to\{0,1\}^m$，随机选取$r\in\{0,1\}^k$，定义</p>
<script type="math/tex; mode=display">
e_K(x)=(y_1,y_2)=(f(r),G(r)\oplus x)\\
d_K(y_1,y_2)=G(f^{-1}(y_1))\oplus y_2</script><p>f和G是公钥，$f^{-1}$是私钥。</p>
</blockquote>
<p>主要缺点是数据扩张，将m加密成m+k</p>
<p>假定存在一个算法Distinguish可以对两个明文x1,x2求解密文识别问题，且是完善的（正确概率为$1/2+\epsilon$），我们可以构造新算法Invert以不为0的概率对y求逆。</p>
<blockquote>
<p>用SimG代替随机预言G</p>
<p>SimG维护RList、GList。RList记录Distinguish询问的所有输入r，GList为对应的响应</p>
<p>如果r已经询问过，那么用已定义的值g。</p>
<p>如果有$f(r)=y$，那么随机选择j，$g=y_2\oplus x_j$。否则随机选择g</p>
</blockquote>
<p>那么可以证明得到$x=f^{-1}(y)$的概率大于等于$\epsilon$。</p>
<blockquote>
<p>更有效的非对称密码体制</p>
<p>m&lt;k，$k_0=k-m$，F为一族陷门单向置换，对任意$f\in F$，有$f:\{0,1\}^k\to\{0,1\}^k$，随机预言$G:\{0,1\}^{k_0}\to\{0,1\}^m$，$H:\{0,1\}^m\to\{0,1\}^{k_0}$，随机选取$r_0\in\{0,1\}^m$。</p>
<script type="math/tex; mode=display">
e_K(x)=f(y_1||y_2)\\
y_1=x\oplus G(r),\:y_2=r\oplus H(x\oplus G(r))</script><p>进一步定义</p>
<script type="math/tex; mode=display">
f^{-1}(y)=x_1||x_2\\
r=x_2\oplus H(x_1)\\
d_K(y)=G(r)\oplus x_1</script><p>$f,G,H$为公钥，$f^{-1}$为私钥</p>
</blockquote>
<h1 id="离散对数问题的公钥密码体制"><a href="#离散对数问题的公钥密码体制" class="headerlink" title="离散对数问题的公钥密码体制"></a>离散对数问题的公钥密码体制</h1><p><strong>离散对数</strong></p>
<p>对乘法群$(G,·)$,一个n阶元素$\alpha$，$\beta\in&lt;\alpha&gt;$，找到a</p>
<script type="math/tex; mode=display">
\alpha^a=\beta</script><p>记a为$log_\alpha\beta$</p>
<h2 id="ElGamal密码体制"><a href="#ElGamal密码体制" class="headerlink" title="ElGamal密码体制"></a>ElGamal密码体制</h2><p>设p是素数，$Z_p$上的离散对数问题是案处理的，$\alpha$是一个本原元</p>
<p>$p,\alpha,\beta$是公钥，a是私钥。</p>
<p>定义</p>
<script type="math/tex; mode=display">
e_K(x,k)=(y_1,y_2)\\
y_1=\alpha^k\:mod\:p,\:y_2=x\beta^k\:mod\:p</script><p>定义</p>
<script type="math/tex; mode=display">
d_K(y_1,y_2)=y_2(y_1^a)^{-1}\:mod\:p</script><h2 id="离散对数问题的算法"><a href="#离散对数问题的算法" class="headerlink" title="离散对数问题的算法"></a>离散对数问题的算法</h2><p><strong>Shanks算法</strong></p>
<p>m=$[\sqrt{n}]$，对$0\leq j\leq m-1$，计算$\alpha^{mj}$。</p>
<p>对m个有序对$(j,\alpha^{mj})$按照第二个坐标排序，得到列表L1。</p>
<p>对$0\leq i\leq m-1$，计算$\beta\alpha^{-i}$</p>
<p>对m个有序对$(i,\beta\alpha^{-i})$关于第二个坐标排序，得到列表L2&gt;</p>
<p>找到具有相同第二坐标的对，令a=mj+i</p>
<p><strong>Pollard $\rho$离散对数算法</strong></p>
<p>定义大致相等的划分$S_1,S_2,S_3$，定义函数f</p>
<script type="math/tex; mode=display">
f(x,a,b)=(\beta x,a,b+1),x\in S_1\\
f(x,a,b)=(x^2,2a,2b),x\in S_2\\
f(x,a,b)=(\alpha x,a+1,b),x\in S_3</script><p>这样产生的每个三元组都满足$x=\alpha^a\beta^b$</p>
<p>比较三元组，知道发现$x_{2i}=x_i$，这时有</p>
<script type="math/tex; mode=display">
\alpha^{a_{2i}}\beta^{b_{2i}}=\alpha^{a_i}\beta^{b_i}</script><p>所以</p>
<script type="math/tex; mode=display">
log_\alpha\beta=(a_i-a_{2i})(b_{2i}-b_i)^{-1}\:mod\:n</script><p><strong>Pohlig-Hellman算法</strong></p>
<p>假设</p>
<script type="math/tex; mode=display">
n=\prod_{i=1}^kp_i^{c_i}</script><p>把a表示为</p>
<script type="math/tex; mode=display">
a=\sum_{i=0}^{c-1}a_iq^i+sq^c</script><p>依次确定$a_0,a_1,…$（利用$\beta^{n/q}=\alpha^{a_0n/q}$）</p>
<p>然后用中国剩余定理。</p>
<p><strong>指数演算法</strong></p>
<p>取B个小素数作为基，构造C&gt;B个模p的同余方程（要保证所有因子在B里）</p>
<script type="math/tex; mode=display">
\alpha^{x_j}=p_1^{a_{1j}}...p_B^{a_{Bj}}\:mod\:p</script><p>然后选择随机数s，使得</p>
<script type="math/tex; mode=display">
\beta\alpha^s</script><p>可以在B上分解，那么就容易得到答案。</p>
<p><u>通用性算法复杂性的下界是$\sqrt{n}$，（这是可以证明的）</u></p>
<h2 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h2><p>ElGamal密码体制可以咋任何离散对数问题难处理的群中实现</p>
<ul>
<li>有限域$F_{p^n}$的乘法群</li>
<li>定义在有限域上的椭圆曲线群</li>
</ul>
<p>$Z_p[x]/(f(x))$是域当且仅当$f(x)$是不可约的</p>
<p>$F_{2^n}$上离散对数问题当前被认为是计算不可行的</p>
<h2 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h2><p>二元方程解的集合</p>
<p>满足$4a^2+27b^3\neq 0$的方程</p>
<script type="math/tex; mode=display">
y^2=x^3+ax+b</script><p>的解加上无穷远点O。</p>
<p>定义二元运算，对$P,Q\in E$，L是通过PQ的直线，交E于第三点$R’$，对x轴作反射得到R，定义</p>
<script type="math/tex; mode=display">
P+Q=R</script><p>显然若P、Q是实数，则R也是实数。</p>
<p>可以解得</p>
<script type="math/tex; mode=display">
x_R=\lambda^2-x_P-x_Q\\
y_R=\lambda(x_P-x_R)-y_P\\
\lambda=(y_P-y_Q)/(x_P-x_Q)</script><p>进一步定义模素数的椭圆曲线</p>
<script type="math/tex; mode=display">
y^2\equiv x^3+ax+b\:mod\:p</script><p>同样有无穷远点O。</p>
<p>加法群的定义是相似的。</p>
<p>定理：定义在$Z_p$上的椭圆曲线E，则存在正整数$n_1,n_2$，使得$(E,+)$同构于$Z_{n_1}\times Z_{n_2}$，并且有$n_2|n_1$和$n_2|p-1$。</p>
<p>有一类弱椭圆曲线（“trace one”）是易解的。具有大约$2^{160}$个元素循环子群的椭圆曲线是安全的。</p>
<p><strong>点压缩和ECIES</strong></p>
<p>实际中，椭圆曲线的实现有大约4倍的扩张因子。更为严重的问题是，没有方便的方法确定生成E上的点。</p>
<p>由于确定了x，y的两个值是相反数，一个是奇数，另一个是偶数，因此点压缩技术可以通过判断y mod 2来确定y。</p>
<p>ECIES利用点压缩技术，有一个近似2的信息扩张。</p>
<p><u>计算椭圆曲线上点的乘积—对倍数c转换为二进制，利用2倍-和差法计算</u></p>
<p>椭圆曲线加密有得到越来越广泛的应用</p>
<h2 id="ElGamal体制的安全性"><a href="#ElGamal体制的安全性" class="headerlink" title="ElGamal体制的安全性"></a>ElGamal体制的安全性</h2><p>比特安全性：确定对数表示二进制的第i个最低比特</p>
<p>最低位是容易的（利用二次剩余）</p>
<p>如果$\beta$是二次剩余，那么$\beta$模p的两个平方根为$\pm\beta^{(p+1)/4}$，且这两个数的最低位不同。那么，我们利用ORACLEL2（假设有这种算法）计算最低第二位，进行判断。</p>
<p>利用此方法可以从最低位开始依次计算。</p>
<h1 id="签名方案"><a href="#签名方案" class="headerlink" title="签名方案"></a>签名方案</h1><p>签名算法（私有）+验证算法（公开）</p>
<blockquote>
<p>RSA签名方案</p>
<p>利用RSA解密规则进行签名</p>
<p>定义</p>
<script type="math/tex; mode=display">
sig_K(x)=x^a\:mod\:n</script><p>以及</p>
<script type="math/tex; mode=display">
ver_K(x,y)=true\Leftrightarrow x=y^b\:mod\:n</script></blockquote>
<p>但是任何人都能随机生成y来伪造RSA签名，阻止这种攻击的方法是让消息足够冗余，使得x有意义的概率非常小。</p>
<p>签名和Hash函数常常结合使用。通过Hash生成信息摘要，再对摘要进行签名。有三种攻击</p>
<ul>
<li>已知消息攻击的存在性伪造：Hash二次原像稳固可以避免</li>
<li>选择消息攻击的存在性伪造：Hash碰撞稳固可以避免</li>
<li>惟密钥攻击的存在性伪造：Hash原相稳固可以避免</li>
</ul>
<p>所以签名+Hash不减弱签名的安全性。</p>
<h2 id="ElGamal签名方案"><a href="#ElGamal签名方案" class="headerlink" title="ElGamal签名方案"></a>ElGamal签名方案</h2><p>非确定性：有许多有效的签名</p>
<p>难解的离散对数</p>
<script type="math/tex; mode=display">
\beta=\alpha^a\:mod\:p</script><p>定义</p>
<script type="math/tex; mode=display">
sig_K(x,k)=(\gamma,\delta)\\
\gamma=\alpha^k\:mod\:p,\:\delta=(x-a\gamma)k^{-1}\mod{(p-1)}</script><script type="math/tex; mode=display">
ver_K(x,(\gamma,\delta))=true\Leftrightarrow \beta^\gamma\gamma^\delta=\alpha^x\:mod\:p</script><p>需要注意随机值k不能泄露，否则计算a很容易。</p>
<p>另外，对两个不同的消息签名使用相同的k，可以计算得到$d=gcd(\delta_1-\delta_2,p-1)$个候选的k进行验证。</p>
<h3 id="一些变体"><a href="#一些变体" class="headerlink" title="一些变体"></a>一些变体</h3><p><strong>Schnorr签名方案</strong>（缩短了签名）</p>
<p>素数p,q满足$p-1\equiv 0\mod q$。一般取$p\approx 2^{1024}$，$q\approx 2^{160}$。定义Hash函数$h:\{0,1\}^n\to Z_q$</p>
<script type="math/tex; mode=display">
sig_K(x,k)=(\gamma,\delta)\\
\gamma=h(x||\alpha^k),\:\delta=k+a\gamma\:mod\:q</script><script type="math/tex; mode=display">
ver_K(x,(\gamma,\delta))=true\Leftrightarrow h(x||\alpha^\delta\beta^{-\gamma})=\gamma</script><p><strong>数字签名算法（DSA）</strong></p>
<p><u>特点：消息是经过Hash缩短的，所以我们会得到比较短的消息摘要</u></p>
<p>和Schnorr签名一样，使用了一个q元子群。</p>
<p>把ElGammal签名中$\delta$中的减号改为加号。</p>
<script type="math/tex; mode=display">
sig_K(x,k)=(\gamma,\delta)\\
\gamma=(\alpha^k\:mod\:p)\:mod\:q\\
\delta=(SHA-1(x)+a\gamma)k^{-1}\:mod\:q</script><p>验证</p>
<script type="math/tex; mode=display">
e_1=SHA-1(x)\delta^{-1}\mod q\\
e_2=\gamma\delta^{-1}\mod q\\
ver_K(x,(\gamma,\delta))=true\Leftrightarrow (\alpha^{e_1}\beta^{e_2}\mod p)\mod q=\gamma</script><p><strong>椭圆曲线DSA（ECDSA）</strong></p>
<p>具有更高的安全性</p>
<p>A是E上阶数为q的一个点，p、q、E、A、B是公钥，m是私钥，$B=mA$</p>
<script type="math/tex; mode=display">
sig_K(x,k)=(r,s)\\
kA=(u,v)\\
r=u\mod q\\
s=k^{-1}(SHA-1(x)+mr)\mod q</script><p>验证</p>
<script type="math/tex; mode=display">
w=s^{-1}\mod q\\
i = w\cdot SHA-1(x)\mod q\\
j=wr\mod q\\
(u,v)=iA+jB\\
var_K(x,(r,s))=true\Leftrightarrow u\mod q=r</script><h2 id="可证明的安全签名方案"><a href="#可证明的安全签名方案" class="headerlink" title="可证明的安全签名方案"></a>可证明的安全签名方案</h2><p>可以证明破解概率的方案</p>
<p><strong>一次签名</strong></p>
<p>Lamport签名方案：$f:Y\to Z$单向，y是私钥，z公开</p>
<script type="math/tex; mode=display">
sig_K(x_1,x_2,...,x_k)=y_1,y_2,...,y_k\\
var_K(x_1,x_2,...,x_k,a_1,a_2,...,a_k)=true\Leftrightarrow f(a_i)=z_i</script><p><strong>全域Hash</strong></p>
<p>单向陷门f，随机函数G</p>
<script type="math/tex; mode=display">
sig_K(x)=f^{-1}(G(x))\\
ver_K(x,y)=true\Leftrightarrow f(y)=G(x)</script><h2 id="不可否认的签名"><a href="#不可否认的签名" class="headerlink" title="不可否认的签名"></a>不可否认的签名</h2><p>验证签名需要签名者的合作</p>
<p>Chaum-van Antwerpen</p>
<p>p=2q+1，q是素数，$\beta=\alpha^a\mod p$</p>
<script type="math/tex; mode=display">
y=sig_K(x)=x^a\mod p</script><p>验证者随机选择$e_1,e_2$，计算$c=y_1^{e_1}\beta^{e_2}\mod p$。</p>
<p>签名者计算$d=c^{a^{-1}\mod q}\mod p$，当且仅当$d=x^{e_1}\alpha^{e_2}\mod p$时是合法的签名。</p>
<p><u>把y当成合法签名接受的概率为1/q</u></p>
<p><strong>否认协议</strong></p>
<p>验证者选择$e_1,e_2$，得到d不合法，然后再次选择$e_1’,e_2’$，得到$d’$，当</p>
<script type="math/tex; mode=display">
(d\alpha^{-e_2})^{e_1'}\equiv(d'\alpha^{-e_2'})^{e_1}\mod p</script><p>时，可以推断签名是伪造的。</p>
<p><u>伪造否认协议成功的概率为1/q</u></p>
<h2 id="fail-stop签名"><a href="#fail-stop签名" class="headerlink" title="fail-stop签名"></a>fail-stop签名</h2><p>van Heyst-Pedersen</p>
<p>p=2q+1，q是素数，</p>
<script type="math/tex; mode=display">
\beta=\alpha^{a_0}\mod p</script><p>$p,q,\alpha,\beta$是公开且不变的。</p>
<script type="math/tex; mode=display">
\gamma_1=\alpha^{a_1}\beta^{a_2}\mod p\\
\gamma_2=\alpha^{b_1}\beta^{b_2}\mod p</script><p>$\gamma_1,\gamma_2$是公钥，$a_1,a_2,b_1,b_2$是私钥</p>
<p>签名</p>
<script type="math/tex; mode=display">
sig_K(x)=(y_1,y_2)\\
y_1=a_1+xb_1\mod q\\
y_2=a_2+xb_2\mod q</script><p>验证</p>
<script type="math/tex; mode=display">
ver_K(x,y)=true\Leftrightarrow \gamma_1\gamma_2^x=\alpha^{\gamma_1}\beta^{\gamma_2}\mod p</script><p>定义：如果$\gamma_1=\gamma_1’$，$\gamma_2=\gamma_2’$，那么密钥称为等价的</p>
<p>引理：K和K‘等价，那么$ver_K(x,y)=ver_{K’}(x,y)$</p>
<p>引理：恰好有q个等价的密钥K，$sig_K(x)=y$</p>
<p>引理：至多有一个等价密钥K’，使得$ver_{K’}(x,y)=ver_{K’}(x’,y’)=true$</p>
<p>定理：$sig_K(x)=y$，那么伪造者能计算出$sig_K(x’)$的概率为1/q</p>
<p><u>这是一个一次签名方案</u></p>
<p>246</p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计</title>
    <url>/2020/03/22/program-design/</url>
    <content><![CDATA[<h1 id="C语言输入输出"><a href="#C语言输入输出" class="headerlink" title="C语言输入输出"></a>C语言输入输出</h1><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>参数可变的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * , ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是格式字符串，后面的参数是变量的地址，函数作用是按照第一个参数指定的格式，将数据读入后面的变量</p>
<p>返回值</p>
<ul>
<li>>0 成功读入的数据个数</li>
<li>0 没有被赋值</li>
<li>EOF 第一个尝试输入的字符是EOF</li>
</ul>
<a id="more"></a>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>参数可变函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * , ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是格式字符串，后面的参数是待输出的变量，函数作用是按照第一个参数指定的格式，将后面的变量在屏幕上输出</p>
<p>返回值</p>
<ul>
<li>成功打印的字符数</li>
<li>返回负值为出错</li>
</ul>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">scanf</span>(<span class="string">"%d%c%s%lf%f"</span>,&amp;a,&amp;b,c,&amp;d,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %c %s %lf %e %f %d"</span>,a,b,c,d,e,e,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">gets</span><span class="params">(<span class="keyword">char</span> * s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从标准输入读取一行到字符串s</p>
<p>如果成功，返回值就是s 地址</p>
<p>如果失败，返回值是 NULL</p>
<p><u>调用时要确保s 指向的缓冲区足够大，否则可能发生内存访问错误</u></p>
<h2 id="sscanf和ssprint"><a href="#sscanf和ssprint" class="headerlink" title="sscanf和ssprint"></a>sscanf和ssprint</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> * format[, address, ...])</span></span>;</span><br><span class="line"><span class="comment">// 和scanf的区别在于，它是从buffer里读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format[, argument, ...])</span></span>;</span><br><span class="line"><span class="comment">// 和printf的区别在于，它是往buffer里输出数据</span></span><br></pre></td></tr></table></figure>
<h1 id="C语言高级内容"><a href="#C语言高级内容" class="headerlink" title="C语言高级内容"></a>C语言高级内容</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>定义形式：类型名 (* 指针变量名)(参数类型1, 参数类型2,…);</p>
<p>使用方法：可以用一个原型匹配的函数的名字给一个函数指针赋值。要通过函数指针调用它所指向的函数，写法为：函数指针名(实参表);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMin</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( a&lt;b )</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d"</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* pf)(<span class="keyword">int</span> ,<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>, y = <span class="number">5</span>;		</span><br><span class="line">    pf = PrintMin;   </span><br><span class="line">    pf(x,y);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用：qsort库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> ( * pfCompare)( <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>; <span class="comment">// base起始位置，nelem元素个数，width元素宽度</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;&#125; <span class="comment">// argc命令行参数个数，包括可执行程序本身的名字</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>六种运算符：&amp;，|，^，~，&lt;&lt;，&gt;&gt;</p>
<p>应用：交换a，b</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<h1 id="从C到C"><a href="#从C到C" class="headerlink" title="从C到C++"></a>从C到C++</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。 类型名 &amp; 引用名 = 某变量名; </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">int</span> &amp; r = n;  <span class="comment">// r引用了 n, r的类型是 int &amp;</span></span><br></pre></td></tr></table></figure>
<p>定义引用时一定要将其初始化成引用某个变量。</p>
<p>初始化后，它就一直引用该变量，不会再引用别 的变量了。</p>
<p>引用只能引用变量，不能引用常量和表达式。</p>
<p><u>C语言&amp;取指，C++中&amp;引用</u></p>
<p>引用可以作为函数的返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> n;  &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    SetValue() = <span class="number">40</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">//输出： 40</span></span><br></pre></td></tr></table></figure>
<p><u>const T &amp; 和T &amp; 是不同的类型</u></p>
<p>T &amp; 类型的引用或T类型的变量可以用来初始化 const T &amp; 类型的引用。</p>
<p>const T 类型的常变量和const T &amp; 类型的引用则 不能用来初始化T &amp;类型的引用，除非进行强制类 型转换</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>第一种用法，分配一个变量：T是任意类型名，P是类型为T * 的指针。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T;</span><br></pre></td></tr></table></figure>
<p>第二种用法，分配一个数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T[N];</span><br></pre></td></tr></table></figure>
<p><u>使用new动态分配的内存空间，一定要用delete进行释放</u></p>
<p>使用delete释放动态分配的数组，要加[]，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p> 为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( a &gt; b) <span class="keyword">return</span> a; </span><br><span class="line">    <span class="keyword">return</span> b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载</p>
<p>函数重载使得函数命名变得简单。 </p>
<p>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>其作用就是指向成员函数所作用的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 等价于 void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; "hello" &lt;&lt; endl; &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>非静态成员函数</strong>中可以直接使用this来代表指向该函数作用的对象的指针。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; imag ; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i) &#123;&#125;</span><br><span class="line">    <span class="function">Complex <span class="title">AddOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real ++; <span class="comment">//等价于 real ++;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;Print(); <span class="comment">//等价于 Print</span></span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><strong>静态成员</strong>是在说明前面加了static关键字的成员。静态成员变量本质上是全局变量。</p>
<p><u>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份， 为所有对象共享。</u></p>
<p>sizeof 运算符不会计算静态成员变量。  </p>
<p>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象，因此静态成员不需要通过对象就能访问。</p>
<p>四种种访问静态成员的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle::PrintTotal(); <span class="comment">// 类名::成员名</span></span><br><span class="line">CRectangle r; r.PrintTotal(); <span class="comment">// 对象名.成员名</span></span><br><span class="line">CRectangle * p = &amp;r; p-&gt;PrintTotal(); <span class="comment">// 指针-&gt;成员名</span></span><br><span class="line">CRectangle &amp; ref = r; <span class="keyword">int</span> n = ref.nTotalNumber; <span class="comment">// 引用.成员名</span></span><br></pre></td></tr></table></figure>
<p>必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。  </p>
<p><u>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</u></p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()&#123;</span><br><span class="line">    nTotalNumber --;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nTotalNumber &lt;&lt; <span class="string">","</span> &lt;&lt; nTotalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写缺陷是在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象  ，比如调用CRectangle类对象作为参数或作为返回值的函数时，并不会增加nTotalNumber，却会在这些对象消亡时调用析构函数。解决办法：写一个赋值构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle :: CRectangle(CRectangle &amp; r )&#123;</span><br><span class="line">    w = r.w; h = r.h;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>有<strong>成员对象</strong>的类叫<strong>封闭类</strong>。</p>
<p>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。</p>
<p>具体的做法就是：<u> 通过封闭类的构造函数的初始化列表 。</u> </p>
<p>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。</p>
<p>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。</p>
<p>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反  </p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CTyre() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre contructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CTyre() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CEngine() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine contructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CEngine() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CEngine engine;</span><br><span class="line">    CTyre tyre;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CCar( ) &#123; <span class="built_in">cout</span> &lt;&lt; “CCar contructor” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CCar() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CCar car;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">CEngine contructor</span></span><br><span class="line"><span class="comment">CTyre contructor</span></span><br><span class="line"><span class="comment">CCar contructor</span></span><br><span class="line"><span class="comment">CCar destructor</span></span><br><span class="line"><span class="comment">CTyre destructor</span></span><br><span class="line"><span class="comment">CEngine destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><u>封闭类的对象，如果是用默认复制构造函数初始化的，那么它里面包含的成员对象，也会用复制构造函数初始化。</u></p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元分为友元函数和友元类两种  </p>
<p><u>友元函数: 一个类的友元函数可以访问该类的私有成员。</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> ;</span> <span class="comment">//提前声明 CCar类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">( CCar * pCar)</span> </span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar * pCar); <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar( CCar * pCar)&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>; <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。</p>
<p><u>友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><u>友元类之间的关系不能传递，不能继承。</u></p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加 const关键字 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sample Obj;</span><br></pre></td></tr></table></figure>
<p>常量对象只能使用构造函数、析构函数和有const 说明的函数(常量方法）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sample() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数。  </p>
<p>在<u>定义常量成员函数</u>和<u>声明常量成员函数</u>时都应该使用const 关键字  </p>
<p>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么， 最好将其写成常量成员函数。</p>
<p>两个函数，名字和参数表都一样，但是一个是const,一个不是，算重载。  </p>
<p>const成员函数可以修改的成员变量要加mutable</p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载的实质是函数重载</p>
<p>可以重载为普通函数，也可以重载为成员函数</p>
<p>把含运算符的表达式转换成对运算符函数的调用</p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">double</span> real,imag; </span><br><span class="line">    Complex( <span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i= <span class="number">0.0</span> ):real(r),imag(i) &#123;&#125; </span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp; c); </span><br><span class="line">&#125;; </span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; a, <span class="keyword">const</span> Complex &amp; b) &#123; </span><br><span class="line">    <span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag); <span class="comment">//返回一个临时对象 </span></span><br><span class="line">&#125; </span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp; c) &#123; </span><br><span class="line">    <span class="keyword">return</span> Complex(real - c.real, imag - c.imag); <span class="comment">//返回一个临时对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>赋值运算符“=”只能重载为成员函数</p>
<p>如不定义自己的赋值运算符，那么可能会导致浅拷贝。</p>
<h2 id="运算符重载为友元函数"><a href="#运算符重载为友元函数" class="headerlink" title="运算符重载为友元函数"></a>运算符重载为友元函数</h2><p>有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line">    <span class="keyword">double</span> real,imag; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Complex( <span class="keyword">double</span> r, <span class="keyword">double</span> i):real(r),imag(i)&#123; &#125;; </span><br><span class="line">    Complex <span class="keyword">operator</span>+( <span class="keyword">double</span> r );  <span class="comment">// c + 5</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (<span class="keyword">double</span> r,<span class="keyword">const</span> Complex &amp; c); <span class="comment">// 5 + c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流插入-提取运算符的重载"><a href="#流插入-提取运算符的重载" class="headerlink" title="流插入/提取运算符的重载"></a>流插入/提取运算符的重载</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream &amp; ostream::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    ... <span class="comment">// 输出n的代码</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载类型转换运算符"><a href="#重载类型转换运算符" class="headerlink" title="重载类型转换运算符"></a>重载类型转换运算符</h2><h2 id="自增-自减运算符重载"><a href="#自增-自减运算符重载" class="headerlink" title="自增/自减运算符重载"></a>自增/自减运算符重载</h2><p>前置运算符作为一元运算符重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载为成员函数： </span></span><br><span class="line">T &amp; <span class="keyword">operator</span>++(); </span><br><span class="line">T &amp; <span class="keyword">operator</span>--(); </span><br><span class="line"><span class="comment">// 重载为全局函数： </span></span><br><span class="line">T1 &amp; <span class="keyword">operator</span>++(T2); </span><br><span class="line">T1 &amp; <span class="keyword">operator</span>--(T2);</span><br></pre></td></tr></table></figure>
<p>后置运算符作为二元运算符重载，多写一个没用的参数int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载为成员函数： </span></span><br><span class="line">T <span class="keyword">operator</span>++(<span class="keyword">int</span>); </span><br><span class="line">T <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 重载为全局函数： </span></span><br><span class="line">T1 <span class="keyword">operator</span>++(T2,<span class="keyword">int</span> ); </span><br><span class="line">T1 <span class="keyword">operator</span>--( T2,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>但是在没有后置运算符重载而有前置重载的情况下，在vs中，obj++ 也调用前置重载，而dev则令 obj ++ 编译出错</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>C++不允许定义新的运算符</p>
<p>重载不改变优先级顺序</p>
<p>重载(),[],-&gt;,=时，重载函数必须声明为类的成员函数。</p>
<h1 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h1><p>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量 和成员函数。</p>
<p>派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public 。</p>
<p>在派生类的各个成员函数中，不能访问 基类中的private成员。</p>
<h2 id="继承关系和复合关系"><a href="#继承关系和复合关系" class="headerlink" title="继承关系和复合关系"></a>继承关系和复合关系</h2><p>继承：B继承A，A是基类，B对象也是A对象</p>
<p>复合：C中有成员变量k，k是D对象</p>
<h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p> 派生类可以定义一个和基类成员同名的成员，这叫 覆盖。</p>
<p>在派生类中访问这类成员时，缺省的情况是 访问派生类中定义的成员。要在派生类中访问由基 类定义的同名成员时，要使用作用域符号::。</p>
<h2 id="类的保护成员"><a href="#类的保护成员" class="headerlink" title="类的保护成员"></a>类的保护成员</h2><p>基类的private成员：可以被下列函数访问 </p>
<ul>
<li>基类的成员函数 </li>
<li>基类的友员函数 </li>
</ul>
<p>基类的protected成员：可以被下列函数访问 </p>
<ul>
<li>基类的成员函数 </li>
<li>基类的友员函数 </li>
<li>派生类的成员函数可以访问<strong>当前对象的基类</strong>的保护成员</li>
</ul>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>构造函数不能访问基类的private变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> nLegs; <span class="keyword">int</span> nColor; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> nType; </span><br><span class="line">    Bug (<span class="keyword">int</span> legs, <span class="keyword">int</span> color); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span>:</span> <span class="keyword">public</span> Bug <span class="comment">// FlyBug是Bug的派生类 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> nWings; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">    FlyBug(<span class="keyword">int</span> legs,<span class="keyword">int</span> color, <span class="keyword">int</span> wings); </span><br><span class="line">&#125;;</span><br><span class="line">Bug::Bug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color) &#123; nLegs = legs; nColor = color; &#125;</span><br><span class="line"><span class="comment">//正确的FlyBug构造函数： </span></span><br><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color, <span class="keyword">int</span> wings):Bug( legs, color) &#123; nWings = wings; &#125;</span><br></pre></td></tr></table></figure>
<p>在创建派生类的对象时，需要调用基类的构造函数：初始化派 生类对象中从基类继承的成员。在执行一个派生类的构造函数 之前，总是先执行基类的构造函数。</p>
<p>调用基类构造函数的两种方式 </p>
<ul>
<li>显式方式：在派生类的构造函数中，为基类的构造函数提供参数. </li>
<li>隐式方式：在派生类的构造函数中，省略基类构造函数时， 派生类的构造函数则自动调用基类的默认构造函数.</li>
</ul>
<p>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</p>
<p>封闭派生类对象构造先基类构造函数，然执行对象成员的构造函数，最后执行自己的构造函数。析构时与之相反。</p>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><p>派生类的对象可以赋值给基类对象 </p>
<p>派生类对象可以初始化基类引用</p>
<p>派生类对象的地址可以赋值给基类指针</p>
<p>如果派生方式是 private或protected，则上述三条不可行</p>
<p><u>protected继承时，基类的public成员和protected成员成为派生类的protected成员。</u></p>
<p><u>private继承时，基类的public成员成为派生类的private成员，基类的protected成员成 为派生类的不可访问成员</u></p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h2><p>类的定义中，有virtual关键字的成员函数是虚函数</p>
<p>virtual关键字只用在类定义的函数声明中，写函数体时不用。</p>
<p>通过基类指针调用基类和派生类中的同名同参虚函数时: </p>
<ul>
<li>若该指针指向一个基类的对象，那么被调用是基类的虚 函数；</li>
<li>若该指针指向一个派生类的对象，那么被调用的是派生 类的虚函数。</li>
</ul>
<p>这种机制就叫做<strong>“多态”</strong>。</p>
<p>两种表现形式</p>
<ul>
<li><p>派生类的指针可以赋给基类指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    CDerived ODerived; </span><br><span class="line">    CBase * p = &amp; ODerived; </span><br><span class="line">    p -&gt; SomeVirtualFunction(); <span class="comment">//调用哪个虚函数取决于p指向哪种类型的对象 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类的对象可以赋给基类引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    CDerived ODerived; </span><br><span class="line">    CBase &amp; r = ODerived; </span><br><span class="line">    r.SomeVirtualFunction(); <span class="comment">//调用哪个虚函数取决于r引用哪种类型的对象 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><u>在非构造函数，非析构函数的成员 函数中调用虚函数，是多态!!!</u></p>
<p>在构造函数和析构函数中调用虚函数，不是多态。编 译时即可确定，调用的函数是自己的类或基类中定义 的函数，不会等到运行时才决定调用自己的还是派生 类的函数。</p>
<p>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</p>
<p><u>虚函数的访问权限根据基类定义所决定。</u></p>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><p>“多态”的关键在于通过基类指针或引用调用 一个虚函数时，编译时不确定到底调用的是基类还 是派生类的函数，运行时才确定——这叫<strong>“动态联编”</strong>。</p>
<p><u>多态实现的关键 —- 虚函数表</u></p>
<p>每一个有虚函数的类（或有虚函数的类的派生类） 都有一个虚函数表，该类的任何对象中都放着虚函数 表的指针。虚函数表中列出了该类的虚函数地址。</p>
<p>多态的函数调用语句被 编译成一系列根据基类指 针所指向的（或基类引用 所引用的）对象中存放的 虚函数表的地址，在虚函 数表中查找虚函数地址， 并调用虚函数的指令。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>   &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::Func"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A  &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::Func"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">	A a; </span><br><span class="line">	A * pa = <span class="keyword">new</span> B(); </span><br><span class="line">	pa-&gt;Func(); <span class="comment">//若是64位程序,指针为8字节，则应为long long </span></span><br><span class="line">	<span class="keyword">long</span> * p1 = (<span class="keyword">long</span> * ) &amp; a; </span><br><span class="line">	<span class="keyword">long</span> * p2 = (<span class="keyword">long</span> * ) pa; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; * p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; * p2 &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	* p2 = * p1; </span><br><span class="line">	pa-&gt;Func(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// B::Func</span></span><br><span class="line"><span class="comment">// A::Func</span></span><br></pre></td></tr></table></figure>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。但是，删除一个派生类的对象时，应该先调用派生类的析构函 数，然后调用基类的析构函数。 </p>
<p>解决办法：把基类的析构函数声明为virtual </p>
<p>派生类的析构函数可以virtual不进行声明</p>
<ul>
<li>通过基类的指针删除派生类对象时，首先调用派生类的析构函 数，然后调用基类的析构函数 </li>
<li>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成 虚函数。</li>
</ul>
<p>或者，一个类打算作为基类使用，也应该将析构函数定义 成虚函数。 </p>
<p><u>注意：不允许以虚函数作为构造函数</u></p>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>纯虚函数：没有函数体的虚函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br></pre></td></tr></table></figure>
<p>包含纯虚函数的类叫抽象类</p>
<p>不能创建抽象类的对象</p>
<p>抽象类只能作为基类来派生新类</p>
<p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部 不能调用纯虚函数。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>输入输出相关的类</p>
<p>istream/ostream/iostream 流类</p>
<p>ifstream/ofstream/fstream 文件类</p>
<h2 id="标准流对象"><a href="#标准流对象" class="headerlink" title="标准流对象"></a>标准流对象</h2><p>输入流cin从键盘读入</p>
<p>输出流cout、cerr、clog向屏幕输出（缺省情况下三者一样）</p>
<p>可以被重新向为向文件读/写数据</p>
<p>可以用如下方法判输入流结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;x)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果从键盘输入，则在单独一行输入ctrl+z代表输入流结束</p>
<h2 id="istream类成员函数"><a href="#istream类成员函数" class="headerlink" title="istream类成员函数"></a>istream类成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> bufSize)</span></span>;</span><br><span class="line"><span class="comment">// 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到‘\n’ 为止（哪个先到算哪个）</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> bufSize,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">// 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到delim字 符为止（哪个先到算哪个）</span></span><br></pre></td></tr></table></figure>
<p>两个函数都会自动在buf中读入数据的结尾添加\0’。</p>
<p>‘\n’或 delim都不会被读入buf，但会被从输入流中取走。如果输入流中 ‘\n’或delim之前的字符个数达到或超过了bufSize个，就导致读 入出错，其结果就是：虽然本次读入已经完成，但是之后的读入就 都会失败了</p>
<p>可以用 <code>if(!cin.getline(…))</code> 判断输入是否结束</p>
<p><code>bool eof();</code>判断输入流是否结束 </p>
<p><code>int peek();</code> 返回下一个字符,但不从流中去掉. </p>
<p><code>istream &amp; putback(char c);</code>将字符ch放回输入流 </p>
<p><code>istream &amp; ignore( int nCount = 1, int delim = EOF );</code> 从流中删掉最多nCount个字符，遇到EOF时结束。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">freopen(<span class="string">"test.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件 </span></span><br><span class="line">freopen(“t.txt”,“r”,<span class="built_in">stdin</span>);  <span class="comment">//cin被改为从 t.txt中读取数据</span></span><br></pre></td></tr></table></figure>
<h2 id="流操纵算子"><a href="#流操纵算子" class="headerlink" title="流操纵算子"></a>流操纵算子</h2><p><u>使用流操纵算子需要 <code>#include &lt;iomanip&gt;</code></u></p>
<p>整数流的基数：流操纵算子dec,oct,hex </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; “\n” <span class="comment">// a </span></span><br><span class="line">    &lt;&lt; dec &lt;&lt; n &lt;&lt; “\n”  <span class="comment">// 10</span></span><br><span class="line">    &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>指定输出浮点数有效位数（非定点方式输出）/小数点后有效位数（定点方式输出）：</p>
<p>precision是成员函数，调用方式为<code>cout.precision(5);</code></p>
<p>setprecision是流操作算子，调用方式为<code>cout&lt;&lt;setprecision(5);</code></p>
<p><code>setiosflags(ios::fixed)</code>定点输出模式</p>
<p><code>resetiosflags(ios::fixed)</code>非定点输出模式</p>
<p>设置域宽的流操作算子：</p>
<p>setw是流算子<code>cin&gt;&gt;setw(4);</code></p>
<p>width是成员函数<code>cin.width(5);</code></p>
<p><u>宽度设置有效性是一次性的，在每次读入和 输出之前都要设置宽度。</u></p>
<p>其他操作算子</p>
<p><code>showpos</code>显示正负号/<code>noshowpos</code>不显示正负号</p>
<p><code>left</code>、<code>right</code>、<code>internal</code>左/右/中</p>
<p><code>scientific</code>科学计数法</p>
<p>用户自定义算子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">tab</span><span class="params">(ostream &amp;output)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> output &lt;&lt; <span class="string">'\t'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这是因为iostream对&lt;&lt;进行了重载</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt;(  ostream &amp; ( * p ) ( ostream &amp; ) ) ;</span><br></pre></td></tr></table></figure>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p><code>#include&lt;fstream&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"clients.dat"</span>, ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ios::out</code> 删除原有内容 <code>ios::app</code>保留原有内容</p>
<p>也可以先出创建ofstream对象，再用<code>open</code>函数打开</p>
<p><code>tellp()</code>获得指针位置</p>
<p><code>seekp(location)</code>将指针移到location处</p>
<p><code>seekp(location, ios::beg)</code>从开头数，<code>seekp(location, ios::cur)</code>从当前数，<code>seekp(location, ios::end)</code>从结尾数</p>
<p>location可以是负数</p>
<p>关闭文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"1.dat"</span>, ios::in)</span></span>;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"1.dat"</span>, ios::out)</span></span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>二进制读文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span> <span class="params">(<span class="keyword">char</span>* s, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 将文件读指针指向的地方的n个字节内容，读入到内存地址s，然后将文件读指针向后移动n字节</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 将内存地址s处的n个字节内容，写入到文件中写指针指向的位置， 然后将文件写指针向后移动n字节</span></span><br></pre></td></tr></table></figure>
<p><u>二进制文件和文本文件的区别</u></p>
<p>Linux,Unix下的换行符号：‘\n’  (ASCII码:  0x0a) </p>
<p>Windows 下的换行符号：‘\r\n’  (ASCII码： 0x0d0a)    endl 就是 ‘\n’ </p>
<p>Mac OS下的换行符号： ‘\r’  (ASCII码：0x0d)</p>
<p>二进制和Linux下一致</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp; <span class="title">x</span>,<span class="title">T</span> &amp; <span class="title">y</span>) &#123;</span> </span><br><span class="line">    T tmp = x; </span><br><span class="line">    x = y; </span><br><span class="line">    y = tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以不通过参数实例化函数模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Inc</span>(<span class="title">T</span> <span class="title">n</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Inc&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>)/<span class="number">2</span>;  <span class="comment">//输出 2.5 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一 条函数调用语句</p>
<ol>
<li>先找参数完全匹配的普通函数(非由模板实例化而得的函数)。 </li>
<li>再找参数完全匹配的模板函数。 </li>
<li>再找实参数经过自动类型转换后能够匹配的普通函数。 </li>
<li>都找不到，则报错。</li>
</ol>
<p>匹配模板函数时，不进行类型自动转换</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    T1 key;  <span class="comment">//关键字 </span></span><br><span class="line">    T2 value;     <span class="comment">//值 </span></span><br><span class="line">    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Pair</span>&lt;T1,T2&gt;:</span>:<span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span> <span class="comment">//Pair的成员函数 operator &lt; </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> key &lt; p.key;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器由类模板生成类的过程叫类模板的实例化。</p>
<p>由类 模板实例化得到的类，叫模板类。</p>
<p><u>同一个类模板的两个模板类是不兼容的。</u></p>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数： <code>template &lt;class T, int size&gt;</code></p>
<h2 id="类模板和派生"><a href="#类模板和派生" class="headerlink" title="类模板和派生"></a>类模板和派生</h2><p>类模板从类模板派生</p>
<p>类模板从普通类派生</p>
<p>类模板从模板类派生</p>
<p>普通类从模板类派生</p>
<h2 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h2><p> 函数、类、类的成员函数作为类模板的友元 </p>
<p>函数模板作为类模板的友元 </p>
<p>函数模板作为类的友元 </p>
<p>类模板作为类模板的友元</p>
<h1 id="标准模板库（STL）"><a href="#标准模板库（STL）" class="headerlink" title="标准模板库（STL）"></a>标准模板库（STL）</h1><p>C++ 语言的核心优势之一就是便于软件的重用</p>
<p>C++中有两个方面体现重用：</p>
<ol>
<li><p>面向对象的思想：继承和多态，标准类库</p>
</li>
<li><p>泛型程序设计(generic programming) 的思想： 模板机制，以及标准模板库 STL</p>
</li>
</ol>
<p>将一些常用的数据结构（比如链表，数组，二叉树）和算法（比如排序，查找）写成模板，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。</p>
<p><strong>标准模板库 (Standard Template Library) </strong>就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。</strong></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>容器</strong>：可容纳各种数据类型的通用数据结构，是类模板</p>
<p><strong>迭代器：</strong>可用于依次存取容器中元素，类似于指针</p>
<p><strong>算法：</strong>用来操作容器中的元素的函数模板</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>对象被插入容器中时，被插入的是对象的一个<strong>复制品</strong>。许多算法，比如排序，查找，要求对容器中的元素进行比较，有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该重载 == 和 &lt; 运算符。</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>vector, deque, list</p>
<p><strong>vector</strong></p>
<p>头文件<code>&lt;vector&gt;</code></p>
<p>动态数组。元素在内存连续存放。随机存取任何元素都能在<strong>常数时间</strong>完成。在尾端增删元素具有较佳的性能</p>
<p><strong>deque</strong></p>
<p>头文件<code>&lt;deque&gt;</code></p>
<p>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成(但次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</p>
<p>所有适用于 vector的操作都适用于 deque。</p>
<p>deque还有 push_front（将元素插入到前面） 和 pop_front(删除最前面的元素）操作。</p>
<p><strong>list</strong></p>
<p>头文件<code>&lt;list&gt;</code></p>
<p>双向链表。元素在内存<strong>不连续存放</strong>。在任何位置增删元素都能在常数时间完成。<strong>不支持随机存取。</strong></p>
<p> 除了具有所有顺序容器都有的成员函数以外，还支持8个成员函数：</p>
<ul>
<li>push_front: 在前面插入</li>
<li>pop_front:  删除前面的元素</li>
<li>sort:    排序 ( list 不支持 STL 的算法 sort)</li>
<li>remove:    删除和指定值相等的所有元素</li>
<li>unique:   删除所有和前一个元素相同的元素</li>
<li>merge:    合并两个链表，并清空被合并的那个</li>
<li>reverse:    颠倒链表</li>
<li>splice:   在指定位置前面插入另一链表中的一个或多个元素,并在另一链表中删除被插入的元素</li>
</ul>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>元素是排序的</p>
<p>插入任何元素，都按相应的排序规则来确定其位置</p>
<p>在查找时具有非常好的性能</p>
<p>通常以平衡二叉树方式实现，插入和检索的时间都是 O(log(N))</p>
<p>set, multiset, map, multimap</p>
<p>内部元素有序排列，新元素插入的位置取决于它的值，查找速度快。</p>
<p>除了各容器都有的函数外，还支持以下成员函数：</p>
<ul>
<li>find: 查找等于某个值 的元素(x小于y和y小于x同时不成立即为相等)</li>
<li>lower_bound : 查找某个下界</li>
<li>upper_bound : 查找某个上界</li>
<li>equal_range : 同时查找上界和下界</li>
<li>count :计算等于某个值的元素个数(x小于y和y小于x同时不成立即为相等)</li>
<li>insert: 用以插入一个元素或一个区间</li>
</ul>
<p><strong>set/multiset</strong></p>
<p>头文件<code>&lt;set&gt;</code> </p>
<p>区别在于是否允许存储相同元素</p>
<p>multiset的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, </span></span><br><span class="line"><span class="class">	        <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multiset</span> &#123;</span> …… &#125;;</span><br></pre></td></tr></table></figure>
<p>Pred类型的变量决定了multiset 中的元素，“一个比另一个小”是怎么定义的。multiset运行过程中，比较两个元素x,y的大小的做法，就是生成一个 Pred类型的变量，假定为 op,若表达式op(x,y) 返回值为true,则 x比y小。 Pred的缺省类型是<code>less&lt;Key&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// less模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; </span><br><span class="line">&#123; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ; &#125; <span class="keyword">const</span>;   &#125;;</span><br></pre></td></tr></table></figure>
<p>multiset用法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">multiset</span>&lt;A&gt; a;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;A, less&lt;A&gt;&gt; a;</span><br></pre></td></tr></table></figure>
<p>由于less模板默认&lt;比较大小，所以A不可比较时需要重载&lt;</p>
<p><strong>map/multimap</strong></p>
<p>头文件<code>&lt;map&gt;</code></p>
<p>map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。</p>
<p>pair模板如下，map/multimap里放着都是pair模板类的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">     <span class="keyword">typedef</span> _T1 first_type;  </span><br><span class="line">     <span class="keyword">typedef</span> _T2 second_type; </span><br><span class="line">     _T1 first;               </span><br><span class="line">     _T2 second;              </span><br><span class="line">     pair(): first(), second() &#123; &#125;</span><br><span class="line">     pair(<span class="keyword">const</span> _T1&amp; __a, <span class="keyword">const</span> _T2&amp; __b)</span><br><span class="line">     : first(__a), second(__b) &#123; &#125;</span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">U1</span>, <span class="title">class</span> _<span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;_U1, _U2&gt;&amp; __<span class="title">p</span>)</span></span><br><span class="line"><span class="class">:</span> first(__p.first), second(__p.second) &#123; &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>multimap定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">		 <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span> &#123;</span> </span><br><span class="line">	….</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type; </span><br><span class="line">	…….	</span><br><span class="line"> &#125;;    <span class="comment">//Key 代表关键字的类型</span></span><br></pre></td></tr></table></figure>
<p>multimap中的元素由 &lt;关键字,值&gt;组成，每个元素是一个pair对象，关键字就是first成员变量,其类型是Key</p>
<p>multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 <code>less&lt;Key&gt;</code> 定义关键字的“小于”关系。</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>stack, queue, priority_queue</p>
<ul>
<li>push 插入元素</li>
<li>pop 弹出元素</li>
<li>top 返回栈顶元素的引用</li>
</ul>
<p><strong>stack</strong></p>
<p>头文件<code>&lt;stack&gt;</code></p>
<p>后进先出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> = <span class="title">deque</span>&lt;T&gt; &gt;  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span> </span><br><span class="line">	…..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可用 vector, list, deque来实现。缺省情况下，用deque实现。用 vector和deque实现，比用list实现性能好。</p>
<p><strong>queue</strong></p>
<p>头文件<code>&lt;queue&gt;</code></p>
<p>先进先出</p>
<p>和stack 基本类似，可以用 list和deque实现。缺省情况下用deque实现。</p>
<p><strong>priority_queue</strong></p>
<p>头文件<code>&lt;queue&gt;</code></p>
<p>优先级队列。最高优先级元素总是第一个出列</p>
<p>和 queue类似，可以用vector和deque实现。缺省情况下用vector实现。</p>
<p>priority_queue 通常用堆排序技术实现，保证最大的元素总是在最前面。即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的引用。默认的元素比较器是 <code>less&lt;T&gt;</code>。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>begin 第一个元素的迭代器</p>
<p>end 最后一个元素后面的迭代器</p>
<p>rbegin 最后一个元素的迭代器</p>
<p>rend 第一个元素前面的迭代器</p>
<p>erase</p>
<p>clear</p>
<p>front 第一个元素的引用</p>
<p>back 最后一个元素的引用</p>
<p>push_back</p>
<p>pop_back</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>用于指向顺序容器和关联容器中的元素</p>
<p>迭代器用法和指针类似</p>
<p>有const 和非 const两种</p>
<p>通过迭代器可以读取它指向的元素</p>
<p>通过非const迭代器还能修改其指向的元素</p>
<p>定义一个容器类的迭代器的方法可以是：</p>
<p> <code>容器类名::iterator  变量名;</code></p>
<p>或：</p>
<p> <code>容器类名::const_iterator 变量名;</code></p>
<p>访问一个迭代器指向的元素：</p>
<p> <code>* 迭代器变量名</code></p>
<p>迭代器可以执行++，—</p>
<p>可以判断是否相等</p>
<p>如果是随机访问迭代器，可以+i，-i， p[i]，可以判断大小</p>
<p>容器适配器（stack、queue、priority_queue）不支持迭代器</p>
<p>vector/deque 随机访问，list/set/map 双向</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法就是一个个<strong>函数模板</strong>, 大多数在<code>&lt;algorithm&gt;</code> 中定义</p>
<p>STL中提供能在各种容器中通用的算法，比如查找，排序等</p>
<p>算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找</p>
<p>有的算法返回一个迭代器。比如 find() 算法，在容器中查找一个元素，并返回一个指向该元素的迭代器</p>
<p>算法可以处理容器，也可以处理普通数组</p>
<p><strong>find</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
<p>first 和 last 这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first,last)。区间的起点是位于查找范围之中的，而终点不是。find在[first,last)查找等于val的元素</p>
<p>用 == 运算符判断相等</p>
<p>函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last</p>
<p><strong>STL中“大”“小” 的概念</strong></p>
<p>关联容器内部的元素是从小到大排序的</p>
<p>有些算法要求其操作的区间是从小到大排序的，称为“有序区间算法”，例如<code>binary_search</code></p>
<p>有些算法会对区间进行从小到大排序，称为“排序算法”，例如<code>sort</code></p>
<p>还有一些其他算法会用到“大”，“小”的概念</p>
<p>使用STL时，在缺省的情况下，以下三个说法等价：</p>
<ul>
<li>x比y小</li>
<li>表达式“x&lt;y”为真</li>
<li>y比x大</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>是个对象，但是用起来看上去象函数调用，实际上也执行了函数调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyAverage</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3 )</span> </span>&#123; <span class="comment">//重载 () 运算符</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2+a3) / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> CMyAverage average;  <span class="comment">//函数对象</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// average.operator()(3,2,3) 用起来看上去象函数调用 输出 2.66667</span></span><br></pre></td></tr></table></figure>
<p>STL里有以下模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">val</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure>
<p>pr 就是个函数对象。</p>
<p>对[first,last)中的每个迭代器 I, </p>
<p>执行 val = pr(val,* I) ,返回最终的val。</p>
<p>Pr也可以是个函数。</p>
<p><strong>greater 函数对象类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;&#123; </span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x &gt; y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//binary_function定义：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span> </span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type; </span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>STL中的算法大致可以分为以下七类：</p>
<ul>
<li><p>不变序列算法</p>
<p>此类算法不会修改算法所作用的容器或对象，适用于所有容器。它们的时间复杂度都是O(n)的。</p>
<p>min、max、for_each、count、count_if、find、find_if、find_end、find_first_of、adjacent_find，search、search_n、equal</p>
</li>
<li><p>变值算法</p>
<p>此类算法会修改源区间或目标区间元素的值。值被修改的那个区间，不可以是属于关联容器的。</p>
<p>for_each、copy、copy_backward、transform、swap_ranges、fill、fill_n、generate、replace、replace_if、replace_copy、replace_copy_if</p>
</li>
<li><p>删除算法</p>
<p>删除算法会删除一个容器里的某些元素。这里所说的“删除”，并不会使容器里的元素减少，其工作过程是：将所有应该被删除的元素看做空位子，然后用留下的元素从后往前移，依次去填空位子。元素往前移后，它原来的位置也就算是空位子，也应由后面的留下的元素来填上。最后，没有被填上的空位子，维持其原来的值不变。删除算法不应作用于关联容器。</p>
<p>remove、remove_if、remove_copy、remove_copy_if、unique、unique_copy</p>
</li>
<li><p>变序算法</p>
<p>变序算法改变容器中元素的顺序，但是不改变元素的值。变序算法不适用于关联容器。此类算法复杂度都是O(n)的。</p>
<p>reverse、reverse_copy，rotate（左移）、next_permutation（下一个排列）、prev_permutation、random_shuffle（需要预设随机种子）、partition</p>
</li>
<li><p>排序算法</p>
<p>排序算法比前面的变序算法复杂度更高，一般是O(n×log(n))。排序算法需要随机访问迭代器的支持，因而不适用于关联容器和list。</p>
<p>sort（快排）、stable_sort（归并）、partial_sort（部分排序，直到最小的n个元素就位）、nth_element、make_heap、push_heap、pop_heap、sort_heap</p>
</li>
<li><p>有序区间算法</p>
<p>有序区间算法要求所操作的区间是已经从小到大排好序的，而且需要随机访问迭代器的支持。所以有序区间算法不能用于关联容器和list。</p>
<p>binary_search、includes、lower_bound、upper_bound、merge、set_union、set_intersection、set_difference、</p>
</li>
<li><p>数值算法</p>
</li>
</ul>
<p>大多重载的算法都是有两个版本的，其中一个是用“==”判断元素是否相等，或用“&lt;”来比较大小；而另一个版本多出来一个类型参数“Pred”，以及函数形参“Pred op”,该版本通过表达式“op(x,y)”的返回值是ture还是false，来判断x是否“等于”y，或者x是否“小于”y。如下面的有两个版本的min_element:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last)</span></span>;</span><br><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last, Pred op)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++11特性"></a>C++11特性</h1><p>统一的是初始化方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;  mp&#123;&#123;<span class="number">1</span>, <span class="string">"a"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"b"</span>&#125;&#125;; </span><br><span class="line"><span class="built_in">string</span> str&#123;<span class="string">"Hello World"</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    A(<span class="keyword">int</span> m,<span class="keyword">int</span> n):i(m),j(n) &#123; &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A * pa = <span class="keyword">new</span> A &#123;<span class="number">3</span>,<span class="number">7</span>&#125;; </span><br><span class="line">    A a[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量默认初始值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1234</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>auto关键字：用于定义变量，编译起可以自动判断变量的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span></span><br></pre></td></tr></table></figure>
<p>decltype 关键字：求表达式的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span></span><br></pre></td></tr></table></figure>
<p>智能指针shared_ptr：通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返 回的指针,此后ptr就可以像 T<em> 类型的指针一样来使用，即 </em>ptr 就是用new动态分配的那 个对象，而且不必操心释放内存的事。多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当 无shared_ptr托管该指针时，delete该指针。 <u>shared_ptr对象不能托管指向动态分配的数组的指针，否则程序运行会出错</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sp1(<span class="keyword">new</span> A(<span class="number">2</span>)); <span class="comment">//sp1托管A(2) </span></span><br><span class="line">    sp1.reset();           <span class="comment">//sp1放弃托管 A(2) </span></span><br><span class="line">    A * q = <span class="keyword">new</span> A(<span class="number">3</span>); </span><br><span class="line">    sp1.reset(q); <span class="comment">// sp1托管q </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于范围的for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ary[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp; e: ary)  </span><br><span class="line">        e*= <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : ary) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右值引用和move语义：一般来说，不能取地址的表达式，就是右值， 能取地址的，就是左值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;; </span><br><span class="line">A &amp; r = A(); <span class="comment">// error , A()是无名变量，是右值 </span></span><br><span class="line">A &amp;&amp; r = A(); <span class="comment">//ok, r 是右值引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MoveSwap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>)   &#123;</span> </span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(<span class="built_in">move</span>(a))</span></span>; <span class="comment">// std::move(a)为右值，这里会调用move constructor </span></span><br><span class="line">    a = <span class="built_in">move</span>(b);    <span class="comment">// move(b)为右值，因此这里会调用move assigment </span></span><br><span class="line">    b = <span class="built_in">move</span>(tmp);  <span class="comment">// move(tmp)为右值，因此这里会调用move assigment </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无序容器(哈希表) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; </span></span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; turingWinner; <span class="comment">//图灵奖获奖名单</span></span><br></pre></td></tr></table></figure>
<p>正则表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">"b.?p.*k"</span>)</span></span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_match(<span class="string">"bopggk"</span>,reg) &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符](参数表) -&gt;返回值类型 &#123; 语句组 &#125;</span><br><span class="line"><span class="comment">// “-&gt;返回值类型”也可以没有， 没有则编译器自动判断返回值类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[] 不使用任何外部变量 </span></span><br><span class="line"><span class="comment">[=] 以传值的形式使用所有外部变量 </span></span><br><span class="line"><span class="comment">[&amp;] 以引用形式使用所有外部变量 </span></span><br><span class="line"><span class="comment">[x, &amp;y] x 以传值形式使用，y 以引用形式使用 </span></span><br><span class="line"><span class="comment">[=,&amp;x,&amp;y] x,y 以引用形式使用，其余变量以传值形式使用 </span></span><br><span class="line"><span class="comment">[&amp;,x,y] x,y 以传值的形式使用，其余变量以引用形式使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>多线程 </p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="C-11高级特性"><a href="#C-11高级特性" class="headerlink" title="C++11高级特性"></a>C++11高级特性</h1><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>static_cast、reinterpret_cast、const_cast和dynamic_cast</p>
<p>static_cast用来进用行比较“自然”和低风险的转换，比 如整型和实数型、字符型之间互相转换。static_cast不能来在不同类型的指针之间互相转换，也不 能用于整型和指针之间的互相转换，也不能用于不同类型的 引用之间的转换。</p>
<p>reinterpret_cast用来进行各种不同类型的指针之间的转换、不同 类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间 的转换。转换的时候，执行的是逐个比特拷贝的操作。</p>
<p>const_cast用来进行去除const属性的转换。将const引用转换成同类型的非 const引用，将const指针转换为同类型的非const指针时用它。</p>
<p>dynamic_cast专门用于将多态基类的指针或引用，强 制转换为派生类的指针或引用，而且能够检查转换的 安全性。对于不安全的指针转换，转换结果返回NULL 指针。 </p>
<p>dynamic_cast不能用于将非多态基类的指针或引用， 强制转换为派生类的指针或引用</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;... <span class="keyword">throw</span> ...&#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>C++标准库中有一些类代表异常，这些类都是从exception类派生而来</p>
<p>bad_typeid</p>
<p>bad_cast</p>
<p>bad_alloc</p>
<p>ios_base::failure</p>
<p>logic_error/out_of_range</p>
<h2 id="运行时类型检查"><a href="#运行时类型检查" class="headerlink" title="运行时类型检查"></a>运行时类型检查</h2><p> C++运算符typeid是单目运算符，可以在程序运行过程中获取一个表达式的值的 类型。typeid运算的返回值是一个type_info类的对象，里面包含了类型的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; //要使用typeinfo，需要此头文件</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1) int is: "</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">int</span>).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) int is: in</span></span><br></pre></td></tr></table></figure>
<h2 id="Boost-Any"><a href="#Boost-Any" class="headerlink" title="Boost.Any"></a>Boost.Any</h2><p> 实现任意类型的存储 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">any a = <span class="number">10</span>;        <span class="comment">// 存储一个 int  </span></span><br><span class="line">a = <span class="built_in">string</span>(“hello world”); <span class="comment">// 存储字符串  </span></span><br><span class="line">a = myclass(); <span class="comment">// 存储自己的对象  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; any_cast&lt;<span class="keyword">int</span>&gt;(a); <span class="comment">// 转换为需要的类型</span></span><br></pre></td></tr></table></figure>
<p>关于 any_cast </p>
<p> 存储的类型与转换的类型不一致会抛出bad_any_cast </p>
<p>指针版不一致返回空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/any.hpp&gt; </span></span></span><br><span class="line"><span class="comment">//成员函数： </span></span><br><span class="line">any(); </span><br><span class="line">~any(); </span><br><span class="line">any(<span class="keyword">const</span> any&amp;); </span><br><span class="line">any&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> any&amp;); </span><br><span class="line"><span class="function">any&amp; <span class="title">swap</span><span class="params">(any&amp;)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt; any(<span class="keyword">const</span> ValueType&amp;); </span><br><span class="line">any&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ValueType&amp;); </span><br><span class="line"><span class="comment">// 独立函数： </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt; </span><br><span class="line"><span class="function">ValueType <span class="title">any_cast</span><span class="params">(<span class="keyword">const</span> any&amp;)</span></span>; <span class="comment">// Throw bad_any_cast </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> ValueType* <span class="title">any_cast</span><span class="params">(<span class="keyword">const</span> any*)</span></span>; <span class="comment">// Return NULL </span></span><br><span class="line"><span class="function">ValueType* <span class="title">any_cast</span><span class="params">(any*)</span></span>;</span><br></pre></td></tr></table></figure>
<p><u> 抽象基类 + 模板派生 = 编译时的多态</u></p>
<h2 id="多文件共享全局变量"><a href="#多文件共享全局变量" class="headerlink" title="多文件共享全局变量"></a>多文件共享全局变量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span></span><br></pre></td></tr></table></figure>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>一个类可以有多个直接基类，这叫多继承 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>多继承可能导致二义性，因此需要把直接基类继承base声明为<strong>虚拟基类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span> : </span><br><span class="line">    <span class="keyword">int</span> va;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A  &#123;  <span class="keyword">int</span> vb;    &#125;;     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A  &#123;  <span class="keyword">int</span> vc;    &#125;;         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;  <span class="keyword">int</span>  vd ; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>调用C函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">c_func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>python调用C++</p>
<p>编译成动态链接库c.so，然后拷贝到调用它的python程序的文件夹下: g++ -o c.so -shared -fPIC c.cpp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes </span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> * <span class="comment"># c类型库 </span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">libc = CDLL(<span class="string">'c.so'</span>) <span class="comment">#装入动态链接库 </span></span><br><span class="line">libc.cpp_func1(c_char_p(bytes(<span class="string">"this高达"</span>,encoding=<span class="string">"utf-8"</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(#define XXX/#undef XXX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XXX/#<span class="meta-keyword">ifndef</span> XXX</span></span><br><span class="line">...</span><br><span class="line">(#<span class="keyword">else</span> ...)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="STL-Review"><a href="#STL-Review" class="headerlink" title="STL(Review)"></a>STL(Review)</h1><p>六大部件</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; vi(ia, ia+<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 容器vector，分配器allocator（可以不写）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_if(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">                    not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>))));</span><br><span class="line">    <span class="comment">// 算法count_if 迭代器.begin .end </span></span><br><span class="line">    <span class="comment">// 函数适配器negator binder 函数less</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><p>Set/Map 都是用红黑树实现的 </p>
<p>单向列表<code>forward_list</code>（和GNU_C中的<code>slist</code>完全一样），只有<code>push_front</code></p>
<p><code>array</code>无法扩充，<code>vector</code>两倍扩充</p>
<p><code>deque</code>是一个本质是map到buffer的一些指针，</p>
<p><code>unordered_multimap</code>相当于hash_map</p>
<p><code>hash_set</code> <code>hash_map</code> <code>hash_multiset</code> <code>hash_multimap</code>并不是规范C++语言，但在编译器中实现（注意include的头文件位置） </p>
<p>容器分类：</p>
<p>序列式容器：</p>
<ul>
<li>array</li>
<li>vector<ul>
<li>heap<ul>
<li>priority_queue</li>
</ul>
</li>
</ul>
</li>
<li>list</li>
<li>slist（非标准）</li>
<li>dequeue（分段连续）<ul>
<li>stack</li>
<li>queue</li>
</ul>
</li>
</ul>
<p>关联式容器</p>
<ul>
<li>rb_tree（非公开）<ul>
<li>set</li>
<li>map</li>
<li>multiset</li>
<li>multimap</li>
</ul>
</li>
<li>hashtable（非公开、非标准）<ul>
<li>hash_set</li>
<li>hash_map</li>
<li>hash_multiset</li>
<li>hash_multimap</li>
</ul>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>GNU2.9</strong> sizeof=4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中list node定义为（这里void pointer是有明显问题的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中list iterator定义为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    </span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer operato r-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;node=(link_type)((*node).next);<span class="keyword">return</span> *<span class="keyword">this</span>&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;self tmp=*<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125; </span><br><span class="line">    <span class="comment">// tmp=*this 并不会调用重载的*，因为赋值操作被重载，this被解释为参数 </span></span><br><span class="line">    <span class="comment">// __list_iterator(const iterator&amp; x): node(x.node)&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 之后++*this 也不会调用重载的*，因为*this已被解释为参数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GNU4.9</strong></p>
<p>修改了iterator和node的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list 定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc=<span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">list</span>: <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;_Tp&gt; iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iterator 定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span>&#123;</span></span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">    _List_node_base* _M_prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span>:</span> <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">    _Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list的父类定义<code>_List_base</code>有成员<code>_List_impl&lt;_Tp,_A&gt;</code>继承自<code>_A&lt;List_node&lt;_Tp&gt;&gt;</code></p>
<p><u>list的实际实现是<strong>双向、环状</strong>的，为了符合“前闭后开”的要求。</u></p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>两倍扩张</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)&#123;</span><br><span class="line">        construct(finish, x);</span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert_aux(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux(iterator <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)&#123; <span class="comment">// 和push_back里的检查是一样的</span></span><br><span class="line">        construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        copy_backward(<span class="built_in">position</span>, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *<span class="built_in">position</span> = x_copy</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        iterator new_start = data_allocator::allocate(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            new_finish = uninitialized_copy(start, <span class="built_in">position</span>, new_start);</span><br><span class="line">            construct(new_finish, x);</span><br><span class="line">            ++new_finish;</span><br><span class="line">            new_finish = uninitialized_copy(<span class="built_in">position</span>, finish, new_finish); <span class="comment">//拷贝安插点之后的内容，因为insert也可能需要扩充</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁原vector</span></span><br><span class="line">        destroy(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector的iterator（GNU4.9：舍近求远）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span> : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Vector_Base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, <span class="built_in">vector</span>&gt; iterator;</span><br><span class="line">    <span class="comment">// _M_current:_Tp* 本质与GNU2.9相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>TR1版本（C++1之后）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    </span><br><span class="line">    value_type _M_instance[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">// 长度为0的默认为1</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GNU4.9中的定义方式本质与之相同，变得更加复杂，但没有明显好处</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//support for zero-sized array</span></span><br><span class="line">    <span class="keyword">typedef</span> _GLIIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line">    <span class="keyword">typename</span> _AT_Type::_Type _M_elems;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">array_traits</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp _Type[_Nm];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">100</span>] b; <span class="comment">// fail</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T[<span class="number">100</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>看上去连续，其实是分段的：多个buffer（或者称为node）</p>
<p>有一个中控（称为map）维护这些buffer，map是个vector</p>
<p>iterator分为四格：cur,first,last,node（前三个都是指向node中的位置）</p>
<p><code>deque&lt;T&gt;::insert()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">position</span>.cur == start.cur)&#123;</span><br><span class="line">        push_front(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">position</span>.cur == finish.cur)&#123;</span><br><span class="line">        push_back(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert_aux(<span class="built_in">position</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)&#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>)&#123;</span><br><span class="line">        push_front(front());</span><br><span class="line">        ...</span><br><span class="line">        copy(front2, pos1, front1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        push_back(back());</span><br><span class="line">        ...</span><br><span class="line">        copy_backward(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stack</code>和<code>queue</code>更像是适配器，底层默认deque实现。它们都不允许遍历，也不提供<code>iterator</code></p>
<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>例：以<code>rotate</code>函数为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(_ForwardIterator __first,</span></span></span><br><span class="line"><span class="function"><span class="params">                  _ForwardIterator __middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                  _ForwardITerator __last)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::__rotate(__first, __middle, __last,</span><br><span class="line">                  <span class="built_in">std</span>::__iterator_category(__first));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rotate</code>需要知道iterators的三个associated types：为了回答iterator的类型，在C++标准库中设计出5种，<code>iterator_category</code>，<code>difference_type</code>， <code>value_type</code>，<code>reference</code>， <code>pointer</code>，后两种在STL中从未使用过。</p>
<p>回答的方式：<code>typedef</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GNU2.9</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// necessary </span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GNU4.9</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type; <span class="comment">// necessary </span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>萃取机<code>traits</code></p>
<p>分辨iterator是class还是pointer</p>
<p>实现方法：<em>偏特化</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">sturct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const *T&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>标准库中有各式各样的萃取机</u></p>
<h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>除了默认的allocator之外还有</p>
<p>mt_allocator，debug_allocator，pool_allocator，bitmap_allocator，malloc_allocator，new_allocator，要<code>include&lt;ext\相应的头文件&gt;</code></p>
<p><u>分配器可以直接使用，但没有必要</u></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">allocator&lt;<span class="keyword">int</span>&gt; alloc;</span><br><span class="line">p = alloc.allocate(<span class="number">1</span>); <span class="comment">// 1个元素</span></span><br><span class="line">alloc.deallocate(p, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>所有分配内存（包括<code>new</code>）都会归结到<code>malloc</code></p>
<p>由于malloc需要记录指针和<em>分配内存大小</em>，这是额外开销。但在容器中，利用元素大小相同这一点，G2.9 标准库 alloc对<code>allocator</code>的实现设计了16个链表，以节省这一部分开销。G4.9中命名为pool_allocator可以调用（不再是默认）。</p>
<h2 id="泛型编程（GP）"><a href="#泛型编程（GP）" class="headerlink" title="泛型编程（GP）"></a>泛型编程（GP）</h2><p>面向对象编程（OOP）把方法放进对象</p>
<p>泛型编程（GP）却将datas和methods分开</p>
<p><em>算法</em>通过<em>迭代器</em>确定操作范围，并通过<em>迭代器</em>取用<em>容器</em>元素。这样<em>算法</em>和<em>容器</em>可以独立开发。</p>
<p>所有的算法，最终涉及元素本身的操作，就是<u>比大小</u></p>
<p>Template模板（略）</p>
<p>Specialization特化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span>...&#125;</span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt;&#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
<p>Partial Specialization偏特化：可以特化一部分template（个数偏特化），也可以改变template</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span>...&#125;</span><br><span class="line"><span class="comment">// 偏特化为指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂性问题</title>
    <url>/2020/03/20/complexity/</url>
    <content><![CDATA[<p>P/NP</p>
<h3 id="PCP-History"><a href="#PCP-History" class="headerlink" title="PCP History"></a>PCP History</h3><p>PCP Theorem begins at MIT in the early 1980s: <em>The Knowledge Complexity of Interactive Proof Systems(Goldwasser, Micali, Rackoff)</em>，文中给出如下定义：</p>
<p>定义 1：<strong>IP（Interactive Proofs）</strong>定义为一个验证者（verifier）和全能的证明者（prover）进行多项式轮交互，正确的论述一定通过 (“completeness”)，错误的论述会有至少1/2的概率不通过 (“soundness”)  </p>
<p>独立于上述工作的<em>Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes(Babai, Moran)</em>，定义如下：</p>
<p>定义 2：<strong>AM[k]</strong>是k轮的交互过程。</p>
<p>Babai证明了（定理 1）对任何常数k，AM[k]=AM[2]，因此AM[2]也被写作AM。AM[poly]和IP很相似，区别在于coin是否public，Goldwasser和Sipser很快证明了他们等价。</p>
<a id="more"></a>
<p>定义 3：Graph Non-Isomorphism是给定两个图的邻接表，判断他们是否同构</p>
<p>定理 2： Graph Non-Isomorphism是IP问题。（证明：随机重命名图，然后给prover判断是哪个）</p>
<p>定义 4：<strong>MIP</strong>是和多个独立Prover的交互问题。（Ben-Or, Goldwasser, Kilian, Wigderson, 1988）（他们还证明了多个Prover和两个Prover等价）</p>
<p>定理 3：$P^{井P}\subseteq IP$（Lund, Fortnow, Karloff, Nisan, 1990）</p>
<p>定理 4：IP=PSPACE（Shamir, 1990）</p>
<p>定理 5：MIP=NEXP（Babai, Fortnow, Lund, 1990）</p>
<p>人们试图给Verifier加限制，比如空间限制，Condon证明了NP是Verifier有对数空间和单向读权限的IP，另一个限制是时间，但是B-F-L-S证明了Prover用特定语言来写证明就可以在多项式时间内证明所有NP。最有趣的是同时限制Verifier的随机数数量和Proof的大小，其定义如下</p>
<p>定义 5：$PCP[r(n),q(n)]$是PCP系统，使用$O(r(n))$字节的Randomness，$O(q(n))$字节的Proof，并且completeness 1，soundness 1/2。</p>
<p>在这个定义下，$MIP=NEXP$的结果等价于$NEXP\subseteq PCP[poly, poly]$。B-F-L-S关于时间的限制的结论等价于$NP\subseteq PCP[polylog, polylog]$。</p>
<p>定理 6：$NP\subseteq PCP(f(n), f(n))$，其中$f(n)=log(n)log(log(n))$，进一步，MAX-CLIQUE无法近似除非$NP\subseteq DTIME(n^{log(log(n))})$（FGLSS，FOCS，1991）</p>
<p>看上去$NP\subseteq PCP[log(n),log(n)]$是必然的，最终在1992年得到证明，query的数量约$10^6$</p>
<p>定理 7： $NP\subseteq PCP[log(n), log(n)]$，实际上$NP\subseteq PCP[log(n), log(n)^{.5+\epsilon}]$（Arora，Safra，1992）</p>
<p>定理 8（<strong>PCP定理</strong>）：$NP\subseteq PCP[log(n), 1]$（Arora-Lund-Motwani-Sudan-Szegedy，1992）</p>
<h3 id="算子代数"><a href="#算子代数" class="headerlink" title="算子代数"></a>算子代数</h3><p><strong>Connes‘ embeddings conjecture（CEC）</strong>是算子代数最有名的开放问题之一，猜测任意有限冯诺依曼代数可以被有限维矩阵代数接近。</p>
<p>CEC有很多等价形式，其中之一是<strong>Tsirelson’s Problem</strong>，这个问题从Einstein-Podolsky-Rosen的问题出发，定义希尔伯特空间H，一个Projection valued measure（PVM）定义为H上投影的有限集合$\{P_1,…,P_m\}$满足$\sum P_i=Id$。对于有限指标集$X,Y,A,B$，Tsirelson考虑凸子集$Q_{ABXY}^C$（commuting）和$Q_{ABXY}^S$（spatial），定义如下</p>
<script type="math/tex; mode=display">
Q_{ABXY}^C=\{(<\phi,A_a^xB_b^y\phi>)_{a,b,x,y}:\phi\in H,\\
\{A_a^x\}_{a\in A},\{B_b^y\}_{b\in B}PVM,[A_a^x,B_b^y]=0\}</script><script type="math/tex; mode=display">
Q_{ABXY}^S=\{(<\phi,A_a^x\otimes B_b^y\phi>)_{a,b,x,y}:\phi\in H_A\otimes H_B,\\
\{A_a^x\}_{a\in A},\{B_b^y\}_{b\in B}PVM\:on\:H_A,H_B,\:resp.\}</script><p>Tsirelson起初声称两者相等，但很快他把两者是否相等重新设定为开放问题。约25年后Slofstra证明了两者不等，但$\bar{Q_{ABXY}^S}=Q_{ABXY}^C$是否成立依旧开放。Ozawa证明了这个问题和CEC等价，这样将这个问题从量子力学领域转移到算子代数领域。</p>
<p>Tsirelson的问题的提出源自量子力学的<strong>entanglement</strong>现象。在E-P-R之后30年，Bell提出<strong>Bell实验</strong>，假设两个物理系统从任意状态初始，假设两个系统可以分别被有限集合$A^x,x\in X$和$B^y,y\in Y$度量，假设通过度量产生$(a,b)\in A\times B$，定义<strong>correlation set</strong>为包含所有$p_{abxy}$的凸集$K_{ABXY}\subseteq [0,1]^{A\times B\times X\times Y}$。Bell实验需要联合可测性，冯诺依曼证明这等价于$A^x\in O_A$和$B^y\in O_B$可交换。谱分解为$A^x=\sum_a\lambda_aA_a^x$和$B^y=\sum_b\mu_bB_b^y$，然后可以定义观测到$(a,b)$的概率，可以证明这是well-defined分布族，也即上文定义的$Q_{ABXY}^C$。Bell实验可以表示为<strong>nonlocal game</strong>。</p>
<p><strong>从IP到MIP</strong>（上文PCP已详述）Babai证明了$NEXP\subseteq MIP$，进而有PCP定理。</p>
<p>一个nonlocal game有一个Verifier和两个Prover（这里也是Player），每次Verifier从$X\times Y$中选择一对问题$(x,y)$，然后分别发送给两个Prover，得到$a\in A$和$b\in B$两个答案，然后评价$V(a,b|x,y)\in \{0,1\}$。如果V=1，那么认为Prover获胜，否则他们失败。Verifier的问题分布$\pi$已知，V公开，Player可以有预先设定的策略。Player的两个策略函数$f_A:X\times \Omega\to A$，$f_B:Y\times\Omega\to B$，在经典意义下</p>
<script type="math/tex; mode=display">
\omega(G)=\sup_{f_A,f_B}\sum_{x,y}\pi(x.y)\sum_{a,b}V(a,b|x,y)\times\int_\Omega1_{f_A(x,\omega)=a}1_{f_B(y,\omega)=b}d\omega</script><p>Spatial value</p>
<script type="math/tex; mode=display">
\omega^S(G)=\sup_{A^x,b^y}\sum_{x,y}\pi(x,y)\sum_{a,b}V(a,b|x,y)\times<\phi,(A_a^x\otimes B_b^y)\phi></script><p>Commuting value</p>
<script type="math/tex; mode=display">
\omega^C(G)=\sup_{A^x,b^y}\sum_{x,y}\pi(x,y)\sum_{a,b}V(a,b|x,y)\times<\phi,A_a^xB_b^y\phi></script><p>$\omega(G)\leq \omega^S(G)\leq\omega^C(G)$，上文Tsirelson问题等价于$\omega^S(G)=\omega^C(G)$</p>
<p>我们首先证明$\omega(G)&lt;\omega^S(G)$，以Magic Square(MS)为例，游戏规则如下</p>
<p><img src="ms.png" alt=""></p>
<p>可以得到classical value $\omega(MS)=17/18&lt;1$，而spatial value $\omega^S(MS)=1$</p>
<p>一系列复杂性理论提出了技术来抵抗Prover对entanglement的利用。现在我们知道任何证明系统都可以使得entanglement不再有用，并得出结论$NEXP=MIP\subseteq MIP^*$。前一半等号的证明由Babai等给出。Natarajan和Wright证明了MIP<em>严格大于NEXP，并且$NEEXP\subseteq MIP^\</em>$。</p>
<p>From below，$O(|X|log|A|+|Y|log|B|)$在多项式时间内，所以$MIP\subseteq NEXP$。在entanglement的情况下，对固定维数d，可以找到一连串有限网络$N_1\subseteq … \subseteq N_k\subseteq …$，$N_k$的大小为$k^{O(d^2)}$，那么对d维的任意策略，有$N_k$中的策略和其误差在$1/k$。令$\omega_{\leq n}^S$表示$d,k\leq n$时$N_k$在d维下的最高准确率。那么$\{\omega_{\leq n}^S\}$是个有界非减数列，并收敛到Spatial Value $\omega^S(G)$。这里Commuting value并没有有限维逼近。</p>
<p>From above，有一种”dual approach”，最简单的方法就是用一个系数$\alpha_{abxy}$代替$&lt;\phi,A_a^xB_b^y\phi&gt;$，然后考虑其最大值，当然这回极大的高估，所以可以通过引入限制来修正，比如对任意x,y，系数对a,b求和为1，又如增加层次性限制，引入了形如$&lt;\phi,(A_{a_1}^{x_1}B_{b_1}^{y_1}A_{a_2}^{x_2}…B_{b_k}^{y_k})\phi&gt;$，然后考虑在所有乘积长度小于等于n的约束下的最大值，得到非降数列$\{\omega_{\leq n}^C\}$，它收敛到$\omega^C(G)$。</p>
<p>如果$\bar{Q^S}=Q^C$，现在考虑MIP<em>中的问题L，这意味着有方法可以将问题的实例转换为$G=\{\pi(x,y)V(a,b|x,y)\}$，如果是正例，$\omega^S(G)$接近1，否则会小很多。执行G的算法，可以发现任何L的成员可以被可停机的算法决定，这就是说明$MIP\</em>$是<strong>decidable</strong>。Slofstra证明了如果没有2/3-1/3 promise，那么$\omega^S(G)=1$是<strong>undecidable</strong>，这样就没有<strong>finite gap $\delta$</strong>使得下界达到$1-\delta$。</p>
<p><strong>2020年1月已经证明了$MIP^*=RE$</strong></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/17/design-pattern/</url>
    <content><![CDATA[<p>两种手段</p>
<ul>
<li>抽象</li>
<li>分解</li>
</ul>
<p>八大原则</p>
<ul>
<li>依赖倒置原则（DIP）</li>
<li>开放封闭原则（OCP）</li>
<li>单一职责原则（SRP）</li>
<li>Liskov替换原则（LSP）</li>
<li>接口隔离原则（ISP）</li>
<li>对象组合优于类继承</li>
<li>封装变化点</li>
<li>面向接口编程</li>
</ul>
<a id="more"></a>
<p>五个重构技巧</p>
<ul>
<li>静态改为动态</li>
<li>早绑定改为晚绑定</li>
<li>继承改为组合</li>
<li>编译时依赖改为运行时依赖</li>
<li>紧耦合改为松耦合</li>
</ul>
<p>二十三个模式分类<em>（斜体为不常用）</em></p>
<ul>
<li>组件协作<ul>
<li>模板（Template Method）</li>
<li>策略（Strategy）</li>
<li>观察者（Observer）</li>
</ul>
</li>
<li>单一职责<ul>
<li>装饰器（Decorator）</li>
<li>桥（Bridge）</li>
</ul>
</li>
<li>对象创建<ul>
<li>工厂模式（Factory Method）</li>
<li>抽象工厂（Abstract Factory）</li>
<li>原型（Prototype）</li>
<li><em>构建器（Builder）</em></li>
</ul>
</li>
<li>对象性能<ul>
<li>Singleton</li>
<li>Flyweight</li>
</ul>
</li>
<li>接口隔离<ul>
<li>门面（Facade）</li>
<li>代理（Proxy）</li>
<li><em>中介模式（Mediator）：中介对象的具体实现过于复杂</em></li>
<li>转换器（Adapter）</li>
</ul>
</li>
<li>状态变化<ul>
<li><em>备忘录（Memento）：被序列化所替代</em></li>
<li>状态模式（State）</li>
</ul>
</li>
<li>数据结构<ul>
<li>组合器（Composite）</li>
<li><em>迭代器（Iterator）：编译时多态</em></li>
<li><em>职责链（Chain of Responsibility）</em></li>
</ul>
</li>
<li>行为变化<ul>
<li><em>命令模式（Command）：Function Object</em></li>
<li><em>访问者（Visitor）：前提苛刻</em></li>
</ul>
</li>
<li>领域问题<ul>
<li><em>编译器（Interpreter）</em></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据分析中的算法</title>
    <url>/2020/03/12/algorithms-for-big-data-analysis/</url>
    <content><![CDATA[<p>优化算法四种基本方法</p>
<ul>
<li>Taylor展开</li>
<li>考虑对偶</li>
<li>split（拆分问题，比如换元法）</li>
<li>交替极小（BCD）</li>
</ul>
<h1 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h1><p>强对偶/KKT条件</p>
<p>单纯形法</p>
<p>内点法</p>
<h1 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h1><p>稀疏表示问题：</p>
<script type="math/tex; mode=display">
min\:||x||\\
s.t.\:Ax=b</script><p><u>L0范数是NP难问题，L1范数可以等价为线性规划</u></p>
<p>稀疏表示=好的压缩感知</p>
<p><strong>第一个基础结论：（感知稀疏信号）</strong></p>
<p><strong>x是s-稀疏的</strong>（s个非零元），通过m个随机感知，$b_k=<a_k, x>,\:k=1,2,…,m$，通过L1最小化重建</p>
<p>如果$m\geq slog(n)$就可以精确重建</p>
<p><strong>第二个基础结论：（非适应性感知可压缩的信号）</strong></p>
<p>$m\geq slog(n)$甚至$m\geq slog(n/s)$，就可以达到</p>
<script type="math/tex; mode=display">
||\hat{x}-x||_2\leq ||x-x_s||_2</script><p>其中$x_s$是s个最大的系数。</p>
<p><strong>第三个基础结论：（对比Lasso或Dantzig）</strong></p>
<p>令$\bar{s}=m/log(n/m)$</p>
<script type="math/tex; mode=display">
||\hat{x}-x||_2^2\leq\inf_{1\leq s\leq\bar{s}}||x-x_s||_2^2+log(n\frac{s\delta^2}{m})</script><a id="more"></a>
<p><strong>SPARK</strong></p>
<p>spark(A)定义为A最小的线性相关列个数，一般情况下，$spark(A)\neq rank(A)+1$</p>
<p>定理（Gorodnitsky&amp;Rao 1997）：如果$Ax=b$有一个解x满足$||X||_0\leq spark(A)/2$，那么x是最稀疏的解。（证明思路：$||x||_0+||y||_0\geq ||x-y||_0\geq spark(A)$）</p>
<p><strong>Coherence</strong></p>
<p>Coherence定义为A列向量间最大的正则内积（夹角大小）：$\mu(A)=max\frac{|a_k^Ta_j|}{||a_k||_2||a_j||_2}$</p>
<p>定理（Donoho&amp;Elad 2003）：$spark(A)\geq 1+\mu^{-1}(A)$</p>
<p>证明：$A$列正则化为$\bar{A}$，令$p=spark(A)$，$B=\bar{A}^T\bar{A}$的$p\times p$的主子式。所以B对角线为1，且$\sum_{j\neq i}|B_{ij}|\leq(p-1)\mu(A)$。如果$p<1+\mu^{-1}(A)$，那么$|B_{ii}|>\sum_{j\neq i}|B_{ij}|$，所以$B\succ 0$（Gershgorin circle theorem），$spark(A)&gt;p$矛盾。</p>
<p>推论：如果$Ax=b$有一个解x满足$||X||_0\leq (1+\mu^{-1}(A))/2$，那么x是<strong>唯一</strong>最稀疏的解。</p>
<p><strong>定理（Donoho&amp;Elad 2003）</strong>：如果A有正则化的列且$Ax=b$有一个解x满足$||X||_0\leq (1+\mu^{-1}(A))/2$，那么x是唯一最稀疏的解，<strong>在L0和L1条件下</strong>。</p>
<p>证明：由前面定理可知$x$是L0唯一解，设$S$为x张成的空间，设$y$为L1的解，令$h=y-x$，所以$Ah=0$且$||h||_1&lt;2||h_S||_1$（因为$||h_{S^C}||_1&lt;||h_S||_1$）。根据$A^TAh=0$和$||h||_1=\sum_{k\neq j}|h_k|+|h_j|$，得到</p>
<script type="math/tex; mode=display">
|h_j|\leq(1+\mu(A))^{-1}\mu(A)||h||_1</script><p>综合两式得到$|h_j|&lt;1$矛盾。</p>
<p><strong>null space相关性质</strong></p>
<p>引理：$0 &lt; p\leq 1$，如果$||(y-x)_{S^C}||_p>||(y-x)_S||_P$，那么$||x||_P&lt;||y||_p$。</p>
<p>定义：null space property（$NSP(k,\gamma)$），每个非零$h\in N(A)$满足$||h_S||_1&lt;\gamma||h_{S^C}||_1$对所有$|S|\leq k$。</p>
<p>定理（Donoho&amp;Huo 2001）L1范数问题可以唯一恢复k-sparse向量x从$b=Ax$当且仅当A满足 $NSP(k,1)$（证明：充分性S为x张成空间即可，必要性考虑等号成立条件$sgn(x_S)=-sgn(h_S)$。）</p>
<p>引理（Zhang 2008）：$||x||_1 &lt; ||y||_1$的一个充分条件是$||x||_0 &lt; \frac{1}{4}(\frac{||h||_1}{||h||_2})^2$</p>
<p>（证明：$||h_S||_1\leq\sqrt{|S|}||h_S||_2\leq\sqrt{||x||_0}||h||_2$，因而上不等式意味着$||h_{S^C}||_1 &gt; ||h_S||_1$。）</p>
<p>定理（Zhang 2008）L1范数问题可以唯一恢复x如果</p>
<script type="math/tex; mode=display">
||x||_0<min\{\frac{1}{4}(\frac{||h||_1}{||h||_2})^2,h\in N(A)\backslash\{0\}\}</script><p><strong>RIP(Restriceted Isometry constants)</strong></p>
<p>定义：对k，$\delta_k$是最小的标量对所有k-sparse的x满足</p>
<script type="math/tex; mode=display">
(1-\delta_k)||x||_2^2\leq ||Ax||_2^2\leq(1+\delta_k)||x||_2^2</script><p>想法：稀疏恢复=远离零空间，如果A有2s线性相关列则不能恢复</p>
<p>$\delta_{2k}$是是最小的标量对所有k-sparse的$x_1,x_2$满足</p>
<script type="math/tex; mode=display">
(1-\delta_{2k})||x_1-x_2||_2^2\leq ||Ax_1-Ax_2||_2^2\leq(1+\delta_{2k})||x_1-x_2||_2^2</script><p>那么如果有s-sparse的解x满足Ax=b</p>
<ul>
<li>如果$\delta_{2s}&lt;1$则L0最优解唯一</li>
<li>如果$\delta_{2s}&lt;0.414$，那么LP relaxtion的解唯一且相等</li>
<li>(Cai-Wang-Wu)$\delta_{2s}&lt;0.307$是充分的</li>
<li>(Cai-Zhang)$\delta_{2s}&lt;1/3$是L1重建的充要条件。</li>
</ul>
<p><strong>L1解的特征</strong></p>
<p>x是解等价于$||x+h||_1\geq ||x||_1$对任意属于A零空间的h</p>
<p>L1重建的充要条件为对所有属于零空间的h，</p>
<script type="math/tex; mode=display">
\sum_{i\in T}sgn(x_i)h_i\leq\sum_{i\in T^C}|h_i|</script><p><strong>KKT条件的性质</strong></p>
<script type="math/tex; mode=display">
L(x,\lambda)=f(x)+<\lambda,b-Ax></script><p>x是解当且仅当x可行，存在$\lambda$</p>
<script type="math/tex; mode=display">
\nabla f(x)-A^*\lambda=0</script><p>即$\nabla f(x)\perp null(A)$。当$f(x)$不可微时，可用<strong>次梯度</strong>同样成立。</p>
<p>推论：那么L1解x是最优的当且仅当存在$u=A^*\lambda$，满足</p>
<script type="math/tex; mode=display">
u_i=sgn(x_i),x_i\neq 0(i\in T)\\
|u_i|\leq 1,x_i=0(i\in T^C)</script><p>如果$|u_i|<1$且$A^T$列满秩则x唯一。（只需证零空间的h，$||x+h||_1 > ||x||_1$）</p>
<p>T=supp(x)且$A_T$列满秩，定义valid dual certificate u（作用是证明可以达到）</p>
<script type="math/tex; mode=display">
u:=A^*A_T(A_T^*A_T)^{-1}sgn(x_T)</script><p>则y是$A^*\lambda$的形式，且$u_i=sgn(x_i)$（$i\in T$）。对$i\in T^C$，$|u_i|&lt;1$的证明如下</p>
<p>定义常数$\theta_{S,S’}$满足对所有不相交的集合$T,T’$，$|T|\leq S$，$|T’|\leq S’$，满足</p>
<script type="math/tex; mode=display">
<A_{T}c,A_{T'}c'>\leq \theta_{S,S'}||c||||c'||</script><p>如果$S\geq 1$且$\delta_S+\theta_{S,S’}+\theta_{S,2S}&lt;1$，那么如果$|supp(x)|\leq S$，x唯一。</p>
<p>引理：令$S\geq 1$满足$\delta_S+\theta_{S,2S}&lt;1$，那么存在$\lambda$满足对所有$j\in T$，$\lambda^*A_j=sgn(x_j)$，且对所有$j\in T^C$</p>
<script type="math/tex; mode=display">
|u_j|=|\lambda^*A_j|\leq\frac{\theta_{S,S'}}{(1-\delta_S-\theta_{S,2S})\sqrt{S}}||sgn(x)||\leq 1</script><h1 id="压缩感知（算法）"><a href="#压缩感知（算法）" class="headerlink" title="压缩感知（算法）"></a>压缩感知（算法）</h1><p>L1正则的最小二乘问题</p>
<script type="math/tex; mode=display">
min\:\mu||x||_1+\frac{1}{2}||Ax-b||_2^2</script><h2 id="Proximal-Gradient-Method-ISTA-FPC"><a href="#Proximal-Gradient-Method-ISTA-FPC" class="headerlink" title="Proximal Gradient Method/ISTA/FPC"></a>Proximal Gradient Method/ISTA/FPC</h2><p><strong>Proximal Gradient Method</strong></p>
<script type="math/tex; mode=display">
x^{k+1}:=\arg\min\mu||x||_1+(\nabla f(x^k))^T(x-x^k)+\frac{1}{2r}||x-x^k||_2^2\\
=\arg\min\mu||x||_1+\frac{1}{2r}||x-(x^k-r\nabla f(x^k))||_2^2\\
=shrink(x^k-r\nabla f(x^k),\mu r)</script><p>定义$shrink(y,v)=sgn(y)max(|y|-v,0)$</p>
<p><strong>Proximal Gradient Method for General Problems</strong></p>
<script type="math/tex; mode=display">
\min F(x):=f(x)+r(x)</script><p>其中r(x)可以是不可微凸函数（甚至可以是离散的如L0范数），同样可以得到</p>
<script type="math/tex; mode=display">
x^{k+1}:=prox_{\gamma r}(x^k-r\nabla f(x^k))</script><p>其中代理算子</p>
<script type="math/tex; mode=display">
prox_r(y):=argmin\:r(x)+\frac{1}{2}||x-y||_2^2</script><p><u>Proximal Gradient也叫投影梯度法。</u></p>
<p>代理算子的性质：</p>
<script type="math/tex; mode=display">
x=prox_r(y)\Leftrightarrow y-x\in\partial r(x)</script><p>然后由Cauchy-Schwarz不等式得到</p>
<script type="math/tex; mode=display">
||prox_r(y)-prox_r(x)||_2\leq ||x-y||_2</script><p><strong>收敛性问题</strong></p>
<p>在一定假设下，$h(x)=x-\gamma\nabla f(x)$满足</p>
<script type="math/tex; mode=display">
||h(x)-h(x')||\leq||x-x'||</script><p><strong>线性搜索</strong></p>
<script type="math/tex; mode=display">
x^k(r^k)=shrink(x^k-r^k\nabla f^k,\mu r^k)</script><p>那么设定</p>
<script type="math/tex; mode=display">
x^{k+1}=x^k+\alpha^k(x^k(r^k)-x^k)=x^k+\alpha^k d^k</script><p>$r^k$的选择：Barzilai-Borwein法（$\min||rs-y||^2$）</p>
<script type="math/tex; mode=display">
s^{k-1}=x^k-x^{k-1},y^{k-1}=\nabla f^k-\nabla f^{k-1}\\
r^k=\frac{(s^{k-1})^Ts^{k-1}}{(s^{k-1})^Ty^{k-1}}or\frac{(s^{k-1})^Ty^{k-1}}{(y^{k-1})^Ty^{k-1}}</script><p>$r^k$需要通过truncation限制大小</p>
<p>$\alpha^k$的选择：Armijo-like线性搜索（能够达到超线性收敛速度）</p>
<p>（Armijo-Goldstein：$C^k=F(x^k)$）</p>
<script type="math/tex; mode=display">
F(x^k+\alpha^k d^k)\leq C^k+\sigma a^k\Delta^k</script><ul>
<li>FPC：$\Delta^k=(\nabla f^k)^Td^k</li>
<li>FPC_AS：$\Delta^k=(\nabla f^k)^Td^k+\mu||x^k(r^k)||_1-\mu||x^k||_1</li>
<li>non-monotone line search(Zhang and Hagar)：$C^k=(\eta Q^{k-1}C^{k-1}+F(x^k))/Q^k$，$Q^k=\eta Q^{k-1}+1$，$C^0=F(x^0)$，$Q^0=1$</li>
</ul>
<p><strong>三种名称</strong></p>
<ul>
<li>proximal gradient method</li>
<li>ISTA: iterative shrinkage thresholding algorithm</li>
<li>FPC: fixed-point continuation method</li>
</ul>
<p>如果$f(x)$满足Lipschitz连续条件$||\nabla f(x)-\nabla f(y)||_2\leq L||x-y||_2$，那么可以得到</p>
<script type="math/tex; mode=display">
p_L(y)=prox_{r, 1/L}(y-\frac{1}{L}\nabla f(y))</script><p><strong>复杂性分析</strong></p>
<script type="math/tex; mode=display">
F(x^k)-F(x^*)\leq \frac{L||x_0-x^*||_2^2}{2k}</script><p>(证明：引理$F(x)-F(pl(y))\geq \frac{L}{2}(||pl(y)-x||_2^2-||x-y||_2^2)$)</p>
<p><strong>FISTA: accelerated proximal gradient(APG)</strong></p>
<p><u>FISTA/APG的理论收敛性质较好，但实际中不如B-B算法</u></p>
<p>令$y^1=x_0$，$t^1=1$</p>
<script type="math/tex; mode=display">
x^k=pL(y^k)\\
t^{k+1}=\frac{1+\sqrt{1+4(t^{k})^2}}{2}\\
y^{k+1}=x^k+\frac{t^k-1}{t^{k+1}}(x^k-x^{k-1})</script><p>复杂性结果</p>
<script type="math/tex; mode=display">
F(x^k)-F(x^*)\leq \frac{2L||x_0-x^*||_2^2}{(k+1)^2}</script><p>证明：令$v_k=F(x^k)-F(x^*)$，$u_k=t^kx^k-(t^k-1)x^{k-1}-x^*$，那么</p>
<script type="math/tex; mode=display">
\frac{2}{L}(t_k^2v_k-t_{k+1}^2v_{k+1})\geq ||u_{k+1}||_2^2-||u_k||_2^2</script><p><strong>APG的几个变体</strong></p>
<p>Variant 1</p>
<p>$x_{-1}=x_0$，$\theta_{-1}=\theta_0=1$</p>
<script type="math/tex; mode=display">
y_k=x_k+\theta_k(\theta_{k-1}^{-1}-1)(x_k-x_{k-1})\\
x_{k+1}=\arg\min l(x,y_k)+\frac{L}{2}||x-y_k||_2^2\\
\theta_{k+1}=\frac{\sqrt{\theta_k^4+4\theta_k^2}-\theta_k^2}{2}</script><p>($\theta_k$其实相当于$t_k$的倒数)</p>
<p>Variant 2</p>
<p>用Bregman distance $D(x,y_k)$来代替$\frac 12||x-y_k||_2^2$，并且令$x_0=z_0=\theta_0=1$</p>
<script type="math/tex; mode=display">
y_k=(1-\theta_k)x_k+\theta_kz_k\\
z_{k+1}=\arg\min l(x,y_k)+\theta_kL D(x,z_k)\\
x_{k+1}=(1-\theta_k)x_k+\theta_kz_{k+1}\\
\theta_{k+1}=\frac{\sqrt{\theta_k^4+4\theta_k^2}-\theta_k^2}{2}</script><p>Variant 3</p>
<p>$x_0=z_0=\arg\min h(x)$，$\theta_0=1$</p>
<script type="math/tex; mode=display">
y_k=(1-\theta_k)x_k+\theta_kz_k\\
z_{k+1}=\arg\min \sum_{i=0}^k\frac{l(x,y_i)}{\theta_i}+Lh(x)\\
x_{k+1}=(1-\theta_k)x_k+\theta_kz_{k+1}\\
\theta_{k+1}=\frac{\sqrt{\theta_k^4+4\theta_k^2}-\theta_k^2}{2}</script><p>三个变体收敛性都是$\sim \frac{1}{k^2}LD(….)$</p>
<h2 id="增广拉格朗日框架"><a href="#增广拉格朗日框架" class="headerlink" title="增广拉格朗日框架"></a>增广拉格朗日框架</h2><script type="math/tex; mode=display">
\min||x||_1,s.t.Ax=b</script><p>对偶问题</p>
<script type="math/tex; mode=display">
\max b^T\lambda,s.t.||A^T\lambda||_\infty\leq 1</script><p>等价于</p>
<script type="math/tex; mode=display">
\max b^T\lambda,s.t.A^T\lambda=s,||s||_\infty\leq 1</script><p>Augmented Lagrangian (Bregman) function</p>
<script type="math/tex; mode=display">
L(\lambda,s,x)=-b^T\lambda+x^T(A^T\lambda-s)+\frac{1}{2\mu}||A^T\lambda-s||^2</script><p>算法框架</p>
<ol>
<li><p>第k次迭代计算$\lambda^{k+1},s^{k+1}$</p>
<script type="math/tex; mode=display">
\min_{\lambda,s}L(\lambda,s,x^k),s.t.||s||_\infty\leq 1</script></li>
<li><p>更新(计算导数易得)</p>
<script type="math/tex; mode=display">
x^{k+1}=x^k+(A^T\lambda^{k+1}-s^{k+1})/\mu</script></li>
</ol>
<p><u>缺点是求min太慢</u></p>
<p> ADMM（An alternating direction minimization scheme）</p>
<script type="math/tex; mode=display">
\lambda^{k+1}=\arg\min_\lambda L(\lambda,s^k,x^k)\\
s^{k+1}=\arg\min_s L(\lambda^{k+1},s,x^k),s.t.||s||_\infty\leq 1\\
x^{k+1}=x^k+(A^T\lambda^{k+1}-s^{k+1})/\mu</script><p><u>在x更新步乘以步长1.618性能提升30%左右</u></p>
<p>Bregman method（实际与Augmented Lagrangian等价，但是计算更复杂）</p>
<script type="math/tex; mode=display">
D_J^{p^k}(x,x^k)=||x||_1-||x^k||_1-<p^k,x-x^k>\\
x^{k+1}=\arg\min_x\mu D_j^{p^k}(x,x^k)+\frac12 ||Ax-b||_2^2\\
p^{k+1}=p^k+\frac1\mu A^T(b-Ax^{k+1})</script><p><strong>Linearized ADMM</strong></p>
<p>Review of Bregman method</p>
<script type="math/tex; mode=display">
\min ||x||_1,s.t.Ax=b</script><p>Bregman method:</p>
<script type="math/tex; mode=display">
D_J^{n^k}(x,x^k)=||x||_1-||x^k||_1-<p^k,x-x^k>\\x^{k+1}=\arg\min_x\mu D_J^{n^k}(x,x^k)+\frac12||Ax-b||_2^2\\p^{k+1}=p^k+\frac1\mu A^T(b-Ax^{k+1})</script><p>（等价于</p>
<script type="math/tex; mode=display">
\min\mu\{||x||_1-<p^k,x-x^k>\}+\frac12||Ax-b||_2^2\\0\in\mu \partial||x||_1-\mu p^k+A^T(Ax^{k+1}-b)\\p^{k+1}=p^k+\frac1\mu A^T(b-Ax^{k+1})</script><p>Linearized Bregman method</p>
<script type="math/tex; mode=display">
x^{k+1}=\arg\min\mu D_L^{p^k}(x,x^k)+(A^T(Ax^k-b))^T(x-x^k)+
frac1{2\delta}||x-x^k||_2^2\\
p^{k+1}=p^k-\frac1{\mu\delta}(x^{k+1}-x^k)-\frac1\mu A^T(Ax^k-b)</script><p>实际上$x^k$逼近</p>
<script type="math/tex; mode=display">
\arg \min\mu||x||_1+\frac1{2\delta}||x||_2^2,s.t.Ax=b</script><h1 id="矩阵恢复"><a href="#矩阵恢复" class="headerlink" title="矩阵恢复"></a>矩阵恢复</h1><p>常见于推荐系统</p>
<p>起源：Netflix电影推荐竞赛</p>
<h2 id="Collaborative-Filtering（协同过滤）"><a href="#Collaborative-Filtering（协同过滤）" class="headerlink" title="Collaborative Filtering（协同过滤）"></a>Collaborative Filtering（协同过滤）</h2><script type="math/tex; mode=display">
\hat{r}_{si}=b_{si}+\sum_{j\in N(i:x)}w_{ij}(r_{xj}-b_{xj})</script><p>权重的确定：</p>
<script type="math/tex; mode=display">
\min_{w_{ij}}F(w):=\sum_x([b_{xi}+\sum_jw_{ij}(r_{xj}-b_{xj})]-r_{xi})^2</script><p>求导可得</p>
<script type="math/tex; mode=display">
\nabla_{w_{ij}}F(w)=2\sum_x([b_{xi}+\sum_jw_{ij}(r_{xj}-b_{xj})]-r_{xi})(r_{xj}-b_{xj})=0</script><p>梯度下降求解：GD、SGD</p>
<h2 id="Latent-factor-models"><a href="#Latent-factor-models" class="headerlink" title="Latent factor models"></a>Latent factor models</h2><p>“SVD” on Netflix data: </p>
<script type="math/tex; mode=display">
R\approx Q\cdot P^T</script><p>预测</p>
<script type="math/tex; mode=display">
\hat{r}_{si}=q_i\cdot p_s^T</script><p>考虑到下式有显式解（奇异值分解）</p>
<script type="math/tex; mode=display">
\min_{Q,P}||R-QP^T||_F^2</script><p>所以将原问题</p>
<script type="math/tex; mode=display">
\min\sum_{(i,j)\in\Omega}(R_{ij}-(QP^T)_{ij})^2</script><p>等价于</p>
<script type="math/tex; mode=display">
\min ||P_\Omega(R-QP^T)||_F^2,P_\Omega为投影算子</script><p>进行求解。</p>
<p>梯度下降方法：异步迭代QP（矩阵导数）</p>
<p>另外还有加上bias的latent factor model。</p>
<h2 id="General-Matrix-Completion"><a href="#General-Matrix-Completion" class="headerlink" title="General Matrix Completion"></a>General Matrix Completion</h2><script type="math/tex; mode=display">
\min rank(X)\\
s.t. X_{ij}=M_{ij},(i.j)\in\Omega</script><p><u>这是个NP-hard问题</u></p>
<p>引入奇异值分解</p>
<script type="math/tex; mode=display">
X=\sum\sigma_ku_kv_k^*</script><p>(Eckart&amp;Young 1936) if k&lt;rank(A):</p>
<script type="math/tex; mode=display">
\min_{rank(B)=k}||A-B||_2=||A-\sum_{i=1}^k\sigma_iu_iv_i^*||_2</script><h2 id="Positive-semidefinite-unknown"><a href="#Positive-semidefinite-unknown" class="headerlink" title="Positive semidefinite unknown"></a>Positive semidefinite unknown</h2><p>假设X半正定，那么可以转换为半定规划</p>
<script type="math/tex; mode=display">
\min trace(X)\\
s.t.X_{ij}=M_{ij},(i,j)\in\Omega\\
X\succeq 0</script><p>Nuclear norm和spectral norms是对偶的</p>
<script type="math/tex; mode=display">
||X||=\sigma_1(X),||X||_*=\sum\sigma_i(X)</script><p>核范数最小化</p>
<script type="math/tex; mode=display">
\left.\begin{align}\min||X||_*\\
s.t.A(X)=b\end{align}\right.
\Leftrightarrow
\left.\begin{aligned}
\max b^Ty\\
s.t.||A^T(y)||\leq 1
\end{aligned}\right.</script><p>SDP reformulation</p>
<script type="math/tex; mode=display">
\left.\begin{align}
\min\frac12(trace(W_1)+trace(W_2))\\
s.t.A(X)=b\\
\begin{pmatrix}W_1&X\\X^T&W_2\end{pmatrix}\succeq 0
\end{align}\right.
\Leftrightarrow
\left.\begin{aligned}
\max b^Ty\\
s.t.\begin{pmatrix}I&A^*(y)\\(A^*(y))^T&I\end{pmatrix}\succeq 0
\end{aligned}\right.</script><h2 id="Matrix-Shrink-Operator"><a href="#Matrix-Shrink-Operator" class="headerlink" title="Matrix Shrink Operator"></a>Matrix Shrink Operator</h2><script type="math/tex; mode=display">
\min v||X||_*+\frac12||X-Y||_F^2</script><p>Optimal solution</p>
<script type="math/tex; mode=display">
X=S_v(Y)=UDiag(s_v(\sigma))V^T</script><p>其中</p>
<script type="math/tex; mode=display">
Y=UDiag(\sigma)V^T\\
s_v(x)=\max(x_i-v,0)</script><p>可以证明这是non-expansive的。</p>
<p>计算量在SVD上。—&gt;LANSVD、LMSVD、Randomized SVD等方法</p>
<p><strong>low-rank factorization model</strong></p>
<script type="math/tex; mode=display">
\min_{X,Y,Z}\frac12||XY-Z||_F^2,s.t.Z_{ij}=M_{ij},\forall(i,j)\in\Omega</script><p>优点：不需要SVD</p>
<p>Nonlinear Gauss-Seidel scheme</p>
<script type="math/tex; mode=display">
X_+\leftarrow ZY^+\\
Y_+\leftarrow (X_+)^+Z\\
Z_+\leftarrow X_+Y_++P_\Omega(M-X_+Y_+)</script><p>这个算法需要计算广义逆，注意到</p>
<script type="math/tex; mode=display">
X_+Y_+=P_{X_+}Z=P_{ZY^T}Z</script><p>由此推出第二个版本：</p>
<script type="math/tex; mode=display">
X_+\leftarrow ZY^T\\
Y_+\leftarrow (X_+)^+Z\\
Z_+\leftarrow X_+Y_++P_\Omega(M-X_+Y_+)</script><p>这里还是有广义逆，又有$V=orth(ZY^T)$，因而</p>
<script type="math/tex; mode=display">
X_+\leftarrow V\\
Y_+\leftarrow V^TZ\\
Z_+\leftarrow X_+Y_++P_\Omega(M-X_+Y_+)</script><h2 id="矩阵分离"><a href="#矩阵分离" class="headerlink" title="矩阵分离"></a>矩阵分离</h2><p>M=W+E，其中W为低秩矩阵，E为系数矩阵</p>
<script type="math/tex; mode=display">
\min_{W,E}||W||_*+\mu||E||_1,s.t.W+E=M</script><p>Robust PCA</p>
<p>（应用：监控录像分离人和背景）</p>
<p>增广拉格朗日函数</p>
<script type="math/tex; mode=display">
L(W,E,A)=||W||_*+\mu||E||_1+<A,W+E-M>+\frac1{2\beta}||W+E-M||_F^2</script><p>ADMM:</p>
<script type="math/tex; mode=display">
W^{i+1}=\arg\min_WL(W,E^i,A^i)\\
E^{i+1}=\arg\min_EL(W^{i+1},E,A^i)\\
A^{i+1}=A^i+\frac\gamma\beta(W^{i+1}+E^{i+1}-M)</script><p>W-子问题：</p>
<script type="math/tex; mode=display">
W^{i+1}=S_\beta(M-E^j-\beta A^i)</script><p>其中$S_\beta$是将SVD的特征值shrink，见上文”Matrix Shrink Operator”</p>
<p>E-子问题：</p>
<script type="math/tex; mode=display">
E^{i+1}=S_{\beta\mu}(M-W^{i+1}-\beta A^i)</script><p>其中$S_{\beta\mu}$是L1 shrink，见上文“Proximal Gradient Method”</p>
<p><strong>low-rank factorization model for matrix seperation</strong></p>
<p>考虑模型</p>
<script type="math/tex; mode=display">
\min_{Z,S}||S||_1,s.t.Z+S=D,rank(Z)\leq k</script><p>对Z进行低秩分解</p>
<script type="math/tex; mode=display">
\min_{U,V,Z}||P_\Omega(Z-D)||_1,s.t.UV-Z=0</script><p>这里的增广拉格朗日函数为</p>
<script type="math/tex; mode=display">
L_\beta(U,V,Z,A)=||P_\Omega(Z-D)||_1+<A,UV-Z>+\frac\beta2||UV-Z||_F^2</script><p>ADMM依次优化U、V、Z、A。</p>
<p><strong>非负矩阵低秩分解</strong></p>
<p>基本相似，更加复杂</p>
<p>ADMM</p>
<h1 id="运输优化"><a href="#运输优化" class="headerlink" title="运输优化"></a>运输优化</h1><p>Application：image color adaption、shape interpolation、word mover’s distance</p>
<h2 id="Kantorovitch’s-Formulation"><a href="#Kantorovitch’s-Formulation" class="headerlink" title="Kantorovitch’s Formulation"></a>Kantorovitch’s Formulation</h2><p>输入两个离散概率度量</p>
<script type="math/tex; mode=display">
\alpha=\sum_{i=1}^ma_i\delta_{x_i},\:\beta=\sum_{j=1}^nb_j\delta_{y_j}</script><p>其中$X=\{x_i\}_i,\:Y=\{y_j\}_j$是给定的<strong>点云</strong>，$x_i,y_j$是向量。</p>
<p>$a_i,\:b_j$是<strong>正权重</strong>，满足$\sum_{i=1}^ma_i=\sum_{j=1}^nb_j=1$</p>
<p>$C_{ij}$是<strong>花费</strong>，$C_{ij}=c(x_i,y_j)\geq 0$</p>
<p>定义<strong>Couplings</strong></p>
<script type="math/tex; mode=display">
U(a,b)=\{\Pi\in R_+^{m\times n}|\Pi 1_n=a,\Pi^T1_m=b\}</script><p>Transportation 问题</p>
<script type="math/tex; mode=display">
\min \sum P_{ij}C_{ij}\\
s.t. P\in U(a,b)</script><p>推广：<strong>Radon 度量</strong>$(\alpha,\beta)$ on $(X,Y)$</p>
<p>Transfer of measure by $T:X\to Y$</p>
<p>定义Y上的度量</p>
<script type="math/tex; mode=display">
T_\#\alpha(Y)=\alpha(T^{-1}(Y))\:\forall Y\:measurable</script><p>离散情形下</p>
<script type="math/tex; mode=display">
T_\#\alpha=\sum_i\alpha_i\delta_{T(x_i)}</script><p>连续情形下</p>
<script type="math/tex; mode=display">
d\alpha=\rho(x)dx,\:d\beta=e(x)dx\\
T_\#\alpha=\beta\Leftrightarrow \rho(T(x))|det(\partial T(x))|=e(x)</script><h2 id="Monge-Problem"><a href="#Monge-Problem" class="headerlink" title="Monge Problem"></a>Monge Problem</h2><p>找到这样的T，使得</p>
<script type="math/tex; mode=display">
b_j=\sum_{i:\:T(x_i)=y_j}a_i</script><p>离散情形下</p>
<script type="math/tex; mode=display">
\min_T\sum_ic(x_i,T(x_i))\:s.t.T_\#\alpha=\beta</script><p>连续情形下</p>
<script type="math/tex; mode=display">
\min_T\int_Xc(x,T(x))d\alpha(x)\:s.t.T_\#\alpha=\beta</script><h2 id="Wasserstein-Distance"><a href="#Wasserstein-Distance" class="headerlink" title="Wasserstein Distance"></a>Wasserstein Distance</h2><p>Kantorovitch Problem for General Measures</p>
<script type="math/tex; mode=display">
L(\alpha,\beta,c)=\min_{\pi\in U(\alpha,\beta)}\int_{X\times Y}c(x,y)d\pi(x,y)</script><p>花费满足$c(x,y)=d(x,y)^p$，定义W-distance</p>
<script type="math/tex; mode=display">
W_p(\alpha,\beta)=L(\alpha,\beta,d^p)^{1/p}</script><p>可以证明这是个距离，且</p>
<script type="math/tex; mode=display">
W_p(\alpha_n,\alpha)\to 0\Leftrightarrow \alpha_n\to^{weak}\alpha</script><p><strong>Wasserstein barycenter</strong></p>
<p>定义$C=M_{XY}$，那么W-距离等于</p>
<script type="math/tex; mode=display">
L(a,b,C)=\min\{\sum C_{ij}\Pi_{ij}|\Pi\in U(a,b)\}</script><p>给定Y，b，找到X，a使得</p>
<script type="math/tex; mode=display">
\min_{X,a}\frac1N\sum_{i=1}^NL(a,b^{k},M_{XY})</script><h2 id="Dual-form"><a href="#Dual-form" class="headerlink" title="Dual form"></a>Dual form</h2><script type="math/tex; mode=display">
\max f^Ta+g^Tb\\
s.t. f_i+g_j\leq C_{ij}</script><h2 id="Entropy-regularization"><a href="#Entropy-regularization" class="headerlink" title="Entropy regularization"></a>Entropy regularization</h2><p>定义</p>
<script type="math/tex; mode=display">
H(P)=-\sum_{i,j}P_{i,j}(log(P_{i,j})-1)</script><p>定义Lullback-Leibler divergence</p>
<script type="math/tex; mode=display">
KL(u||v)=-\sum_{i=1}^nu_ilog(v_i/u_i)</script><p>定义Entropy regularization问题</p>
<script type="math/tex; mode=display">
L^e(a,b,C)=\min_{P\in U(a,b)}(P,C)-eH(P)</script><p>可以证明这个问题当$e&gt;0$时解唯一。 </p>
<p>解法：考虑Lagrangian对偶，令关于P导数为0</p>
<script type="math/tex; mode=display">
P_{ij}=exp(-\frac{C_{ij}+a_i+\beta_j}{e})</script><p>因此可以解得</p>
<script type="math/tex; mode=display">
P_e=diag(e^{-\alpha/2})e^{-C/2}diag(e^{-\beta/2})</script><p>根据KKT条件，令$u=e^{-\alpha/2}$，$v=e^{-\beta/2}$，$K=e^{-C/2}$，那么</p>
<script type="math/tex; mode=display">
P_e=diag(u)Kdiag(v)\\
a=diag(u)Kv\\
b=diag(v)K^Tu</script><p>Sinkhorn算法就是交替优化uv</p>
<script type="math/tex; mode=display">
u^{k+1}=diag(Kv^k)^{-1}a\\
v^{k+1}=diag(K^Tu^{k+1})^{-1}b</script><p> Sinkhorn-Newton 法：令</p>
<script type="math/tex; mode=display">
F(\alpha,\beta)=\begin{pmatrix}diag(e^{-\alpha/e})Ke^{-\beta/2}-a\\
diag(e^{-\beta/e})Ke^{-\alpha/2}-b\end{pmatrix}</script><p>即找到$F(\alpha,\beta)=0$的解。由此Newton Iteration为</p>
<script type="math/tex; mode=display">
\begin{pmatrix}\alpha^{k+1}\\\beta^{k+1}\end{pmatrix}=
\begin{pmatrix}\alpha^k\\\beta^k\end{pmatrix}-J_F^{-1}(\alpha^k,\beta^k)F(\alpha^k,\beta^k)</script><p><u>Sinkhorn算法是忽略非对角元素的近似Sinkhorn-Newton算法</u></p>
<p>定义</p>
<script type="math/tex; mode=display">
U_\alpha(a,b)=\{P\in U(a,b)|KL(P||ab^T)\leq\alpha\}</script><p>定义<strong>Sinkhorn Distance</strong>如下</p>
<script type="math/tex; mode=display">
d_{C,\alpha}(a,b)=\min_{P\in U_\alpha(a,b)}(C,P)</script><p>这是一个距离。</p>
<h2 id="Shielding-Neighborhood-Method"><a href="#Shielding-Neighborhood-Method" class="headerlink" title="Shielding Neighborhood Method"></a>Shielding Neighborhood Method</h2><p>Proposed by Bernhard Schmitzer in 2016</p>
<p>把主问题分解为多个稀疏子问题</p>
<p>对$N\subset X\times Y$，（称N为Neighborhood），</p>
<p>如果</p>
<script type="math/tex; mode=display">
c(x_1,y_n)\geq c(x_1,y_2)+\sum_{i=2}^{n-1}(c(x_i,y_{i+1})-c(x_i,y_i))</script><p>则称为<strong>short-cut</strong></p>
<p>定义：<strong>shielding condition</strong>是指这样的$(x_s,y_s)$使得</p>
<script type="math/tex; mode=display">
c(x,y)+c(x_s,y_s)>c(x,y_s)+c(x_s,y)</script><p>定义：<strong>shielding neighborhood</strong>是指对给定的$\pi$，满足下列条件的N：任意$(x,y)\notin N$，存在$(x_s,y_s)\in\pi$，$x_s,y_s$ shield x,y。</p>
<p>定义：<strong>multiscale scheme</strong>是把集合X分为层级结构，$X_0=\{\{x\}|x\in X\}$，之后每层是从前一层合并而来。</p>
<p>我们假设有两个子算法：</p>
<ul>
<li>solveLocal</li>
<li>shield</li>
</ul>
<p>主算法(从粗网格到细网格)</p>
<ol>
<li>$\pi=solveDense(k)$</li>
<li>while k&gt;0 do</li>
<li>​    k-=1</li>
<li>​    N={}</li>
<li>​    对 $(x,y)\in\pi$，$N=N\cup(children(x)\times children(y))$</li>
<li>​    $\pi=solveSparse(k, N)$</li>
<li>return </li>
</ol>
<p>SolveSparse算法：利用当前等级k和可行邻居N来计算$\pi$</p>
<ol>
<li>i=1</li>
<li>while i=1 or $C(\pi_i)\neq C(\pi_{i-1})$ do</li>
<li>​    $\pi_{i+1}=solveLocal(N)$</li>
<li>​    $N_{i+1}=shield(\pi_{i+1},k)$</li>
<li>​    i+=1</li>
<li>return</li>
</ol>
<h1 id="Large-scale-ML"><a href="#Large-scale-ML" class="headerlink" title="Large-scale ML"></a>Large-scale ML</h1><script type="math/tex; mode=display">
(x,y)\sim P</script><p>给定一个数据集$D=\{(x,y)\},\:(x,y)\sim P$，找到</p>
<script type="math/tex; mode=display">
\min R[h_s]:=E[l(h_s(x),y)]</script><p>Empirical Risk Minimizor(ERM) —— Expected Risk Minimizor</p>
<p>对任意小的$\epsilon,\delta$，当n足够大的时候，有</p>
<script type="math/tex; mode=display">
P(|R[h_n]-R[h]|\geq\epsilon)<\delta</script><p>Hoeffding不等式：$X_i$是i.i.d.随机变量，且$E(X_i)=\mu$且$P(a\leq X_i\leq b)=1$，那么对任意$\epsilon&gt;0$</p>
<script type="math/tex; mode=display">
P(|\frac1n\sum_{i=1}^nX_i-\mu|\geq\epsilon)\leq2exp(-\frac{2n\epsilon^2}{(b-a)^2})</script><p>假设对于固定的h，根据Hoeffding不等式</p>
<script type="math/tex; mode=display">
P(|R_n[h]-R[h]|\geq\epsilon)\leq2e^{-2n\epsilon^2}</script><p>得到上界</p>
<script type="math/tex; mode=display">
P(\cup_{h\in H}\{|R_n[h]-R[h]|\geq\epsilon\})\leq2|H|e^{-2n\epsilon^2}</script><p>因此需要样本数量</p>
<script type="math/tex; mode=display">
n\geq\frac1{2\epsilon^2}log(2|H|/\delta)</script><h2 id="VC-dimension"><a href="#VC-dimension" class="headerlink" title="VC dimension"></a>VC dimension</h2><p>VC dimension是集合的集合</p>
<script type="math/tex; mode=display">
H\cap C:=\{h\cap C|h\in H\}</script><p>定义C被H <strong>shattered</strong>，如果$H\cap C=2^C$</p>
<p>H的VC dimension定义为最大的整数D，使得存在|C|=D被H shattered。</p>
<p>一个模型$f$的VC dimension定义为最大的点数可以被$f$ shattered。</p>
<p>根据VC dimension，可以控制泛化误差</p>
<script type="math/tex; mode=display">
\sup_{h\in H}|R_n[h]-R[h]|\leq O(\sqrt{\frac{VC[H]log(n/VC[H])+log(1/\delta)}{n}})</script><h2 id="次梯度方法"><a href="#次梯度方法" class="headerlink" title="次梯度方法"></a>次梯度方法</h2><p><strong>次梯度方法</strong></p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\alpha_kg_k,g_k\in \partial f(x_k)</script><p>定理1（次梯度的收敛性）：假设存在最小点，且次梯度有界M。那么</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\alpha_k[f(x_k)-f(x^*)]\leq \frac12||x_1-x^*||_2^2+\frac12\sum_{k=1}^K\alpha_k^2M^2</script><p>推论：令$A=\sum_{i=1}^k\alpha_i$，$\bar{x_K}=\frac{1}{A_K}\sum_{k=1}^K\alpha_kx_k$，那么</p>
<script type="math/tex; mode=display">
f(\bar{x_K})-f(x^*)\leq\frac{||x_1-x^*||_2^2+\sum \alpha_k^2M^2}{2\sum\alpha_k}</script><p><strong>投影次梯度方法</strong></p>
<script type="math/tex; mode=display">
x_{k+1}=\pi_C(x_k-\alpha_kg_k),g_k\in \partial f(x_k)</script><p>定理2（投影次梯度的收敛性）：假设$||x-x^*||_2\leq R&lt;\infty$，且次梯度有界M，那么</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\alpha_k[f(x_k)-f(x^*)]\leq \frac12||x_1-x^*||_2^2+\frac12\sum_{k=1}^K\alpha_k^2M^2</script><p><strong>随机次梯度方法</strong></p>
<p>问题</p>
<script type="math/tex; mode=display">
\min_{x\in C}f(x):=E_P[F(x;S)]</script><p>S是random space。</p>
<script type="math/tex; mode=display">
x_{k+1}=\pi_C(x_k-\alpha_kg_k),E[g_k|x_k]\in\partial f(x_k)</script><p>定理3（随机次梯度法的收敛性）：假设$||x-x^*||_2\leq R&lt;\infty$，且$E||g(x,S)||_2^2\leq M^2\leq\infty$，那么</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\alpha_kE[f(x_k)-f(x^*)]\leq \frac12E||x_1-x^*||_2^2+\frac12\sum_{k=1}^K\alpha_k^2M^2</script><p>推论：令$A=\sum_{i=1}^k\alpha_i$，$\bar{x_K}=\frac{1}{A_K}\sum_{k=1}^K\alpha_kx_k$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{X_K})-f(x^*)]\leq\frac{R^2+\sum \alpha_k^2M^2}{2\sum\alpha_k}</script><p>定理5（随机次梯度法的收敛性2）：$\alpha_k$不增，且定义$\bar{x_K}=\frac1K\sum x_k$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{X_K})-f(x^*)]\leq\frac{R^2}{2K\alpha_K}+\frac1{2K}\sum \alpha_k^2M^2</script><p>推论：令$\alpha_k=R/M\sqrt{k}$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{x_K})-f(x^*)]\leq \frac{3RM}{2\sqrt{K}}</script><p>定理6（随机次梯度法的收敛性3—依概率收敛）：在定理5的条件下，假定$||g||_2\leq M$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{X_K})-f(x^*)]\leq\frac{R^2}{2K\alpha_K}+\frac1{2K}\sum \alpha_k^2M^2+\frac{RM}{\sqrt{K}}\epsilon</script><p>至少以概率$1-e^{-\epsilon^2/2}$的概率成立。</p>
<p>（证明需要用到Azume-Hoeffding不等式）</p>
<p><strong>Adaptive stepsize</strong>—Variable metric methods</p>
<script type="math/tex; mode=display">
x_{k+1}=\arg\min_{x\in C}\{<g_k,x>+\frac12<x-x_k,H_k(x-x_k)>\}</script><ul>
<li>投影法：$H_k=\alpha_kI$ </li>
<li>Newton法：$H_k=\nabla^2f(x_k)$</li>
<li>AdaGrad：$H_k=\frac1\alpha diag(\sum g_{i.} g_i)^{1/2}$</li>
</ul>
<p>定理9（Variable metric method的收敛性）：$H_k&gt;0$为正定矩阵，$E[g_k|x_k]\in\partial f(x_k)$那么</p>
<script type="math/tex; mode=display">
E[\sum_{k=1}^K(f(x_k)-f(x^*))]\leq\frac12E[\sum_{k=2}^K(||x_k-x^*||_{H_k}^2-||x_k-x^*||_{H_{k-1}}^2)]+\frac12E[||x_1-x^*||_{H_1}^2+\sum_{k=1}^K||g_k||_{H_k^{-1}}^2]</script><p>(证明根据$||x_{k+1}-x^*||_{H_k}^2\leq||x_k-H_k^{-1}g_k-x^*||_{H_k}^2$)</p>
<p>推论（AdaGrad的收敛性）：在定理9的条件下，定义$R_\infty=\sup_{x\in C}||x-x^*||_\infty$，那么</p>
<script type="math/tex; mode=display">
E[\sum_{k=1}^K(f(x_k)-f(x^*))]\leq\frac1{2\alpha}R_\infty^2E[tr(M_K)]+\alpha E[tr(M_K)]</script><p>(证明利用$\sum_{k=1}^K\frac{a_k^2}{\sqrt{\sum^k a_i^2}}\leq 2\sqrt{\sum^K a_i^2}$)</p>
<p><u>总结：合适的步长策略可以提升收敛性。</u></p>
<h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>收敛性：假设f是L-光滑且$\mu$-强凸的</p>
<p>引理：</p>
<script type="math/tex; mode=display">
<\nabla f(x)-\nabla f(y),x-y>\geq \frac{L\mu}{L+\mu}||x-y||^2+\frac1{L+\mu}||\nabla f(x)-\nabla f(y)||^2</script><p>定理：梯度下降收敛速度：定义$\alpha_k=\frac2{L+\mu}$，$k=L/\mu$，$\Delta_k=||x_k-x^*||$，那么</p>
<script type="math/tex; mode=display">
f(x_{T+1})-f(x^*)\leq \frac{L\Delta_1^2}2exp(-\frac{4T}{k+1})</script><p>定理：随机梯度下降收敛速度：对于固定的步长$\alpha_k=\alpha&lt;\frac1{2\mu}$</p>
<script type="math/tex; mode=display">
E[f(x_{T+1})-f(x^*)]\leq\frac L2E[\Delta_{T+1}^2]\leq\frac L2[(1-2\alpha\mu)^T\Delta_1^2+\frac{\alpha M^2}{2\mu}]</script><p>定理：随机梯度下降收敛速度：对于$\alpha_k=\frac{\beta}{k+\gamma}$</p>
<script type="math/tex; mode=display">
E[f(x_T)-f(x^*)]\leq\frac L2E[\Delta_T^2]\leq\frac L2\frac{v}{\gamma+T}</script><h2 id="Variance-Reduction"><a href="#Variance-Reduction" class="headerlink" title="Variance Reduction"></a>Variance Reduction</h2><p>f(x)是L-光滑和$\mu$-强凸的</p>
<p>GD：</p>
<script type="math/tex; mode=display">
\Delta_{k+1}^2\leq(1-2\alpha\mu+\alpha^2L^2)\Delta_k^2</script><p>SGD:</p>
<script type="math/tex; mode=display">
E\Delta_{k+1}^2\leq (1-2\alpha\mu)E\Delta_k^2+\alpha^2E||\nabla f_{x_k}(x_k)||_2^2\\
\leq (1-2\alpha\mu+2\alpha^2L^2)E\Delta_k^2+2\alpha^2E||\nabla f_{x_k}(x_k)-\nabla f(x_k)||_2^2</script><p>GD和SGD相差在最后一项，因而要控制方差就要控制这一项</p>
<p><strong>SAG method</strong>（Le Roux，Schmidt， Bach，2012）</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\frac{\alpha_k}n\sum_{k=1}^ng_k^i=x_k-\alpha_k(\frac1n(\nabla f_{s_k}(x_k)-g_{k-1}^{s_k})+\frac1n\sum_{i=1}^ng_{k-1}^i)</script><p>其中$g_k^i=\nabla f_i(x_k)$如果$i=s_k$，否则$g_k^i=\nabla g_{k-1}^i$。$s_k$是1~n的随机分布。</p>
<p><strong>SAGA method</strong>（Defazio，Bach， Julien，2014）：SAG的无偏改进</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\alpha_k(\nabla f_{s_k}(x_k)-g_{k-1}^{s_k}+\frac1n\sum_{i=1}^ng_{k-1}^i)</script><p><strong>SVRG</strong>（Johnson，zhang，2013）</p>
<script type="math/tex; mode=display">
v_k=\nabla f_{s_k}(x_k)-\nabla f_{s_k}(y)+\nabla f(y)\\
x_{k+1}=x_k-\alpha_kv_k</script><p>相比SAG，隔断了$g_k$</p>
<p>定义condition number $k=L/\mu$</p>
<ul>
<li>SVRG：$E\sim log(1/e)$，复杂度$O((n+k)log(1/e))$</li>
<li>GD：$T\sim klog(1/e)$</li>
<li>SGD：$T\sim k/e$</li>
</ul>
<h2 id="DL-中的随机算法"><a href="#DL-中的随机算法" class="headerlink" title="DL 中的随机算法"></a>DL 中的随机算法</h2><script type="math/tex; mode=display">
\min_x\frac1n\sum_{i=1}^nf_i(x)</script><p>GD、SGD、SGD with momentum</p>
<p>Nesterov加速算法（外推算法）</p>
<p>Adagrad、Adadelta</p>
<h1 id="Randomized-Numerical-Linear-Algebra"><a href="#Randomized-Numerical-Linear-Algebra" class="headerlink" title="Randomized Numerical Linear Algebra"></a>Randomized Numerical Linear Algebra</h1><p>provably accurate algorithms for problems that are <strong>massive or computationally expensive</strong></p>
<h2 id="矩阵乘法近似"><a href="#矩阵乘法近似" class="headerlink" title="矩阵乘法近似"></a>矩阵乘法近似</h2><script type="math/tex; mode=display">
AB\approx CR</script><p>SVD分解取前k个特征值</p>
<p>CX分解：最小化A-CX，显然$X=C^-A$ </p>
<h2 id="sampling-rows-columns"><a href="#sampling-rows-columns" class="headerlink" title="sampling rows/columns"></a>sampling rows/columns</h2><script type="math/tex; mode=display">
AB=\sum_{i=1}^nA_iB_i</script><p>设定一系列概率$p_i$，$i=1,2,…,n$，总和为1。然后选取c列（下式左边需要正则化）</p>
<script type="math/tex; mode=display">
AB\approx\frac1c\sum_{j=1}^c\frac1{p_{i_j}}A_{i_j}B_{i_j}</script><p>有/无放回：i.i.d.更容易分析</p>
<p>概率选取</p>
<script type="math/tex; mode=display">
p_i=\frac{||A_i||_2||B_i||_2}{\sum_{j=1}^n||A_j||_2||B_j||_2}</script><p>include $A_j/(cp_j)^{1/2}$ as a column and $B_j/(cp_j)^{1/2}$ as a row，此时CR也可以表示为</p>
<script type="math/tex; mode=display">
CR=(AS)(S^TB)</script><p>如此得到F-范数的界限</p>
<script type="math/tex; mode=display">
E||AB-CR||_F\leq\frac1c||A||_F||B||_F</script><p>证明：</p>
<script type="math/tex; mode=display">
E[CR]=AB,\:Var[(CR)_{ij}]=\frac1c\sum_{k=1}^n\frac{A_{ik}^2B_{kj}^2}{p_k}-\frac1c(AB)_{ij}^2</script><p>因此</p>
<script type="math/tex; mode=display">
E||AB-CR||_F^2=\sum_{k=1}^n\frac{|A_k|^2|B_k|^2}{cp_k}-\frac1c||AB||_F^2\\
\leq\frac1c(\sum_{k=1}^n|A_k||B_k|)^2-\frac1c||AB||_F^2\\
\leq\frac1c||A||_F^2||B||_F^2</script><p>在$B=A^T$时，根据Chernoff/Bernstein不等式，当</p>
<script type="math/tex; mode=display">
c=\Omega(\frac{||A||_F^2}{e^2}ln(\frac{||A||_F^2}{e^2\sqrt{\delta}}))</script><p>此时下式成立的概率至少为$1-\delta$</p>
<script type="math/tex; mode=display">
E||AA^T-CC^T||_F\leq e</script><p><strong>Using a dense S</strong></p>
<ul>
<li>Reminiscent of random projections and the Johnson-Lindenstrauss transform</li>
<li>Bounds for the Frobenius norm are similar</li>
<li>need a sufficiently large value c</li>
</ul>
<h2 id="Approximate-SVD"><a href="#Approximate-SVD" class="headerlink" title="Approximate SVD"></a>Approximate SVD</h2><p>Linear Time SVD algorithm:</p>
<ol>
<li>input matrix A</li>
<li>for t = 1 to c，根据概率选择i，设定$C_t=A_i/\sqrt{cp_i}$</li>
<li>计算$C^TC$和它的SVD：$C^TC=\sum \sigma_t(C)^2y_ty_t^T$</li>
<li>计算$h_t=Cy_t/\sigma_t(C)$</li>
</ol>
<p><u>C的左特征向量很大概率近似A的左特征向量</u></p>
<p>之后可以得到近似的k-dominant SVD</p>
<p><strong>主要结论</strong></p>
<script type="math/tex; mode=display">
E[||A-H_kH_k^TA||_F^2]\leq||A-A_k||_F^2+\epsilon||A||_F^2</script><p>矩阵扰动定理（后者为Hoffman-Wielandt不等式）</p>
<script type="math/tex; mode=display">
max|\sigma_t(A+E)-\sigma_t(A)|\leq||E||_2\\
\sum_{k=1}^n(\sigma_k(A+E)-\sigma_k(A))^2\leq||E||_F^2</script><p>引理：</p>
<script type="math/tex; mode=display">
||A-H_kH_k^TA||_F^2\leq||A-A_k||_F^2+2\sqrt{k}||AA^T-CC^T||_F\\
||A-H_kH_k^TA||_2^2\leq||A-A_k||_2^2+2||AA^T-CC^T||_2</script><p>第一个引理由$||X||_F^2=Tr(X^TX)$和Cauchy-Schwartz不等式和Hoffman-Wielandt不等式得到。</p>
<p>根据引理和F-范数的界限得到主要结论</p>
<p><u>CX分解也有相应的方法/结论</u></p>
<p><u>Fewer sampling</u></p>
<h2 id="Random-Sampling-for-SVD"><a href="#Random-Sampling-for-SVD" class="headerlink" title="Random Sampling for SVD"></a>Random Sampling for SVD</h2><p>Range finding problem：找到Q，$A\approx QQ^TA$</p>
<p>input A，draw a random matrix X，Y=AX，</p>
<p>对Y做QR分解，Y=QR</p>
<p>对$Q^TAQ$做SVD分解得到$T^TDT$，那么QT是U的估计。</p>
<h2 id="Single-View-Algorithm-for-Matrix-Approximation"><a href="#Single-View-Algorithm-for-Matrix-Approximation" class="headerlink" title="Single View Algorithm for Matrix Approximation"></a>Single View Algorithm for Matrix Approximation</h2><p>低秩矩阵重建：</p>
<p>given A，given random matrices k列的$\Omega$, l行的$\Phi$，compute</p>
<script type="math/tex; mode=display">
Y=A\Omega,W=\Phi A</script><p>Y=QR，$X=(\Phi Q)^-W$，近似</p>
<script type="math/tex; mode=display">
\hat{A}=QX</script><p>如果k=2r+1,l=4r+2，那么</p>
<script type="math/tex; mode=display">
E||A-\hat{A}||_F\leq2\min_{rank(Z)\leq r}||A-Z||_F</script><p><u>应用到一些问题上避免了对原矩阵A的revisit</u></p>
<p>应用：低秩投影</p>
<p>投影到凸集C上：</p>
<script type="math/tex; mode=display">
\Pi_C(M)=\arg\min_{X\in C}||X-M||_F^2</script><p>Conjugate Symmetric Approximation：凸集$C=H^n=\{X=X^*\}$。此时$\Pi_{H^n}(M)=\frac12(M+M^*)$，所以对A=QX，$[Q,X^*]=U[T_1,T_2]$，那么得到投影</p>
<script type="math/tex; mode=display">
\hat{A_{sym}}=U(\frac12(T_1T_2^*+T_2T_1^*))U^*\triangleq USU^*</script><p>PSD近似：对于半正定矩阵A，特征值分解$S=VDV^*$，计算$\hat{A}_{sym}=(UV)D(UV)^*$，构造</p>
<script type="math/tex; mode=display">
\hat{A_+}=\Pi_{H_+^n}(\hat{A})=(UV)D_+(UV)^*</script><h1 id="相位恢复"><a href="#相位恢复" class="headerlink" title="相位恢复"></a>相位恢复</h1><script type="math/tex; mode=display">
|Ax|=b\in C^m</script><p>即为多元二次方程求根：NP难问题，非凸优化最值问题</p>
<p>应用：物理问题如Xray/天文观察，一般不能观测到辅角</p>
<h2 id="classical-phase-retrieval"><a href="#classical-phase-retrieval" class="headerlink" title="classical phase retrieval"></a>classical phase retrieval</h2><script type="math/tex; mode=display">
find\:x\in S\cap M\\
M:=\{x(r)||\hat{x}(\omega)|=b(\omega)\},\:\hat{x}(\omega)=Fourier(x(r))\\
S:=\{x(r)|x(r)=0\:for\:x\notin D\}</script><p><strong>Error Reduction</strong>：交替投影法</p>
<script type="math/tex; mode=display">
x^{k+1}=P_SP_M(x^k)</script><p>之后有五种变体</p>
<ul>
<li>Basic input-output (BIO)：$x^{k+1}=(P_SP_M+I-P_M)(x^k)$</li>
<li>Hybrid input-output (HIO)：$x^{k+1}=((1+\beta)P_SP_M+I-P_S-\beta P_M)(x^k)$</li>
<li>Hybrid projection reflection (HPR)：$x^{k+1}=((1+\beta)P_{S_+}P_M+I-P_{S_+}-\beta P_M)(x^k)$</li>
<li>Relaxed average alternating reflection (RAAR)：$x^{k+1}=(2\beta P_{S_+}P_M+\beta I-\beta P_{S_+}-(1-2\beta) P_M)(x^k)$</li>
<li>Difference Map(DF)：$x^{k+1}=(I+\beta(P_S((1-\gamma_2)P_M-\gamma_2 I)+P_M((1-\gamma_1)P_S-\gamma_1 I)))(x^k)$</li>
</ul>
<p><u>收敛性难以保证</u></p>
<p><strong>ADMM</strong></p>
<script type="math/tex; mode=display">
find\:x,y\:s.t.x=y,x\in X\:and\:y\in Y</script><p>增广拉格朗日函数</p>
<script type="math/tex; mode=display">
L(x,y,\lambda)=\lambda^T(x-y)+\frac12||x-y||^2</script><p>ADMM与HIO/HPR在一些假设下等价</p>
<h2 id="Discrete-model"><a href="#Discrete-model" class="headerlink" title="Discrete model"></a>Discrete model</h2><script type="math/tex; mode=display">
find\: x\\
s.t.\:|<a_k,x_0>|^2=b_k</script><p>一般情况下NP难</p>
<p><strong>PhaseLift</strong></p>
<p>令$X=xx^*$，那么$b_k=<a_ka_k^\*,X>$，</p>
<script type="math/tex; mode=display">
find\:X\\
s.t.A(X)=b,X\succeq0</script><p>（这里去掉了约束rank(X)=1）</p>
<p>如此回到半定规划问题</p>
<p>Theorem（C and Li 2012，C Strohmer and Voronisnski 2011）</p>
<p>如果$a_k$独立均匀地分布在单位圆上，且个数m&gt;n，那么至少概率为$1-O(e^{-\gamma m})$唯一可行解即是原来的x（即<em>精确恢复</em>）。</p>
<p><strong>PhaseCut</strong></p>
<p>变形为</p>
<script type="math/tex; mode=display">
\min_{x,u}\frac12||Ax-diag(b)u||_2^2=\min_u u^*(diag(b)(I-AA^*)diag(b))u</script><p>是MAXCUT问题</p>
<script type="math/tex; mode=display">
\min_U Tr(UM)</script><h2 id="Phase-retrieval-by-non-convex-optimization"><a href="#Phase-retrieval-by-non-convex-optimization" class="headerlink" title="Phase retrieval by non-convex optimization"></a>Phase retrieval by non-convex optimization</h2><script type="math/tex; mode=display">
\min_z f(z)=\frac1{4m}\sum_{k=1}^m(y_k-|<a_k,z>|^2)^2</script><p>复数求梯度：根据Wirtinger 梯度即$\frac{\partial}{\partial z}=\frac12(\frac{\partial}{\partial x}-i\frac{\partial}{\partial y})$</p>
<script type="math/tex; mode=display">
\nabla f(z)=\frac1m\sum_{k=1}^m(|<a_k,z>|^2-y_k)(a_ka_k^*)z</script><p><u>梯度下降法线性收敛速度要求强凸</u></p>
<p>定义距离</p>
<script type="math/tex; mode=display">
dist(z,x)=\min_\phi||z-e^{i\phi}x||</script><p>Convergence for Gaussian model：</p>
<p>假设sample $m&gt;nlog(n)$，step size $\mu&lt;c/n$</p>
<p>那么以至少$1-10e^{-\gamma n}-8/n^2-me^{-1.5n}$的概率$dist(z_0,x)\leq \frac18||x||$，在$\tau$步迭代之后</p>
<script type="math/tex; mode=display">
dist(z_\tau,x)\leq\frac18(1-\mu/4)^{\tau/2}||x||</script><p>引理1：假设f满足$RC((\alpha,\beta,\epsilon))$ for all $z\in E(\epsilon)$。进一步假设$z_0\in E(\epsilon)$，$0&lt;\mu\leq 2/\beta$，考虑更新</p>
<script type="math/tex; mode=display">
z_{\tau+1}=z_\tau-\mu\nabla f(z_\tau)</script><p>那么所有$z_\tau\in E(\epsilon)$，且</p>
<script type="math/tex; mode=display">
dist^2(z_\tau,x)\leq(1-\frac{2\mu}{\alpha})^\tau dist^2(z_0,x)</script><p>上面f的正则条件$RC((\alpha,\beta,\epsilon))$是说对任意$z\in E(\epsilon)$</p>
<script type="math/tex; mode=display">
Re(<\nabla f(z),z-xe^{i\phi(z)}>)\geq \frac1\alpha dist^2(z,x)+\frac1\beta||\nabla f(z)||^2</script><p>引理2：假设$||x||=1$，又假设$m\geq c(\delta)nlog(n)$ in Gaussian model 或 $L\geq c(\delta)log^3(n)$ in CD model</p>
<script type="math/tex; mode=display">
||\nabla^2f(x)-E\nabla^2f(x)||\leq \delta</script><p>以至少$1-10e^{-\gamma n}-8/n^2$或$1-(2L+1)/n^3$的概率成立。</p>
<p>（需要Local Curvature Condition或者Local smoothness condition）</p>
<p>原式的证明：</p>
<p>根据引理2：</p>
<script type="math/tex; mode=display">
||Y-(xx^*+||x||^2I)||\leq\epsilon=0.001</script><p>设Y的最大的特征值为$\lambda_0$</p>
<script type="math/tex; mode=display">
|\lambda_0-(|\bar{z_0}x|^2+1)|=|\bar{z_0}^*(Y-(xx^*+I))\bar{z_0}|\leq\epsilon</script><p>因此</p>
<script type="math/tex; mode=display">
|\bar{z_0}^*x|^2\geq\lambda_0-1-\epsilon</script><p>同时有</p>
<script type="math/tex; mode=display">
\lambda_0\geq x^*Yx=x^*(Y-(I+x^*x))x+2\geq2-\epsilon</script><p>所以</p>
<script type="math/tex; mode=display">
|\bar{z_0}^*x|^2\geq 1-2\epsilon\Rightarrow dist^2(\bar{z_0},x)\leq2-2\sqrt{1-2\epsilon}</script><h2 id="Gauss-Newton-Method"><a href="#Gauss-Newton-Method" class="headerlink" title="Gauss-Newton Method"></a>Gauss-Newton Method</h2><p>Nonlinear least square problem</p>
<script type="math/tex; mode=display">
\min_z f(z)=\frac1{4m}\sum_{k=1}^m(y_k-|<a_k,z>|^2)^2</script><p>根据Wirtinger导数</p>
<script type="math/tex; mode=display">
z:=\begin{pmatrix}z\\\bar{z}\end{pmatrix}\\
g(z):=\nabla_cf(z)=\frac1m\sum_{r=1}^m(|a_r^Tz|^2-y_r)\begin{pmatrix}(a_ra_r^T)z\\(\bar{a_r}a_r^T)\bar{z}\end{pmatrix}\\
J(z):=\frac1{\sqrt{m}}\begin{pmatrix}|a_1^*z|a_1&|a_2^*z|a_2&...&|a_m^*z|a_m\\|a_1^*z|\bar{a_1}&|a_2^*z|\bar{a_2}&...&|a_m^*z|\bar{a_m}\end{pmatrix}^T\\
\Phi(z):=J(z)^TJ(z)</script><p>modified LM method for Phase Retrieval：Levenberg-Marquardt Iteration</p>
<script type="math/tex; mode=display">
z_{k+1}=z_k-(\Phi(z_k)+\mu_kI)^{-1}g(z_k)</script><p>Convergence of the Gaussian Model：</p>
<p>假设$m\geq cnlog(n)$，如果$f(z_k)\geq\frac{||z_k||^2}{900n}$，$\mu_k=70000n\sqrt{nf(z_k)}$，否则$\mu_k=\sqrt{f(z_k)}$，那么很高的概率</p>
<script type="math/tex; mode=display">
dist(z_{k+1},x)\leq c_1dist(z_k,x)</script><p>当$f(z_s)&lt;\frac{||z_s||^2}{900n}$时</p>
<script type="math/tex; mode=display">
dist(z_{k+1},x)<c_2dist(z_k,x)^2</script><h2 id="Cryo-Electron-Microscopy"><a href="#Cryo-Electron-Microscopy" class="headerlink" title="Cryo-Electron Microscopy"></a>Cryo-Electron Microscopy</h2><p>冷冻光镜问题</p>
<p>傅里叶切片定理</p>
<p>Detection of Common Line of Two photos </p>
<p>—— Weighted Least Square Approach</p>
<script type="math/tex; mode=display">
\min_{R_1,R_2,...,R_K}\sum_{i\neq j}w_{ij}||R_i(c_{ij},0)^T-R_j(c_{ji},o)^T||^2\\
=\max_{R_1,R_2,...,R_K}\sum_{i\neq j}w_{ij}<R_i(c_{ij},0)^T,R_j(c_{ji},0)^T></script><p>半定规划（SDR）</p>
<script type="math/tex; mode=display">
\max trace((W\cdot S)G\\
G=R^TR,\:S_{ij}=c_{ji}^Tc_{ij},\:W_{ij}=w_{ij}\begin{pmatrix}1&1\\1&1\end{pmatrix}</script><p>即要求</p>
<script type="math/tex; mode=display">
G_{ii}=I_2,G\succeq 0</script><h1 id="数据降维"><a href="#数据降维" class="headerlink" title="数据降维"></a>数据降维</h1><p>SVD</p>
<script type="math/tex; mode=display">
A\approx U\Sigma V^T=\sum_i\sigma_iu_iv_i^T</script><p>Theorem </p>
<script type="math/tex; mode=display">
\min_{rank(B)=k}||A-B||_2=||A-A_k||_2=\sigma_{k+1}</script><p>复杂度：O(nm^2)或者O(n^2m)</p>
<p>但是如果我们只想要特征值/只想要k个特征向量/矩阵系数都可以减少计算量</p>
<p><strong>PCA（主成分分析）</strong></p>
<p>从X到Y，$y=z^Tx$，使得var(y)是最大的</p>
<script type="math/tex; mode=display">
\max z^Tcov(X)z,s.t.||z||_2=1</script><p>即找到cov(X)最大的特征值</p>
<p>如果是多个特征</p>
<script type="math/tex; mode=display">
\max Tr(M^Tcov(X)M),s.t.M^TM=I</script><p>令</p>
<script type="math/tex; mode=display">
\bar{X}=X-\frac1n11^TX=U\Sigma V^T</script><p>那么</p>
<script type="math/tex; mode=display">
cov(X)=V\Sigma^2V^T/(n-1)</script><p><strong>MDS（多维尺度分析）</strong></p>
<p>定义距离矩阵</p>
<script type="math/tex; mode=display">
D_2(X)=(d_{ij}^2(X))_{ij}</script><p>MDS就是找到Y</p>
<script type="math/tex; mode=display">
\min_Y ||HD_2(X)H-HD_2(Y)H||_F^2</script><p>Lemma：$H=I_n-\frac1n 11^T$，$\bar{X}=X-\frac1n11^TX$，那么</p>
<script type="math/tex; mode=display">
B=-\frac12HD_2(X)H=\bar{X}\bar{X}^T</script><p>引理的证明：</p>
<script type="math/tex; mode=display">
D_2(X)_{ij}=x_ix_i^T+x_jx_j^T-2x_ix_j^T</script><p>令$K=XX^T$，$w=diag(K)$，那么</p>
<script type="math/tex; mode=display">
D_2(X)=w1^T+1w^T-2K</script><p>根据引理可以看出：PCA和MDS是等价的，如下。</p>
<script type="math/tex; mode=display">
\min_Y||B-YY^T||_F^2</script><p>Extension of MDS：不同的距离度量，此时$K_{ij}=k(x_i,x_j)$</p>
<p><strong>MVU</strong></p>
<p>图G=(V,E)</p>
<script type="math/tex; mode=display">
\max\sum_{i,j}||y_i-y_j||^2\\
s.t.\sum_iy_i=0,||y_i-y_j||^2=||x_i-x_j||^2,\forall(i,j)\in E</script><p>这个问题非凸</p>
<p>定义$K=YY^T$，那么可以做半定规划松弛</p>
<script type="math/tex; mode=display">
\max Tr(K)\\
s.t.K\succeq 0,1^TK1=0\\
K_{ii}-2K_{ij}+K_{jj}=D_{ij},\forall(i,j)\in E</script><p><strong>Graph Realization and Sensor Network Localization Problems</strong></p>
<p>蛋白质折叠问题？</p>
<p>输入m个已知点$a_i$，n个未知点$x_j$，以及一些点对的距离，据此估计每个点的位置</p>
<p>定义$Y=X^TX$，半定规划松弛</p>
<script type="math/tex; mode=display">
(e_i-e_j)^TY(e_i-e_j)=d_{ij}^2\\
(a_k;-e_j)^T\begin{pmatrix}I&X\\X^T&Y\end{pmatrix}(a_k;-e_j)=d_{kj}^2</script><h1 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h1><p>Path、Directed Path、Cycle、Directed Cycle</p>
<p>（这四个No node is repeated）</p>
<p>Walks：Paths that can repeat nodes and arcs</p>
<p><strong>最短路径</strong></p>
<script type="math/tex; mode=display">
\min \sum c_{ij}x_{ij}\\
s.t.\sum_jx_{sj}=1,\sum_ix_{it}=1,\\
\sum_jx_{ij}=\sum_jx_{ji},\forall i\neq s,t\\
x_{ij}\geq 0</script><p>其对偶形式</p>
<script type="math/tex; mode=display">
\max d(t)-d(s)\\
s.t.d(j)-d(i)\leq c_{ij}</script><p><strong>最大流</strong></p>
<script type="math/tex; mode=display">
\max v\\
s.t.\sum x_{sj}=v,\sum x_{jt}=v,\\
\sum_jx_{ij}=\sum_jx_{ji},\forall i\neq s,t\\
x_{ij}\leq c_{ij}</script><p><strong>Max-Weight Bipartite Matching</strong></p>
<p>find a set of edges covering each node at most once</p>
<script type="math/tex; mode=display">
\max\sum w_{ij}x_{ij}\\
s.t.\sum_jx_{ij}\leq 1,i\in L\\
\sum_ix_{ij}\leq1,j\in R\\
x_{ij}\in[0,1]</script><p>LP relaxtion：最后一个条件放宽为$x_{ij}\geq 0$</p>
<p>对偶问题：顶点覆盖，找到最小集合S，使得每条边至少一端在S里</p>
<script type="math/tex; mode=display">
\min\sum_iy_i\\
s.t.y_i+y_j\geq w_{ij},\:(i,j)\in A\\
y_i\geq 0</script><p>定义：矩阵A Totally Unimodular如果每个正方形子矩阵特征值为0,1或-1</p>
<p>定理：A totoal unimodular，b是整数向量，Ax=b的解为整数</p>
<p>Claim: The constraint matrix of the bipartite matching LP is totally unimodular.</p>
<p><strong>Modularity Maximization for Coummunity Detection</strong></p>
<p>define partition matrix X，$X_{ij}=1$，如果i和j在同一个社群，否则为0</p>
<p>modularity (MEJ Newman, M Girvan, 2004) defined by</p>
<script type="math/tex; mode=display">
Q=<A-\frac{1}{2\lambda}dd^T,X>,\lambda=|E|</script><p>SDP 松弛后</p>
<script type="math/tex; mode=display">
\max<A-\frac1{2\lambda}dd^T,X>\\
s.t.X\succ0,0\leq X_{ij}\leq 1,X_{ii}=1</script><p>为了进一步简化，进行非凸松弛</p>
<script type="math/tex; mode=display">
\min<-A+\frac1{2\lambda}dd^T,UU^T>\\
s.t.||u_i||^2=1,||u_i||_0\leq p,U\geq0</script><p>算法：固定U其他行，最小化第i行</p>
<script type="math/tex; mode=display">
u_i=\arg\min f(u_1,u_2,...,x,...,u_n)+\frac\sigma2||x-\bar{u_i}||^2</script><h1 id="次模优化"><a href="#次模优化" class="headerlink" title="次模优化"></a>次模优化</h1><p>推荐系统：Relevance and Diversity</p>
<p>简单的抽象模型：用户集W，广告集V，对每个广告i，有用户集合$S_i$，定义</p>
<script type="math/tex; mode=display">
F(A)=|\bigcup_{i\in A}S_i|</script><p>优化问题选在k篇来最大化用户覆盖</p>
<script type="math/tex; mode=display">
\max_{|A|<k}F(A)</script><p>这是NP-hard问题</p>
<p><strong>定义</strong></p>
<p>模函数F，如果对任意A，B</p>
<script type="math/tex; mode=display">
F(A)+F(B)=F(A\cap B)+F(A\cup B)</script><p>模函数可以写成</p>
<script type="math/tex; mode=display">
F(A)=F(\emptyset)+\sum_{a\in A}(F(\{a\})-F(\emptyset))</script><p>显然模函数单调、非负</p>
<p>次模函数F，如果对任意A，B</p>
<script type="math/tex; mode=display">
F(A)+F(B)\geq F(A\cap B)+F(A\cup B)</script><p>（次模函数的另一种定义，边际效益递减）对任意$A\subseteq B$，$s\notin B$</p>
<script type="math/tex; mode=display">
F(B\cup\{s\})-F(B)\leq F(A\cup\{s\})-F(A)</script><p>性质：$F(A)=\sum_i\lambda_i F_i(A)$也是次模函数</p>
<p>性质：次模函数F限制在集合W上也是次模函数</p>
<p>性质：凹函数复合模函数是次模函数</p>
<p>定义 coverage function $cover_d(c)=p(d\:covers\:c)$，集合coverage function</p>
<script type="math/tex; mode=display">
cover_A(c)=1-\prod_{d\in A}(1-cover_d(c))</script><p>原式化作</p>
<script type="math/tex; mode=display">
\max_{|A|\leq k}F(A)=\sum_cw_ccover_A(c)</script><p><strong>回到原问题</strong></p>
<p>这是个次模最大值问题</p>
<p>定理：在一般条件下，贪心法的解</p>
<script type="math/tex; mode=display">
F(A)\geq(1-1/e)*optimal-value\approx63\%</script><p>引理：F单调+次模，那么$F_A(S)=F(A\cup S)-F(A)$是单调+次模</p>
<p>引理：如果F正则+次模，那么存在$j\in A$，$F(\{j\})\geq \frac{1}{|A|}F(A)$</p>
<p>证明：k词迭代之后，$F(A^*)-F(A_{k})$ shrink to $(1-1/k)^k&lt;(1-1/e)$</p>
<p>贪心法的改进：“Lazy” Greedy，保持ordered list，只重新计算top的更新</p>
<p><strong>次模最小化</strong></p>
<script type="math/tex; mode=display">
\min F(S)\\
s.t.S\subseteq X</script><p>多项式时间算法</p>
<p>Choquet integral - Lovasz Extention：将$\{0,1\}$上定义的函数拓展为$[0,1]$上的函数</p>
<p>Given any set-function F and w such that $w_{j_1}\geq …\geq w_{j_n}$</p>
<script type="math/tex; mode=display">
f(w)=\sum_{k=1}^{n}w_{j_k}[F(\{j_1,...,j_k\})-F(\{j_1,...,f_{k-1}\})]\\
=\sum_{k=1}^{n-1}(w_{j_k}-w_{j_{k+1}})F(\{j_1,...,j_k\})+w_{j_n}F(\{j_1,...,j_n\})</script><p>实际上</p>
<script type="math/tex; mode=display">
f(w)=\max_{s\in B(F)}w^ts</script><p>Theorem(Lovasz, 1982) F是次模函数当且仅当f是凸的</p>
<p>Theorem(Lovasz, 1982)</p>
<script type="math/tex; mode=display">
\min F(A)=\min_{w\in\{0,1\}^n} f(w)=\min_{w\in[0,1]^n}f(w)</script><p>第一个等号显然成立，第二个显然大于等于成立。</p>
<p>any $w\in [0,1]^n$可以被分解为$w=\sum_{i=1}^n\lambda_i1_{B_i}$，其中$B_1\subseteq B_2\subseteq … \subseteq B_n$，其中$\lambda\geq 0$，且$\lambda(V)\leq 1$</p>
<script type="math/tex; mode=display">
f(w)=\sum_{i=1}^n\lambda_iF(B_i)\geq\sum_{i=1}^n\lambda_i\min F(A)\geq \min F(A)</script><p>因而得证。</p>
<p>迭代过程：</p>
<script type="math/tex; mode=display">
w_t=\Pi_{[0,1]^n}(w_{t-1}-\frac C{\sqrt{t}}s_t)</script><p>可以证明</p>
<script type="math/tex; mode=display">
f(w_t)-\min f(w)\leq \frac C{\sqrt{t}}</script><h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><p>MRP（Markov Reward Process）</p>
<script type="math/tex; mode=display">
E[\sum_{t=1}^T\gamma^{t-1}r_t|s_t]</script><p><strong>Value Functions</strong></p>
<p>On-Policy Value Function</p>
<script type="math/tex; mode=display">
V^\pi(s)=\lim_{T\to\infty}E[\sum_{t=1}^T\gamma^{t-1}r_t|s_1=s]</script><p>On-Policy Action-Value Function</p>
<script type="math/tex; mode=display">
Q^\pi(s,a)=\lim_{T\to\infty}E[\sum_{t=1}^T\gamma^{t-1}r_t|s_1=s,a_1=a]</script><p>Optimal Value Function</p>
<script type="math/tex; mode=display">
V^*(s)=\max_\pi V^\pi(s)</script><p>Optimal Action-Value Fucntion</p>
<script type="math/tex; mode=display">
Q^*(s,a)=\max_\pi Q^\pi(s,a)</script><p><strong>Bellman Equations</strong></p>
<script type="math/tex; mode=display">
V^\pi(s)=E[R(s,a,s')+\gamma V^\pi(s')]\\
Q^\pi(s,a)=E[R(s,a,s')+\gamma E_{a'\sim\pi}[Q^\pi(s',a')]]</script><p>for optimal value functions：</p>
<script type="math/tex; mode=display">
V^*(s)=\max_{a}E[R(s,a)+\gamma V^*(s')]\\
Q^*(s,a)=E[R(s,a)+\gamma \max_{a'} E_{a'\sim\pi}[Q^*(s',a')]]</script><p><strong>Bellman方程的不动点</strong></p>
<p>可以通过LP来找到</p>
<script type="math/tex; mode=display">
\min_v \sum_s w_sv_s\\
s.t.\:v_s\geq R(s,a)+\gamma P(s,a)^Tv</script><p>其中的约束等价于</p>
<script type="math/tex; mode=display">
(I-\gamma P^{\pi^*})v\geq R^{\pi^*}</script><p>因此</p>
<script type="math/tex; mode=display">
v\geq (I-\gamma P^{\pi^*})^{-1}R^{\pi^*}=V^*</script><p>这就证明了这个问题与Bellman方程等价。</p>
<p><strong>Bellman算子</strong></p>
<script type="math/tex; mode=display">
LV(s)=\max_{a}R(s,a)+\gamma \sum_{s'}P(s,a,s')V(s')\\
L^\pi V(s)=E_\pi[R(s,a)+\gamma \sum_{s'}P(s,a,s') V(s')]</script><p>所以对任意policy</p>
<script type="math/tex; mode=display">
V^*=LV^*,\:V^\pi=L^\pi V^\pi</script><p>这两个算子都是压缩映射，这证明了收敛性和唯一性。</p>
<p>可以证明</p>
<script type="math/tex; mode=display">
||v_k-v^*||\leq \frac{\gamma^k}{1-\gamma}||v_0-v^*||</script><p><strong>Q-value iteration</strong></p>
<script type="math/tex; mode=display">
Q^*(s,a)=R(s,a)+\gamma\sum_{s'}P(s,a,s')(\max_{a'}Q^*(s',a'))</script><p>迭代方法</p>
<script type="math/tex; mode=display">
Q^k(s,a)=R(s,a)+\gamma E_{s'}[\max_{a'}Q^{k-1}(s',a')|s,a]</script><p><strong>Policy Iteration</strong></p>
<p>k-th iteration has two steps</p>
<ol>
<li>Policy evaluation: find $v^k$ by solving $v^k=L^{\pi^k}v^k$</li>
</ol>
<script type="math/tex; mode=display">
v^k(s)=E[R(s,a,s')+\gamma\sum_{s'}P(s,a,s')v^k(s')]</script><ol>
<li>Policy improvement: find $\pi^{k+1}$ such that $L^{\pi^{k+1}}v^k=Lv^k$</li>
</ol>
<script type="math/tex; mode=display">
\pi^{k+1}(s)=\arg\max_aR(s,a)+\gamma E_{s'}[v^k(s')|s,a]</script><p>这是个Greedy算法</p>
<p><strong>Platform</strong></p>
<ul>
<li>Gym: support Atari and Mujoco</li>
<li>Universe</li>
<li>Deepmind Lab</li>
<li>ViZDoom</li>
</ul>
<p>Packages: Rllab/Baselines/Github</p>
<p><strong>Taxonomy</strong></p>
<p><img src="RLtaxonomy.png" alt="RLtaxonomy"></p>
<p><strong>Temporal Difference</strong></p>
<script type="math/tex; mode=display">
v(s_t)\leftarrow (1-\alpha_t)v(s_t)+\alpha_tG_t</script><p>TD:</p>
<script type="math/tex; mode=display">
G_t=r_t+\gamma v(s_{t+1})</script><p>TD(n)：</p>
<script type="math/tex; mode=display">
G_t^{(n)}=r_{t}+\gamma R_{t+1}+...+\gamma ^{n-1}r_{t+n-1}+\gamma ^{n}v(s_{t+n})</script><p>TD( $\lambda$ )： </p>
<script type="math/tex; mode=display">
G_t^{\lambda}=(1-\lambda) \sum_{n=0}^{\infty}\lambda^{n-1}G_t^{(n)}</script><p> TD(0)即TD, TD(1)接近MC</p>
<h2 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h2><p><strong>Q-learning</strong></p>
<script type="math/tex; mode=display">
Q_{k+1}(s_t,a_t)=(1-\alpha)Q_k(s_t,a_t)+\alpha(r_t+\gamma\max_{a'}Q_k(s_{t+1},a'))</script><p><strong>Deep Q-learning</strong></p>
<p>以e的概率选择随机action，否则选择最大化Q的action $a_t$，然后得到$s_{t+1}$，$\phi_{t+1}=\phi(s_{t+1})$，然后将$(\phi_t,a_t,r_t,\phi_{t+1})$存储在D里</p>
<p>构造$y_j=r_j+\gamma\max_{a’} Q(\phi,a’;\theta)$，然后perform GD on $(y_j-Q(\phi_j,a_j;\theta))^2$</p>
<p><strong>DDPG</strong>：连续学习Q-function</p>
<script type="math/tex; mode=display">
\max_a Q(s,a)\approx Q(s,\mu(s))</script><p>选择action $a=clip(\mu_\theta(s)+e,low,high),\:e\sim N$。在Buffer D中存储(s,a,r,s’,done)</p>
<p>每次构造targets </p>
<script type="math/tex; mode=display">
y(r.s',d)=r+\gamma(1-d)Q_{\phi targ}(s',\mu_{\theta targ}(s'))</script><p>update Q-function by GD</p>
<script type="math/tex; mode=display">
(Q_\phi(s,a)-y(r,s',a'))^2</script><p>update policy $\theta$ by GD</p>
<script type="math/tex; mode=display">
Q_\phi(s,\mu_\theta(s))</script><p>然后按比例更新</p>
<p><strong>Twin Delayed DDPG</strong></p>
<p>三个trick：</p>
<p>1、learn two Q-function</p>
<script type="math/tex; mode=display">
y(r.s',d)=r+\gamma(1-d)\min_{1,2}Q_{\phi targ}(s',\mu_{\theta targ}(s'))</script><p>2、延迟更新policy（两次更新Q再更新policy）</p>
<p>3、对噪声e做截断</p>
<p><strong>Approximate dynamic programming</strong></p>
<p>update $\theta$ instead of value function</p>
<script type="math/tex; mode=display">
V_\theta(s)=\theta_0f_0(s)+\theta_1f_1(s)+...+\theta_nf_n(s)</script><p>TD(0) approximation: </p>
<script type="math/tex; mode=display">
\min\delta_t=r_t+\gamma V_\theta(s_{t+1})-V_\theta(s_t)</script><p>Fitted value-iteration:</p>
<p>update $\theta$ by finding $\theta$ to fit data</p>
<script type="math/tex; mode=display">
(V_\theta(s),LV_{\theta^{k-1}}(s))</script><p>问题：不一定能收敛</p>
<p>定义approximation operator $M_A$</p>
<script type="math/tex; mode=display">
v^i=(L\odot M_A)v^{i-1}</script><p>要求这个算子Non-expansive</p>
<h2 id="Policy-Gradient-On-Policy"><a href="#Policy-Gradient-On-Policy" class="headerlink" title="Policy Gradient (On-Policy)"></a>Policy Gradient (On-Policy)</h2><script type="math/tex; mode=display">
\max_\theta \rho(\pi_\theta)</script><p><u>Policy Gradient通常会震荡剧烈，甚至可能出现明显下降</u></p>
<p><strong>Finite horizon MDP</strong></p>
<script type="math/tex; mode=display">
\rho(\pi)=E[\sum_{t=1}^H\gamma^{t-1}r_t|\pi,s_t]</script><p>令$D^{\pi}(\tau)$为轨迹$\tau=(s_1,a_1,…,s_H)$的概率。</p>
<p>定理（log-trick）</p>
<script type="math/tex; mode=display">
\nabla_\theta\rho(\pi_\theta)=E_{\tau\sim D^{\pi_\theta}}[R(\tau)\nabla_\theta log(D^{\pi_\theta}(\tau))]=E_\tau[R(\tau)\sum_{t=1}^{H-1}\nabla_\theta log(\pi_\theta(s_t,a))]</script><p><u>一个很大的问题是采样必须有整条轨迹，否则一些情况下无法计算reward</u></p>
<p>方差减少的技术：加入Baseline b，这是无偏估计</p>
<script type="math/tex; mode=display">
g=\frac1m\sum_{i=1}^m\sum_{r=1}^{H-1}(R(\tau^i)-b)\nabla_\theta log(\pi_\theta(s_t^i,s_t^i))</script><p><strong>Long term average reward</strong></p>
<script type="math/tex; mode=display">
\rho(\pi,s_1)=\lim_{T\to\infty}E[\sum_{t=1}^T\gamma^{t-1}r_t|\pi]=\sum_sd^\pi(s)\sum_a\pi(s,a)R(s,a)</script><p>利用下面的V和Q</p>
<script type="math/tex; mode=display">
V^\pi(s)=\sum_a\pi(s_1,a)Q^\pi(s_1,a)</script><p>定义</p>
<script type="math/tex; mode=display">
Q^\pi(s,a)=R(s,a)+\gamma\sum_{s'}P(s,a,s')V^\pi(s')</script><p>当$\gamma=1$时，定义Q的时候要减去$\rho(\pi)$（Advantage）。</p>
<p>定理</p>
<script type="math/tex; mode=display">
\nabla_\theta\rho(\pi_\theta,s_1)=\sum d^{\pi_\theta}(s)\sum Q^{\pi_\theta}(s,a)\nabla_\theta\pi_\theta(s,a)\\
=\sum_sd^{\pi_\theta}(s)(E_{a\sim\pi(s)}[Q^{\pi_\theta}(s,a)\nabla_\theta log(\pi_\theta(s,a))])</script><p>Estimation using samples：根据policy $\pi$得到一系列轨迹，然后再每个step定义$Q_t$，那么这是一个$Q(s_t,a_t)$的无偏估计。 </p>
<p><u>上面为Actor-only methods，又称vanilla policy gradient。</u></p>
<p><strong>Actor-Critic methods</strong></p>
<p>定义函数</p>
<script type="math/tex; mode=display">
\nabla_wf_w(s,a)=\frac1{\pi_\theta(s,a)}\nabla_\theta\pi_\theta(s,a)=\nabla_\theta log(\pi_\theta(s,a))</script><p>对任意baseline b，参数w是下式的解</p>
<script type="math/tex; mode=display">
\min_w E_{s,a}[(Q^{\pi_\theta}(s,a)-b(s;\theta)-f_w(s,a))^2]</script><p>那么可以得到</p>
<script type="math/tex; mode=display">
\nabla_\theta\rho(\pi_\theta)=E_sE_af_w(s,a)\nabla_\theta log(\pi_\theta(s,a))</script><p>分为两步</p>
<p>1、Policy Evaluation：find w</p>
<p>2、Policy Improvement：update $\pi$</p>
<p><strong>Trust Region Policy Optimization（TRPO）</strong></p>
<p>定义 total expected discounted reward</p>
<script type="math/tex; mode=display">
\eta(\pi)=E_\pi[\sum_{t=0}^\infty \gamma^t r(s_t)]</script><p>maximizie the approximator</p>
<script type="math/tex; mode=display">
L_\pi(\hat{\pi})=\eta(\pi)+\sum_sd_\pi(s)\sum_a\hat{\pi}(a|s)A_\pi(s,a)</script><p>一个足够小的$\pi$的增量improve L的同时也improve $\eta$。有下界</p>
<script type="math/tex; mode=display">
\eta(\pi_{new})\geq L_\pi(\pi_{new})-\frac{2\epsilon\gamma}{(1-\gamma)^2}\alpha^2</script><p>其中的$\alpha$是TV divergence，这个可以由KL divergence控制。</p>
<script type="math/tex; mode=display">
\max L\\
s.t.KL(\theta||\theta_k)\leq\delta</script><p>但这个问题仍然是高度非线性的</p>
<p>TRPO将这个问题近似为</p>
<script type="math/tex; mode=display">
L_{\theta_k}(\theta)\approx g^T(\theta-\theta_k)\\
D_{KL}(\theta_k||\theta)=\frac12(\theta-\theta_k)^TH(\theta-\theta_k)</script><p>这个问题是有显式解的，</p>
<script type="math/tex; mode=display">
\theta=\theta_k+\sqrt{\frac{2\delta}{g^TH^{-1}g}}H^{-1}g</script><p>但是效果并不好。</p>
<p><strong>Proximal Policy Optimization（PPO）</strong></p>
<p>PPO-clip updates polices</p>
<script type="math/tex; mode=display">
\theta_{k+1}=\arg\max_\theta E_{s,a}[L(s,a,\theta_k,\theta)]</script><p>其中</p>
<script type="math/tex; mode=display">
L(s,a,\theta_k,\theta)=\min(\frac{\pi_\theta(a|s)}{\pi_{\theta_k}(a|s)}A^{\pi_{\theta_k}}(s,a),clip(\frac{\pi_\theta(a|s)}{\pi_{\theta_k}(a|s)},1-\epsilon,1+\epsilon)A^{\pi_{\theta_k}}(s,a))</script><p><strong>Monte-Carlo Tree Search(MCTS)</strong></p>
<p>Alpha-Go</p>
<p>Selection, Expansion, Simulation, Backpropagation</p>
<p>每个节点j的选取是要最大化</p>
<script type="math/tex; mode=display">
UCT=X_j+2C_p\sqrt{2ln(n)/n_j}</script><p>其中n是当前节点访问次数，$n_j$是j的访问次数，$C_p$是常数，$X_j$是节点平均价值</p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论</title>
    <url>/2020/03/06/database/</url>
    <content><![CDATA[<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型三要素：</p>
<ul>
<li>静态</li>
<li>动态关系</li>
<li>约束</li>
</ul>
<p>关系代数六种基本操作</p>
<ul>
<li>一元操作<ul>
<li>选择$\sigma$</li>
<li>投影$\pi$</li>
<li>重命名$\rho$</li>
</ul>
</li>
<li>多元操作<ul>
<li>并集$\cup$</li>
<li>差集$-$（先排序减少查重次数）</li>
<li>笛卡尔积$\times$</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>其他操作：</p>
<ul>
<li>交运算：虽然可以用差集表示，但底层直接实现</li>
<li>$\theta$连接：笛卡尔积代价很大，所以连接表操作时并非笛卡尔积+选择而是先排序+连接</li>
<li>自然连接：选取相同属性列上取值相等的元组</li>
<li>除操作：满足$q\times s\subseteq r$的最大关系q（可以表示为笛卡尔积+差集，实现是排序）</li>
<li>赋值运算：临时表，不支持递归定义（连接次数和数据相关）</li>
<li>外连接：</li>
<li>聚集函数：五个函数 sum、count、mean、max、mean（-distinct）</li>
<li>分组和聚集函数</li>
<li>广义投影：投影+计算</li>
</ul>
<p>删除/修改操作</p>
<p>空值返回Unknown，计算为false</p>
<p>视图View：虚表，限制数据访问范围，作为基本表和外模式之间的映像；更新原表需要满足列数一样等限制</p>
<p>物化视图：1、频繁使用的；2、固定的</p>
<p>关系代数表达式的等价规则：oracle有约50条等价优化规则</p>
<p>关系代数树：合并投影，投影/选择尽可能移向叶节点</p>
<p>元组关系演算：存在/任意/否</p>
<p><u>元组关系演算与关系代数等价</u></p>
<h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><ul>
<li>数据操作：SELECT，INSERT，UPDATE，DELETE</li>
<li>数据定义：CREATE，ALTER，DROP</li>
<li>数据控制：GRANT，REVOKE</li>
</ul>
<p><strong>SQL查询和关系模型</strong></p>
<ul>
<li>SQL Parser</li>
<li>Query Optimization and Execution</li>
<li>Relational Operators（基本运算实现）</li>
<li>Files and Access Methods（堆文件、顺序文件、B+树）</li>
<li>Buffer Management（数据库特性的缓存管理）</li>
<li>Disk Space Management（定长纪录、非定长纪录）</li>
</ul>
<p>SQL和关系代数的差别</p>
<ul>
<li>SQL引入排序符号</li>
<li>SQL支持单值集合直接使用</li>
<li>SQL投影默认不去重（去重加distinct），集合默认去重（不去重加All）</li>
<li>SQL支持递归、group by等操作</li>
</ul>
<p>SQL查询语句</p>
<ul>
<li>SELECT子句：支持*、支持四则运算、支持不加FROM实现数值运算</li>
<li>FROM子句</li>
<li>WHERE子句</li>
</ul>
<p>其他语句</p>
<ul>
<li><p>去重distinct</p>
</li>
<li><p>ORDER BY排序</p>
</li>
<li><p>AS重命名（可省略AS）</p>
</li>
<li><p>字符串操作：(not) like “”，</p>
<p><code>%</code>匹配零个或多个，<code>_</code>匹配任意单个字符，<code>escape \</code>转义字符</p>
</li>
</ul>
<p>关系连接</p>
<ul>
<li>连接类型：<code>inner join</code> <code>left outer join</code> <code>right outer join</code> <code>full outer join</code></li>
<li>链接条件：<code>nature</code> <code>on&lt;谓词&gt;</code> `using(A1,A2,..,An)</li>
</ul>
<p><u>写法比较简单，并不标准，执行和集合操作等价</u></p>
<p>集合操作</p>
<p>union/intersect/except</p>
<p><u>集合操作是自动去重的，不去重要加上<code>all</code></u></p>
<p>聚集函数</p>
<p><code>max</code> <code>min</code> <code>avg</code> <code>sum</code> <code>count</code></p>
<p>如果select后有聚集函数，则非聚集函数列必须在<code>group by</code>中出现</p>
<p>分组</p>
<p><code>group by 列名 [having 条件表达式]</code></p>
<p>空值</p>
<p><code>is [not] null</code></p>
<p>空值参与算术运算，结果也为null，逻辑运算为false，聚集函数直接忽略</p>
<p><code>ISNULL(check_expression,replacement)</code>：如果check_expression为空则用replacement替代</p>
<p>嵌套子查询</p>
<ul>
<li>集合成员资格：<code>in</code></li>
<li>集合之间比较：<code>&gt;= all</code> <code>some</code> </li>
<li>集合基数的测试<ul>
<li>测试集合是否为空 <code>[not] exists</code></li>
<li>测试集合是否存在重复元组 <code>unique</code> 没有重复元组则返回true（可用count替代所以并不常用）</li>
</ul>
</li>
</ul>
<p>派生关系</p>
<p><code>AS</code>命名为临时关系 </p>
<p>临时视图</p>
<p><code>with ... as ..., ... as ... select ...</code> </p>
<p><strong>SQL修改功能</strong></p>
<p><code>insert into 表名 [列名] values (...)</code> 插入一条指定好值的元组</p>
<p><code>insert into 表名 [列名] (子查询)</code>插入子查询结果的若干条元组</p>
<p>多行数据的插入可以用union实现</p>
<p><code>delete from 表名 [where 条件表达式]</code></p>
<p><code>truncate table</code>删除表中所有行（比delete快，但不能带条件）</p>
<p><code>update 表名 set 列名=表达式|子查询 [where 条件表达式]</code></p>
<p> ORACLE数据库支持 <code>case</code> <code>when</code>根据条件update</p>
<p>SQL Servert支持用其他表更新某个表的数据（注意可能出现结果不确定的情况）</p>
<p><strong>视图</strong></p>
<p><code>create view view_name [列名] as (查询表达式) [with check option]</code></p>
<p>取消视图<code>drop view view_name</code></p>
<p>用视图更新原表需要满足很多条件，视图更新约束如下</p>
<ul>
<li>有主码</li>
<li>select子句目标列不能包括聚集函数，不能有group by</li>
<li>select子句不能用distinct</li>
<li>不能包括计算出的列</li>
</ul>
<p><strong>事务</strong></p>
<p>大多是数据库中，每个SQL执行成功后自动提交</p>
<p>每个事务包含一个语句</p>
<p>我们可以取消自动提交，使之支持多事务</p>
<p><strong>数据定义语言（DDL）</strong></p>
<p>域定义：</p>
<p>基本表的定义：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (</span><br><span class="line">    列名 数据类型 [<span class="keyword">default</span> 缺省值] [<span class="keyword">not</span> <span class="literal">null</span>] </span><br><span class="line">    [, primary <span class="keyword">key</span> (列名)] </span><br><span class="line">    [, <span class="keyword">foreign</span> <span class="keyword">key</span> (列名)] </span><br><span class="line">    [, <span class="keyword">check</span>(约束条件)]</span><br><span class="line">)<span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>修改表的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line">[<span class="keyword">add</span> 子句] 增加新列和约束</span><br><span class="line">[<span class="keyword">drop</span> 子句] 删除列和约束 某些数据库不支持</span><br><span class="line">[<span class="keyword">modify</span> 子句] 修改列定义</span><br></pre></td></tr></table></figure>
<p>删除表 <code>drop table 表名</code></p>
<p>索引的定义</p>
<p><code>create [unique] [clustr] index 索引名 on 表名 (列名[asc/desc])</code></p>
<p>unique：唯一性索引，不允许不同行索引值相同</p>
<p>cluster：聚集索引，影响物理存储位置，一张表只能有一个聚集索引（主要影响区间查询速度）</p>
<p><u>如果是非unique且非cluster的索引可能速度反而更慢</u></p>
<p>删除索引 <code>drop index 索引名</code></p>
<h3 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h3><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><h4 id="域约束："><a href="#域约束：" class="headerlink" title="域约束："></a>域约束：</h4><p><code>create domain 域名 域定义</code></p>
<p>还可以通过<code>constraint value-test check(value &gt; 4)</code>或者更复杂的<code>constraint account-type-test check(value in (&#39;A&#39;, &#39;B&#39;))</code>甚至还可以使用动态check</p>
<h4 id="引用完整性："><a href="#引用完整性：" class="headerlink" title="引用完整性："></a>引用完整性：</h4><p>删除操作根据外码定义方式决定<code>restrict</code> 不能删除 <code>cascade</code>  一起删除 <code>set null</code>设为空值</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><code>create assertion 断言名 check 语句</code> ：表明数据库所满足的条件，实现一般性约束。check约束、主码约束、外键约束可以看作其特例。</p>
<p>断言会导致显著的代价。目前数据库一般不支持assertion。</p>
<h4 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h4><h4 id="SQL数据分析-递归SQL："><a href="#SQL数据分析-递归SQL：" class="headerlink" title="SQL数据分析/递归SQL："></a>SQL数据分析/递归SQL：</h4><p>扩展<code>Group by</code>按照不同标准聚集—&gt;多维数据分析模型：</p>
<ul>
<li><code>rollup</code>  在指定属性列表的每个前缀上分组聚集的并集（相当于依次<code>group by</code>结果合集）</li>
<li><code>cube</code>：2^n次<code>group by</code>合集</li>
</ul>
<h4 id="支持排序、支持扩展聚集函数"><a href="#支持排序、支持扩展聚集函数" class="headerlink" title="支持排序、支持扩展聚集函数"></a>支持排序、支持扩展聚集函数</h4><p>基本分析句法 <code>&lt;function name&gt; () OVER ([partition by &lt;exp1&gt;] order by &lt;exp2&gt; [ASC|DESC] [NULLS FIRST|NULLS LAST])</code> 其中<code>partition by</code>用以分组，<code>NULL FIRST</code>确定空值的处理</p>
<p>排序函数<code>rank</code> <code>dense_rank</code>具体例子是<code>select student, rank() over (order by marks desc) from ...</code> <u>否则实现需要用连接+count</u></p>
<p>滑动窗口<code>AVG(price) OVER (Order by date ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING)</code></p>
<p>递归SQL <code>with A as (select ...(初始条件) union all select ... from A where ...)</code> 结束条件是A不再变化，<u>考虑到具体执行方式是分层执行，内层不支持聚集函数</u> </p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>在SQL 99被引入，机制包括三点</p>
<ul>
<li>E 执行时机：触发动作为insert、delete或者update</li>
<li>C 执行条件</li>
<li>A 完成动作</li>
</ul>
<p><code>create trigger 触发器名字 after|before insert|delete|update [of 列名] on 表名</code></p>
<p><code>referencing old|new table</code> 指定新旧数据</p>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> overdraft-<span class="keyword">trigger</span> <span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="keyword">account</span></span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> nrow <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> nrow.balance &lt; <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span> atomic</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ...</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p><u>功能强大，对数据库负担也很大</u></p>
<p>可以用于实现数据一致性、维护概要表、完成特定审计、记录关键变化</p>
<p>但是很难被优化、判定触发链终止条件比较复杂</p>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>数据库中的一段程序，执行代码会存储到数据库</p>
<p>适合功能单一、逻辑复杂、相对集中的任务</p>
<p>应用：手机月度账单计算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="keyword">Move</span>(</span><br><span class="line">    <span class="keyword">IN</span> oldAddr <span class="built_in">VARCHAR</span>[<span class="number">255</span>],</span><br><span class="line">    <span class="keyword">IN</span> newAddr <span class="built_in">VARCHAR</span>[<span class="number">255</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UPDATE</span> MovieStar</span><br><span class="line"><span class="keyword">SET</span> address = newAddr</span><br><span class="line"><span class="keyword">WHERE</span> address = oldAddr;</span><br></pre></td></tr></table></figure>
<p>使用方式<code>CALL Move(&quot;old&quot;, &quot;new&quot;)</code></p>
<p>安全性+性能+可维护性</p>
<h4 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h4><p>SQL提供的预编译器将SQL语句预编译为C语句</p>
<p>如果返回只有一条记录可以用<code>select ... into ...</code></p>
<p>返回多个记录用<u>游标</u>（相当于迭代器）<code>fetch</code></p>
<p>游标分为滚动游标（可以取任意元组）、非滚动游标（只能顺序取下一个元组）、更新游标（增加更新锁）</p>
<p>使用游标需要先声明，再打开，然后检索。之后需要关闭和释放。</p>
<p><code>declare 游标名[scroll] cursor for select ... [for update]</code></p>
<p><code>open</code>  <code>fetch ... from 游标名</code> <code>close</code> <code>free</code></p>
<p>通过游标更新<code>update ... where current of 游标名</code></p>
<h4 id="SQL模块化"><a href="#SQL模块化" class="headerlink" title="SQL模块化"></a>SQL模块化</h4><p>ODBC（Open Database Connectivity）标准：微软提出的应用程序和数据库交互的标准</p>
<p>JDBC基于ODBC+跨平台</p>
<p>好处：易实用，易移植，不需要预编译</p>
<p>缺点：动态绑定，执行效率低，运行时检查SQL语法</p>
<h4 id="图数据查询"><a href="#图数据查询" class="headerlink" title="图数据查询"></a>图数据查询</h4><p>创建点<code>CREATE TABLE 表名 (...) AS NODE;</code></p>
<p>创建边<code>CREATE TABLE 表名 (...) AS EDGE;</code></p>
<p>查询：<code>... WHERE MATCH (点名-(边名)-&gt;点名[-...-&gt;...])</code></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>防止不合法使用造成的数据<em>泄露</em>和<em>破坏</em></p>
<h4 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h4><p>DBA</p>
<p>完备的策略是收回用户权限的时候，删除用户给出的权限和<u>不是从管理员出发的给这用户的权限</u>。</p>
<p>每一个权限应该形成从管理员出发的完整的权限链</p>
<p>授权命令<code>GRANT 表级权限 ON 表名|视图名 TO 用户 [WITH GRANT OPTION]</code></p>
<p>表级权限包括select,update,…,以及 all。select和update可以指定列名</p>
<p><code>with grant option</code>表示用户可以再把权限授予其他用户</p>
<p>收回权限 <code>REVOKE</code> 用法和授权一样</p>
<p>GRANTh和REVOKE权限不能细化到某个元组，但是可以通过<u>和视图结合支持元组级别授权</u></p>
<p>基于<u>角色</u>的安全访问控制：<code>CREATE ROLE 角色名</code> <code>GRANT 角色名 TO 用户</code></p>
<h4 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h4><p>DAC：基于用户-对象权限访问矩阵和授权机制</p>
<p>桔皮书C1级别</p>
<h4 id="强制访问控制"><a href="#强制访问控制" class="headerlink" title="强制访问控制"></a>强制访问控制</h4><p>MAC：每一个数据库对象有安全级别，用户也有安全级别</p>
<p>桔皮书B1级别</p>
<p>两条规则：</p>
<ul>
<li><p>主体级别&gt;=客体 才能读</p>
</li>
<li><p>主体=客体 才能写</p>
</li>
</ul>
<p>修正规则：</p>
<ul>
<li>主体级别 &lt;= 客体 才能写</li>
<li>用户可以为写入数据对象赋予高于自己的级别</li>
</ul>
<p>共同点</p>
<ul>
<li>禁止高级别主体更新低级别数据</li>
<li>禁止低级别主体查询高级别数据</li>
</ul>
<p><u>Multilevel Relation</u>：每个数据用标签表明写入的级别（可以有相同主码）</p>
<h4 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h4><p>DBA事前，审计事后</p>
<p>审计权限在DBA之外</p>
<h4 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h4><p>例1</p>
<p>在username输入<code>&#39;;DROP TABLE USERS; --</code></p>
<p>那么后台验证时执行 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">USERS</span> <span class="keyword">WHERE</span> username <span class="keyword">IS</span> <span class="string">''</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">USERS</span>; <span class="comment">--'</span></span><br></pre></td></tr></table></figure>
<p>(<code>--</code>是SQL注释符号，保证语句正确性)</p>
<p>例2</p>
<p>在参数输入 <code>0 OR 1=1</code> 获得更多数据</p>
<p>其他</p>
<ul>
<li>通过特殊函数，使得服务器反馈详细信息，如版本和补丁信息</li>
<li>分析反馈错误信息，获取模式信息，例如 <code>union select top 1 name from sysobjects</code>报错将’admin’转换为int时失败</li>
</ul>
<p>解决方法</p>
<ul>
<li>动态绑定SQL语句：应用程序+后台数据，将输入作为参数接收</li>
<li>验证所有的输入：验证输入有效性，防止注释符号等</li>
<li>设置合理权限</li>
</ul>
<h3 id="实体关系模型"><a href="#实体关系模型" class="headerlink" title="实体关系模型"></a>实体关系模型</h3><p>标准Entity-Relationship图</p>
<p>E-R图：用以交流，需要表达</p>
<ul>
<li>实体（方形）</li>
<li>关系（菱形）</li>
<li>属性（椭圆）</li>
<li>多值属性（双椭圆）</li>
<li>派生属性（虚椭圆）</li>
<li>码（主码）</li>
<li>参与（单线）/完全参与（双线）</li>
<li>多对一/一对一（箭头）：此时不一定需要关系表</li>
</ul>
<p>扩展属性（<em>微妙</em>）</p>
<ul>
<li>存在依赖（一个实体存在依赖于另一个实体）</li>
<li>弱实体集（实体自身的属性不足以区分自己）（双长方形，需要以双菱形标识联系）</li>
<li>父类-子类（标记为ISA三角形）<ul>
<li>成员资格由条件定义/用户定义</li>
<li>子类不相交/有重叠</li>
</ul>
</li>
</ul>
<p>E-R图转换为表关系</p>
<ul>
<li>一般情况：属性对应多列</li>
<li>复合属性：不支持</li>
<li>多值属性：新的关系表</li>
<li><p>一对一联系：</p>
<ul>
<li>均部分参与：定义为新的关系</li>
<li>一方全部参与：作为一列，省略关系表</li>
</ul>
</li>
<li><p>一对多：作为列</p>
</li>
<li>多对多：关系表</li>
<li>弱实体：加入依赖强实体的码</li>
<li>ISA：三表方案/两表方案</li>
</ul>
<p><strong>E-R模型的设计</strong></p>
<ol>
<li>需求分析</li>
<li>确定局部结构范围</li>
<li>实体定义</li>
<li>联系定义</li>
<li>属性分配</li>
<li>局部E-R设计</li>
</ol>
<p>…之后…</p>
<ol>
<li>局部E-R图</li>
<li>确定公共实体类型</li>
<li>合并局部E-R</li>
<li>检查并消除冲突（属性冲突、命名冲突、结构冲突）</li>
<li>全局E-R优化</li>
</ol>
<p>工具：PowerDesigner</p>
<h3 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h3><ol>
<li>需求分析</li>
<li>概要设计（E-R图）</li>
<li>逻辑设计（DBMS模型）</li>
<li><strong>模式细化</strong>（规范化操作/逆规范化）</li>
<li>物理设计</li>
<li>安全设计</li>
</ol>
<p>不良设计—&gt;范式—&gt;模式分解—&gt;去范式的模式设计</p>
<h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>问题：数据冗余、插入/删除异常（限制信息表达能力）</p>
<p>问题本质是<strong>函数依赖</strong>：对客观世界的提炼（而非根据数据得出）</p>
<p>函数依赖分类</p>
<ul>
<li>平凡依赖：$Y\subset X$，$X\to Y$显然成立</li>
<li>完全/部分依赖：是否存在X的子集$X’$，$X’\to Y$</li>
<li>传递函数依赖：$X\to Y$，$Y\to Z$，且X不依赖于Y，$(X\cup Y)\cap Z=null$，称Z对X传递函数依赖。</li>
</ul>
<p><u>SQL没用提供函数依赖的支持，但是可以通过断言实现</u></p>
<p><strong>多值依赖</strong>：</p>
<p>关系U=(X,Y,Z)，给定(x,z)，有一组y，这组y仅仅取决于x而与z无关，此时y、z都是多值依赖于x（具有对称性），如果z是空集，则为平凡的多值依赖。函数依赖是多值依赖的特例。</p>
<p>多值依赖的有效性与属性集范围有关（增加属性不一定成立，而减少属性一定成立）</p>
<p>这是1NF范式的要求导致的</p>
<p><strong>码的术语</strong>：</p>
<ul>
<li>属性K决定关系U，称K为<strong>超码</strong></li>
<li>U完全依赖于K，称K为<strong>候选码</strong></li>
<li>候选码中选一个作为<strong>主码</strong></li>
<li>包括在任一候选码中的属性称为<strong>主属性</strong></li>
<li>关系模式的码由整个属性组成，称为<strong>全码</strong>，（此时不存在非平凡的函数依赖）</li>
</ul>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><ul>
<li>1NF：元素不可再分（考虑查询代价）</li>
<li>2NF：非主属性完全依赖于码（考虑数据冗余及插入/删除异常）</li>
<li>3NF：不存在非主属性对码<em>传递依赖</em>（同上）</li>
<li>BCNF：不存在主属性对码的依赖</li>
<li>4NF：不存在对码的多值依赖（主要是冗余）</li>
<li>5NF</li>
</ul>
<p>一般3NF/BCNF综合收益最高</p>
<script type="math/tex; mode=display">
BCNF\subset 3NF\subset 2NF</script><p>模式分解</p>
<p>模式分解的要求</p>
<ul>
<li>无损</li>
<li>保持依赖</li>
<li>无冗余</li>
</ul>
<h4 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h4><p>正确的、完备的推理规则集</p>
<p>Armstrong公理：</p>
<ul>
<li>自反律：$Y\subset X\Rightarrow X\to Y$</li>
<li>增广律：$X\to Y\Rightarrow XZ\to YZ$</li>
<li>传递性</li>
</ul>
<p>根据公理导出的规则</p>
<ul>
<li>合并律：$X\to Y,\:X\to Z\Rightarrow X\to YZ$</li>
<li>分解律：上式反向</li>
<li>伪传递率：$X\to Y,\: YW\to Z\Rightarrow XW\to Z$</li>
</ul>
<p><u>闭包的概念</u></p>
<h4 id="候选码的计算"><a href="#候选码的计算" class="headerlink" title="候选码的计算"></a>候选码的计算</h4><p>考察属性出现在依赖F左边还是右边</p>
<p>启发式规则</p>
<ul>
<li>左部属性必是主属性</li>
<li>右部属性必是非主属性</li>
<li>外部属性必是主属性</li>
</ul>
<h4 id="模式分解相关算法"><a href="#模式分解相关算法" class="headerlink" title="模式分解相关算法"></a>模式分解相关算法</h4><p><strong>正则覆盖</strong>：没有冗余依赖的等价依赖集合</p>
<p><strong>无损连接分解定理</strong>：分解$\rho=\{R_1,R_2\}$是无损连接分解的条件是$R_1\cap R_2\to R_1-R_2$或者$R_1\cap R_2\to R_2-R_1$</p>
<p><strong>函数依赖保持</strong>：分解之后不需要连接表也可以验证函数依赖</p>
<p><strong>BCNF分解算法</strong></p>
<p>如果模式$R_i$不属于BCNF，那么找到$R_i$上的非平凡函数依赖$\alpha\to\beta$使得$\alpha\to R_i$不属于$F^+$（即$\alpha$不是码），那么将$R_i$分解为$R_i-\beta$和$(\alpha,\beta)$</p>
<p><strong>3NF分解算法</strong></p>
<p>正则覆盖的每个依赖是一张表</p>
<p>如果没有模式包含R的候选码，则再加一张表</p>
<p><u>3NF分解是函数依赖保持的</u></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是程序逻辑运行单位</p>
<p>必须保持数据库的一致性</p>
<p>ACID性质</p>
<ul>
<li>Atomicity：事务的原子性</li>
<li>Consistency：保持数据库的一致性</li>
<li>Isolation：每个事务不了解其他并发事务—依靠<strong>事务调度</strong>实现</li>
<li>Durability：将更新永久化</li>
</ul>
<p>事务调度</p>
<ul>
<li><p>串行</p>
</li>
<li><p>并发—要求<strong>可串行化</strong>，即等价于某个串行调度</p>
<p>两个事务的指令冲突当且仅当两者都存/取数据项Q，且至少有一个write指令</p>
</li>
</ul>
<p><strong>视图可串行化</strong>是指在任意调度中，事务read到的值都是一样的。</p>
<p><strong>冲突可串行化</strong>调度的结果相同</p>
<p><u>视图可串行化而非冲突可串行化必有盲写（blind write，不读直接写）</u></p>
<p>事务调度好坏的标准：可恢复性，要求撤销<em>读取了失败事务写入数据的</em>事务</p>
<p>—&gt;<strong>无级联调度</strong>：不读没有commit的数据，一定是可恢复的</p>
<p>冲突可串行化判定</p>
<p>—&gt;<strong>优先图</strong>：要求不能有环，绘制方法是根据对一个数据的write有关的前后顺序判定箭头指向</p>
<p>事务隔离性级别：</p>
<ul>
<li>serializable：串行（最高级别）</li>
<li>repeatable read：可能发生幻象（没有index锁）</li>
<li>read committed：重复读值可能改变（没有数据锁）</li>
<li>read uncommitted：读脏数据</li>
</ul>
<h4 id="并发策略的实现"><a href="#并发策略的实现" class="headerlink" title="并发策略的实现"></a>并发策略的实现</h4><p>事务调度器</p>
<p>事务协议</p>
<ul>
<li><p>悲观控制策略：采取等待的方式避免冲突</p>
<p>两种锁：排他锁（X-锁）、共享锁（S-锁），这样调度器只负责锁的控制</p>
<p>锁控制协议：两阶段锁协议，第一阶段只能获得锁，第二阶段只能释放锁，事务结束的顺序就是事务lock point的先后。</p>
<p>改进：可能存在级联回滚，提交时释放锁</p>
<ul>
<li>严格（Strict）：提交时才能释放排它锁</li>
<li>严密（Rigorous）：提交时才能释放锁</li>
</ul>
<p>带有锁转换的两阶段锁协议：提高并发性（并无副作用）</p>
<p>锁的自动获得：read/write</p>
<p>锁的自动释放：commit </p>
<p><u>另一种方式：图协议，要求所有数据项施加偏序</u></p>
<p><u>另一种方式：树协议，避免重复加锁，缺陷是假设了数据的树状结构</u></p>
<p><u>另一种方式：多粒度协议—多粒度锁（IS、IX、SIX锁，其中I表示其后裔）</u></p>
<p>共同缺陷：死锁，两种处理方法，都需要回滚</p>
<ul>
<li>预防：预先占据所需全部资源/资源预先排序/事务排序（wait-die非抢占式和wound-wait抢占式，都使得老事务具有对新事务的优先级）</li>
<li>检测+恢复：基于时间戳的协议（空间代价）—&gt;Thomas写规则，会被覆盖的Write可以忽略不回滚</li>
</ul>
<p>多版本时间戳序列：方便回滚读取</p>
<p>—&gt;多版本两阶段锁协议：只区分只读事务和更新事务：这个协议读永远是可以的，但是写更新版本，如果有之后的写读取了之前的版本，则这个写操作不合法</p>
</li>
<li><p>乐观控制策略：采取事务回滚的方式避免冲突</p>
</li>
</ul>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>国民党党员、党章与组织制定</title>
    <url>/2020/03/05/KMT-History/</url>
    <content><![CDATA[<h1 id="国民党的改组"><a href="#国民党的改组" class="headerlink" title="国民党的改组"></a>国民党的改组</h1><p>国民党改组效仿苏共的组织制度，特别是注重发展群众。国民党基本照抄了苏共党章纪律，而中共的纪律更加严格。</p>
<p>国民党改组之后修改的党章改用通俗的白话文，虽然孙文本人对此不太认同，但是默认了以之在基层发展党员。</p>
<p>国民党党员的组成成分在广东一地以工农为主，而纵观全国，则大多是青年知识分子，特别是中小知识分子。他们热切的想要参与政治，也有想要谋个工作的含义。吸引力远超共产党，青年视共产党为洪水猛兽。</p>
<p>1923年前后国民党改组前党员20万，国内仅5万，群众基础薄弱。26年统计党员达到54.4万，且其中82%为国内党员，27年初党员人数应在百万以上。</p>
<p>但是国民党组织结构松散，在四一二清党之后，蒋、胡都认识到了这一点。国民党重视上层，忽视基层，就连广州亦是如此。基层经费不足，只能任由豪绅包办，或者豪绅直接伪装加入国民党把持党部。国民党来者不拒，导致党员滥化。一些人利用党籍作为升职工具或者争夺地方权力。这远非孙文所愿。</p>
<a id="more"></a>
<h1 id="国共合作"><a href="#国共合作" class="headerlink" title="国共合作"></a>国共合作</h1><p>关于“容共”，共产党明确是“合作”关系（强调自身独立性），而过国民党方面只是孙中山表明“容共”立场，认为中共是国际组织，与国民党不矛盾，打消党内顽固派的顾虑。</p>
<p>24年8月国民党中央全会上，瞿秋白与鲍罗廷与会，会议设立国民党下属国际联络委员会，协调两党问题，导致上海中共中央震怒。25年秋冬间，瞿秋白首次提出“联共”的说法，26年3月出现在中共中央正式文件中，在此前后国民党正式承认合作关系。26年5月二中全会设立5+3人的两党联席会议，国民党承认联共，这是蒋、鲍妥协的结果。</p>
<p>实际上，在青年中共产主义还是很有吸引力的，乃至孙中山要声称三民主义就是社会主义。</p>
<p>中共对于两党合作的态度是居高临下的“扶持”“诱导”“掖进”。</p>
<p>中共这时期的《向导》面向底层，但因为底层文化程度且不是免费的，实则面向了非底层。</p>
<p>即使如此，中共保持了其独立性，而国民党反而缺失机关刊物。国民党在宣传方面自愧不如，就连北伐时期的“三大政策”“国民革命”也源自中共。除此之外，中共提出的“打倒帝国主义”“打倒军阀”也深入民心。甚至在中共的影响下，国民党青年也相信宁左勿右，以右派为耻。四一二之后，蒋介石就明令禁止使用这些中共的怪词语。</p>
<p>虽然国共的骨干都是中小知识分子，但国民党向上层，共产党向下层。</p>
<p>26年1月国民党二大召开前后，国共实力已经逆转，特别是共产党对国民党地方组织控制更深入。</p>
<p>1924年5月中共中央执委会扩大会议之后，中共逐渐改变策略，开始注意在国民党内部发展组织力量，此事也引起国民党高层注意。对此陈独秀并不否认，还表示“在国民党内成立一个左派，只算是进步，不是破坏”。26年国民党二大以决议的形式限制国民党员转党。25年1月中共四大决定除了工作需要，共产党员不应当加入国民党。事实上，此前中共党员仅有950人，而在26年4月之后一年增加了4.5万。26年5月，蒋介石要求共产党提供党员名单，但中共没有提交。国共两党主客易位在两党合作末期已成为共识，这一事件的根源在孙中山想要创立列宁主义的严密政党而又能包容另一列宁主义政党时就已经注定。</p>
<h1 id="四一二"><a href="#四一二" class="headerlink" title="四一二"></a>四一二</h1><p>四一二对国共两党都是重大打击。中共六大统计，27年4月至28年上半年清党杀害31万人，其中共产党员2万余人，中共党员从5.7万减少到1万余人。清党前国民党党员总数在100万以上，29年10月统计总数降至65万（考虑新加入的投机分子等，实际清洗、脱党可能不止35万）。</p>
<p>关于清党到底逮捕、杀害了多少人，分歧很大，大约在10万人以上。但可以肯定的是，被捕被杀的人数远超中共党员人数。</p>
<p>“逆淘汰”——左派青年被清洗，下层工农阶级脱党 </p>
<p>“组织瘫痪”——国民党地方党务原多由共党包办，原共党控制的省市党部职位成为权力斗争的目标。而基层组织遭到土豪劣绅侵夺。</p>
<p>清党之后，党务人才奇缺，地方上听任豪绅和投机分子侵夺资源，上层只能依赖武力来弥补党力虚脱。</p>
<h1 id="执政党"><a href="#执政党" class="headerlink" title="执政党"></a>执政党</h1><p>27年国民党执掌全国政权以后，与工农民众割裂开来。28年2月撤销农、工、商、青年、妇女五部，对民众运动加以限制。</p>
<p>原来上层国民党-中层共产党-下层民众的结构打破后，民众团体成为国民党的装饰物。比如农会，主要成分从佃农转为“有农地者”以及“习农业者”等。究其原因主要是对民众运动的恐惧、认为民众运动是共党产物。</p>
<p>清党之后，国民党分为两派，对待民众运动的态度截然不同，分别为胡汉民为首的元老派，汪精卫陈公博为首的改组派，蒋先生立于其间。</p>
<p>实则在孙中山的思想里，人分先知先觉和后知后觉的，他并不赞同国民党以工农为基础。改组派提出国民党应以工农为基础，蒋先生则认为所有被压迫的人都是（全民都被帝国主义压迫），但是造成了“两不讨好”的局面，比如《工厂法》在劳资双方都有意见。国民党成为执政党之后抛弃了工农联盟，却也没能赢得资本阶级的支持。</p>
<p>事实上，国民党与资本家阶级一直存在着矛盾。1932-1933期间，由三友实业的劳资纠纷，转变为上海整个劳资两大阵营的正面冲突，上海绝大多数工会都卷入其中。这其中也有资方与国民党中央的较量，引起南京党部28年以来首次对资本家阶级大张挞伐的“卅电”，但政治强权依旧未能把资方压服。资方在法律上完全失败，1932年上海地方法院驳回上诉，1933年1月最高法院再次驳回。但资方仍旧拖延不履行判决，上海当局也显得软弱，最后1933年12月在杜月笙调停下以资方支付解雇金、工人放弃复工告终。</p>
<p>可以看到，一则国民党的统治力比较有限，二则国民党太想讨好所有的人民了，最后反而都不能讨好。</p>
<h1 id="党治"><a href="#党治" class="headerlink" title="党治"></a>党治</h1><p>国民党清党之后，党力实则弱化，而党统在派系斗争中 濒于破裂。法理上的“以党治国”演变为“以军治国”。</p>
<p>在孙中山设想中，训政只维持6年，然后进入宪政。1929年6月国民党三届二中全会也如此决议。但到了1935年并未结束训政。</p>
<p><strong>中政会：</strong>国民党自上而下设立了党政互动的双轨统治机构，党治的重点放在中央一级，孙中山1924年7月效仿俄共中央政治局设立中政会就是此意。</p>
<p>国民党改组后的最高权力机关是中央执行委员会。鉴于40余人的中执会难以对复杂多变的局势作出反应，孙中山提出党政军分离，先后设立政治委员会、军事委员会，这两个委员会名义上式中执会的下属机构。孙中山在世时，三个组织都听命于他，实际是党魁独裁制。中政会同时受总理和中执会节制，孙去世之后，中政会地位明显提高。26年国民党推选汪精卫、胡汉民、蒋介石为中政会委员，27年3月鉴于中政会有受蒋介石挟持的嫌疑，对中政会职权进行了限制。国民党实施训政之后，28年10月决议中政会集立法、决策、人事大权于一体。</p>
<p>后来中政会人数从十数人开始逐渐膨胀，30年代中政会有多达200余人，中政会逐渐变得没有实权。中政会衰落之后，中常会（中执会常委会）就更无足轻重。</p>
<p><strong>兼任：</strong>除了中政会之外，另一条党治通道是中央领导人兼任政军要职来控制政府和军队。主席、委员、五院院长、各部部长都是中央委员兼任。1936年统计，13名最显赫的党政要人兼任了165个职位，蒋介石本人兼任24个。</p>
<p>国民党中央党政军角色高度重叠，实则“法无定规，权从人转”，比如国家主席一职在林森和蒋介石出任前后的变化。国民党法理上最高的中央委员会也日趋没落。</p>
<p>中常会中执会的衰落本质是党权被侵蚀，主要是军权。胡汉民曾试图以党权抗争军权，宁汉之争便是如此。大体上27-31是两权相争，之后则是军权扼制党权。军政党的顺序从中央贯穿到地方。</p>
<p><strong>重军轻党：</strong>蒋介石推崇军人，以及军队的组织纪律，主张政治军事化、党务军事化，甚至社会军事化。政治上设立“行政督察专员”推进剿共，社会上推行保甲制度和新生活运动。KMT执政后，军人党员迅速膨胀（从1929年30w到1937年101万），而普通党员增长缓慢。</p>
<p><strong>双轨制：</strong>国民党推行中央实行党治领导行政，而地方上是党政双轨，行政领导党治。只在地方实力派控制的地区才有党政高度重合的现象。蒋介石等认为地方党治干预行政是“党乱”，胡汉民指出地方党组织是<strong>辅助</strong>政府行政，沟通政府和人民的。这也导致了地方上党治权威的降低，称为地方政府的附庸。</p>
<p><strong>党政冲突</strong>：地方党政冲突是KMT两大顽疾之一，一些地方甚至从文斗升级为武斗。党务人员薪俸较低，在30年代之后党部失势，地方党权低落，制约了KMT党治在基层的运作。</p>
<p><strong>以党治国：</strong>孙中山主张“党义治国”而非“党员治国”，但其后国民党并没很好遵循这一点。但1926年蒋介石建立南京政府前后，就谈到以党治国是根据党的主义指定政治方案，交给政府去实行，而不是直接施政。党籍并不是入仕的必要条件，中央政府机关中国民党党员的比例在1929年为36%，1933年降至22%，1939年又升到45%<em>（此处还需考虑后加入党的？）</em>。这一比例远远称不上独裁。南京上海的政府机关公务员中党员仅占10%-17%。27年以后KMT形式上执掌政权，但并不具备高度党治的实力。29年仅27万党员，37年也不过52万。29年南京政府控制8%国土和20%人口，到37年控制25%地区和66%人口，但是政权组织职能局限于上层和城市，党治实际控制有限。</p>
<p>政府在党外主要吸纳两部分人，一是北洋旧官僚（国民党内元老派包括蒋先生认为年轻党员“幼稚”，因而不让地方党部干预行政，当时有“南京政府，北京内阁”之说），二是专家知识分子。</p>
<h1 id="派系"><a href="#派系" class="headerlink" title="派系"></a>派系</h1><p>北伐时期胡汉民提出“党外无党，党内无派”，这一理念使得派系政治朝两个方面发展，一是争夺党的正统，二是派系斗争隐蔽化。</p>
<p><strong>1925~1931年继承权之争和“党统”之争</strong>：</p>
<p>27年“四一二”之前四次分裂</p>
<ul>
<li>25年8月廖仲恺被刺，胡汉民和汪精卫分裂</li>
<li>25年11月西山会议派另立中央</li>
<li>26年3月中山舰，蒋汪分裂</li>
<li>27年“四一二”宁汉分裂</li>
</ul>
<p>之后各派在“反共”问题上取得一致，但派系斗争激化。党内左右两派依然存在，蒋介石力图以武力树立正统地位，引发左右两派和地方军事集团的不满。</p>
<p>1931年2月“汤山事件”结束了蒋胡合作的局面。</p>
<p>右派（西山会议派）结构松散，28年之后实际失势；左派（改组派）声威虽猛，只有28-30年两年组织生命。</p>
<p><strong>1932~1937年次生派系斗争</strong>：</p>
<p>外部：“福建事变”和“两广事变”</p>
<p>内部：CC系、力行系和政学系</p>
<p>政学系是少数高层的松散组织。</p>
<p>CC系（“Center Club”）一方面控制党机器而使党派系化，一方面又有独立组织系统。33年-49年间KMT基本由CC系掌控。二陈一直否认CC系的存在，但是1933年初二陈在蒋授意下组织过“青白团”，顶层为“青白团”，中层为“中国国民党忠实党员同盟会”，下层是众多活动集社（上海“干社”，平津“诚社”，江苏“励进社”等）和外围团体（中国文化建设协会等）。强调蒋为唯一领袖的绝对集权制。“忠实党员同盟会”主要寄附各级党组织，活动对内秘密，对外以KMT招牌进行。只有纵向关系，下层甚至不知道上层组织的存在。</p>
<p>力行系是“派系党化”的“党中之党”，力图建立新的党组织改造KMT。32年“力行社”在蒋介石的亲自主持下成立，一度成为国家最高决策机构，32年下半年开始逐渐成为一个纯粹的决策执行组织。有三层组织，顶层为“三民主义力行社”约300人，第二层为“革命军人同志会”（人数不明）和“革命青年同志会”约3万人，第三层为“中华复兴社”约10-50万。战前力行社规模与KMT相当，两部分成员并非是重叠的。力行社也被外界误传为“蓝衣社”，常被视作一个新党。</p>
<p>CC系和力行社都强调蒋的绝对权威，采取集权主义体质和秘密组织系统，鼓吹法西斯主义，附设有庞大的特务机关。两者均在1938年3月KMT全国代表大会后宣布取消。</p>
<p>CC系和力行社关系日趋紧张，1934年蒋做出大致分工，CC系致力于党，力行社致力于军，但是两派之间的斗争一直持续，1938年后以党团队里的形式延续。</p>
<p><strong>1938~1949年拥蒋派系斗争</strong>：</p>
<p>党团之争、CC系和政学系</p>
<h1 id="党员"><a href="#党员" class="headerlink" title="党员"></a>党员</h1><p>KMT普通党员增长缓慢</p>
<p>党员与人口比例更低</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>政党</th>
<th>党员/人口</th>
</tr>
</thead>
<tbody>
<tr>
<td>KMT（1935）（包括61%军队）</td>
<td>1:300</td>
</tr>
<tr>
<td>苏共（1931）</td>
<td>1:65</td>
</tr>
<tr>
<td>中共（1958）</td>
<td>1:52</td>
</tr>
<tr>
<td>意大利法西斯（1934）</td>
<td>1:25</td>
</tr>
</tbody>
</table>
</div>
<p>1935年，KMT统治中心的江浙党员仅占16.8%，而与南京分庭抗礼的两广党员有1/3，另有1/4名义上奉KMT为正朔的省区党员。所以KMT是组织基础十分脆弱的执政党。</p>
<p>党员增长缓慢，一是党组织涣散，二是民众疏离。</p>
<p>农村无党，基层脆弱，战前KMT组织未能深入县以下。省党部以下组织多数不健全，地方党务有名无实，或完全停顿。</p>
<p>边缘省区如东北省组织活动被张学良抑制，山西阎锡山借学生运动抵制党部，山东韩复榘类似。两广长期分立，自成一系。</p>
<p>战前KMT党员除军人外，主要集中于知识界和政界。KMT执政后，青年学生人数下降，政界党员增加，农工党员比例下降。</p>
<p>KMT党的形象在北伐后两三年间急转直下。众多支持者如胡适、蒋廷黻也在30年后逐渐转变看法。另一方面，蒋介石也公开和私下对KMT进行批评。</p>
<p>“党部机关衙门化、党部委员官僚化、普通党员特殊化”</p>
<h1 id="抗战"><a href="#抗战" class="headerlink" title="抗战"></a>抗战</h1><p>三民主义青年团正式成立于1938年3月底。“党外造党”试图吸引对KMT反感的青年一代，同时想统合党内各派。</p>
<p>蒋对三青团团员以新生力量相期许，将KMT推到尴尬的境地。同时考虑CC系独掌KMT党机器，蒋属意力行社成员承担组建任务。这导致派系争斗，延续为党团之争。</p>
<p>党团双轨制，但三青团组织关系上与KMT日趋疏远，行为和工作上和KMT日趋接近。党团势成水火之时，蒋才强调KMT对三青团的领导地位，但党团斗争持续加剧，直到1947年党团矛盾激化危及KMT时，蒋才下决心把三青团并入KMT。</p>
<p>KMT中央党政一体化，地方上则要求党政互相监督，因而造成地方党政矛盾。战时格局没有改变，但省党部委员多由省主席兼任，省主席又由战区军事首领担任，省级实现了党政军一体化。地方上形成新式军阀，“以军统党”，“以政统党”，地方党部进一步萎缩。地方党部不得干涉地方政府，但协助和监督；地方政府往往加以抵制，党部显得软弱无能，沦为军政附庸。</p>
<p>抗战成立国防最高委员会，蒋以KMT总裁身份兼任委员长，独揽党政军一切大权。</p>
<p>抗战初期，KMT军事溃退，长江下游地区基层组织几乎解体，战前52万普通党员到1939年只余下28万。1939年开始，KMT采取政策大量吸收新党员，抗战胜利时达到264万，军队党员423万。三青团同期124w，中共121w。</p>
<p>KMT的组织扩张和渗透程度也大为强化。1938年要求县设置党部，1939年“新县制”要求乡镇设区党部，保设区分布，甲设党小组，并且恢复了大革命时期的“党团”制度。45年全国至少1/3乡镇和保建立了区党部和区分部。</p>
<p>党员分布中地域向西南转移。职业中政府机关公务员比例急剧上升，但官员不加甄别强制入党也导致旧权力成为党内官僚。党组织对党员质量不问，党员信仰不顾，党籍管理混乱，一味追求数量扩张，大多数党员游离于党组织之外。</p>
<h1 id="战后"><a href="#战后" class="headerlink" title="战后"></a>战后</h1><p>CC系长期把持党政，引起其他派系不满。六大中，以CC系为一方，以三青团、黄埔系、朱家华系、新桂系等为另一方分化为两大阵营，两大阵营相当。新中委中CC系凭借蒋的偏袒再次获得绝对优势，站总数1/4以上。</p>
<p>蒋空前扩增中委名额，意图缓解各派系矛盾，但不仅没能弥合纷争，反而流失党心。“六大”前后，人心涣散。</p>
<p><strong>1944~1947”党政革新运动“</strong>：虽然没有多少具体成果，但也有重要意义。革新集团是一个跨派系的松散结合，最早由一批CC分子聚会清谈，最初矛头指向孔、翁等政学系成员。1944年KMT五届十二中全会，他们形成初步同盟，痛愤KMT无能，甚至对蒋的领导方式不满。蒋虽然也对KMT失望，但无疑接受革新分子的要求，一方面也可能是考虑到三青团造成的困扰。这条战线也有黄埔/三青团参与，因为他们都有强烈的政治诉求且在反共问题上高度一致，这里更像是代际之争。政学系主导了国共谈判，革新分子趁机攻击政学系牺牲党的利益，蒋虽对他们感到不满，但还是勉强同意了中常委任命。1946年革新派在重庆中央党部举行了公开的党政革新座谈会，在党内党外公开革新目标，革新运动扩大为一场波及全党的政治运动。</p>
<p>在革新分子看来，KMT腐败的根源是北伐军事胜利，政治失败，失去了革命性。革新分子认为党和党员脱节、和民众疏离、政权旁落官僚等等。“国民党理论家”叶青归纳党务缺点：1、组织散漫，2、党员腐化，3、工作松懈，4、派别分歧。因而要求党内民主。</p>
<p>革新分子对KMT猛烈批评，一致认为是成败兴亡的关头。在他们看来三民主义仍是最好的主义，KMT只要唤起革命精神就能获得新生。革新运动除了几场清议和刊物外，并无多少实际成果。1946年10月KMT中央形式上发动一次流于形式的党员总清查。但是革新运动批判北伐后的失策、攻击政学系，后遭到蒋的严厉训斥解散。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>弱势独裁党的必然命运</p>
<p>KMT控制只到政治表层，而没有深入社会内部</p>
<p>一党专政+三民主义导致有集权的委员会又有分权的独立机关</p>
<p>党员对派系的忠诚超过了对党的忠诚</p>
<p>军&gt;政&gt;党</p>
<p>特务组织猖狂与其党机器无能有关</p>
]]></content>
      <categories>
        <category>喵后记</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>团团伙伙论</title>
    <url>/2020/02/26/group/</url>
    <content><![CDATA[<h3 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h3><p>集合X的变换$\alpha$的群记为$S_X$（对称群）</p>
<p><u>Cycle notation：可以证明任意变换可以写作不相交的轮换</u></p>
<p>另一种形式是写成交换的形式。</p>
<p>由此可以确定变换的奇偶。可以证明$sgn(\alpha)=(-1)^{n-t}$，t为轮换的个数。显然奇偶变换数量一样。</p>
<a id="more"></a>
<p>定义：操作$\mu:G\times G\rightarrow G$，半群$(G,<em>)$定义为G上有结合律的操作$\</em>$。</p>
<p>定义：群是有单位元的半群。</p>
<p>定义：同态$f:G\to H$，$f(ab)=f(a)f(b)$。同构是双射的同态。</p>
<p>定义：子群$S\leq G$。</p>
<p>定义：有限群，order</p>
<p>定义：同态$f$的kernel：$ker\:f={a|f(a)=1}$和image：$im\:f={h|h=f(a)}$</p>
<p>定义：$S\leq G$，右（左）陪集 =St(tS)。显然右陪集不交。</p>
<p>定义：index为右陪集数量，记为[G:S]。（Lagrange：G有限，则[G:S]=|G|/|S|）</p>
<p>循环群$|G|=n$，那么对于每个n的因子d，存在唯一子群$|H|=d$。（因此$n=\sum_{d|n}\phi(d)$。）反之，若对每个d，至多存在一个这样的子群，则G为循环群。</p>
<p>$|ST||S\cap T|=|S||T|$</p>
<p>定义：正规子群$K\lhd G$，如果对任意$g\in G$，$gKg^{-1}=K$。</p>
<p>定义：x的共轭为$\{x^*|\exists a\:,x^*=axa^{-1}\}$</p>
<p>题目：（H.B.Mann)有限群G，子集ST，|S|+|T|&gt;G，那么G=ST。（考察S^{-1}g，必和T有交集）；有限域F的任意元素可以写成平方和。（考察a^2和b-a^2）</p>
<p>定义：$N\lhd G$，商群G/N定义为陪集的集合</p>
<p>定义：交换子$aba^{-1}b^{-1}$，其生成的群为交换子群。交换子群G’是G的正规子群。$H\lhd G$，则$G/H$可交换$\Leftrightarrow G’\leq H$</p>
<p>性质：(P.YFF)交换子群为“长交换子集”的子集。</p>
<p>性质：交换子集不一定等于交换子群，一个例子就是P.J.Cassidy给出的</p>
<script type="math/tex; mode=display">
\pmatrix{1&f(x)&h(x,y)\\
0&1&g(y)\\
0&0&1}</script><p>第一同构定理：同态$f$，$G/(ker\:f)\cong im\:f$</p>
<p>引理：G子群S、T中有一个是正规的，那么ST=TS也是子群</p>
<p>第二同构定理：$N\lhd G$，$T\leq G$，那么$N\cap T\lhd T$且$T/(N\cap T)\cong NT/N$。</p>
<p>第三同构定理：$K\leq H\leq G$，K、H正规，那么$(G/K)/(H/K)\cong G/H$。</p>
<p>Correspondence Theorem：$K\leq T\leq S\leq G$，K正规，那么$T\lhd S\Leftrightarrow T^*\lhd S^*$，且此时$S/T\cong S^*/T^*$。其中$S^*=S/K$。</p>
<p>定理：H，K正规，如果$HK=G$,$H\cap K=1$，那么$G\cong H\times K$。</p>
<p>定理：$A\lhd H$，$B\lhd K$，那么$(H\times K)/(A\times B)\cong(H/A)\times(K/B)$</p>
<p>定义：a的共轭的集合记为$a^G$</p>
<p>定义：群G的中心Z(G)是所有的$\{a|ag=ga\:,\:\forall g\in G\}$</p>
<p>定义：中心化子$C_G(a)=\{x|ax=xa\}$，显然这是个子群。</p>
<script type="math/tex; mode=display">
|a^G|=[G:C_G(a)]</script><p>定义：群H的共轭记为$H^g=gHg^{-1}$</p>
<p>定义：正规化子$N_G(H)=\{a\in G:\:aHa^{-1}=H\}$，显然这是个子群，且$|H\lhd N_G(H)|$。</p>
<p>H的共轭的个数=$[G:\:N_G(H)]$</p>
<p>题目：$H\lhd G$且有质数index，且$C_H(x)&lt;C_G(x)$，那么x在H中共轭的数量和在G中相等。（考虑$G=C_G(x)H$）（在证明A_n单群中多次用到）</p>
<p>引理：$\alpha,\:\beta\in S_n$，那么$\alpha\beta\alpha^{-1}$和$\beta$有相同的结构，即r-cycle数量相等。（证明：$\beta(i)=j,\:\alpha(i)=k,\:\alpha(j)=l$，那么$\alpha\beta\alpha^{-1}(k)=l$）</p>
<p>定理：$\beta$和$\gamma$是共轭当且仅当他们有相同的结构。</p>
<p>定理：order为12 的A4没有order为6的子群</p>
<p>定理：$A_n,\:n\geq 5$是单群。证明如下</p>
<ul>
<li>$A_4$有正规子群{(), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)}</li>
<li>$A_5$是单群（1、所有3-cycle是共轭的；2、所有不交的交换是共轭的；3、5-cycle构成两个12元的共轭集合；4、|H|=60，但是1+共轭集合都不是60的约数）</li>
<li>如果$H\lhd A_n$，且H中有3-cycle，那么$H=A_n$（首先证明所有3-cycle共轭，然后证明An可由3-cycle生成）</li>
<li>$A_6$是单群（考察$\{\alpha|\alpha(i)=i\}$，与$A_5$同构）</li>
<li>$A_n$是单群（考察$\beta(i)=j$，必有3-cycle与之不交换，所以可以找到$A_6$的同构）</li>
</ul>
<h3 id="一些群表示论定理"><a href="#一些群表示论定理" class="headerlink" title="一些群表示论定理"></a>一些群表示论定理</h3><p>（Cayley）任何一个群G可以被嵌入为$S_G$的子群。如果|G|=n，那么G可以被嵌入$S_n$。（Left translation $L_a(x)=ax$，<strong>$a\to L_a$也被称为G的左正规表示</strong>）</p>
<p>推论：k是一个域，有限群|G|=n，那么G可以被嵌入GL(n,k)。</p>
<p>定理：如果$H\leq G$且$[G:H]=n$，那么有同态$\rho:G\to S_n$，满足$\ker\rho\leq H$。（这样的同态$\rho$称为<strong>G在H陪集上的表示</strong>）</p>
<p>推论：若定理中的G为单群，那么G可以被嵌入到$S_n$。（这也是Cayley定理的一个推广）</p>
<p>定理：$H\leq G$，定义$X$是H在G中的共轭。那么有同态$\phi:G\to S_X$，满足$\ker\phi\leq N_G(H)$。（这样的同态$\phi$称为<strong>G在H共轭上的表示</strong>）</p>
<h3 id="G-set"><a href="#G-set" class="headerlink" title="G-set"></a>G-set</h3><p>集合X，群G，定义X是G-set如果存在$\alpha:G\times X\to X$使得</p>
<ol>
<li>对$\forall x\in X$，1x=x</li>
<li>g(hx)=(gh)x</li>
</ol>
<p>也称为G作用在X上。</p>
<p>可以看到存在G到$S_x$的同态。同时，群G到$S_X$的同态也能定义一个X上的群作用G。</p>
<p>定义：轨道G-orbit为</p>
<script type="math/tex; mode=display">
O(x)=\{gx:g\in G\}\subset X</script><p>定义：x的stabilizer</p>
<script type="math/tex; mode=display">
G_x=\{g\in G:gx=x\}\leq G</script><p>定理：如果X是G-set，$x\in X$</p>
<script type="math/tex; mode=display">
|O(x)|=[G:G_x]</script><p>推论：如果G是有限群，$x\in G$，那么x的共轭个数为$[G:C_G(x)]$</p>
<p>推论：如果G是有限群，$H\leq G$，那么H的共轭个数是$[G:N_G(H)]$</p>
<p>定义：X是transitive如果它只有一条轨道</p>
<p>定义：如果X和G都是有限的，称G-set X是有限的</p>
<p>定理（Burnside 引理）：有限的G-set X，轨道数量N</p>
<script type="math/tex; mode=display">
N=(1/|G|)\sum_{\tau\in G}F(\tau)</script><p>其中$F(\tau)$是被$\tau$所固定的x。</p>
<p>定义：$G\leq S_X$，其中$X=\{1,2,…,n\}$，如果C是colors的集合，那么$C^n$是一个G-set，如果我们定义$\tau(c_1,…,c_n)=(c_{\tau 1},…,c_{\tau n})$。如果$|C|=q$，那么一个$C^n$的轨道称为(q-G)-coloring of X。</p>
<p>引理：C是q个颜色的集合，$G\leq S_X$，如果$\tau\in G$，那么$F(\tau)=q^{t(\tau)}$，其中$t(\tau)$是$\tau$的完全分解的cycle个数。</p>
<p>定义：如果$\tau$的完全分解有$e_r(\tau)\geq 0$个r-cycle，那么定义index</p>
<script type="math/tex; mode=display">
ind(\tau)=x_1^{e_1(\tau)}...x_n^{e_n(\tau)}</script><p>如果$G\leq S_n$，那么G的cycle index就是多项式</p>
<script type="math/tex; mode=display">
P_G(x_1,...,x_n)=(1/|G|)\sum_{\tau\in G}ind(\tau)\in Q[x_1,...,x_n]</script><p>推论：如果|X|=n，且$G\leq S_n$，那么(q,G)-coloring的数量是$P_G(q,…,q)$。</p>
<p>定理（Polya，1937）：$G\leq S_X$，其中$|X|=n$，$|C|=q$，定义</p>
<script type="math/tex; mode=display">
\sigma^i=c_1^i+...+c_1^i</script><p>那么(q,G)-cloring of X且有$f_r$个元素是$c_r$的个数是$P_G(\sigma_1,…,\sigma_n)$中$c_1^{f_1}…c_q^{f_q}$的系数。</p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>定义：motion是保距变换T满足$||Tx-Ty||=||x-y||$。</p>
<p>定义：线性变换S是正交的，如果$||Sx||=||x||$。</p>
<p>定理：集合$O(n,R)$（实正交群）是$GL(n,R)$的子群。motion的集合$M(n,R)$是一个群。</p>
<p>定义：矩阵$A\in GL(n,R)$是正交的，如果$AA^T=I$</p>
<p>定义：如果|T|=1（orietation-preserving），称为旋转。旋转群$SO(n,R)\leq O(n,R)$，显然$[O(n,R):SO(n,R)]=2$</p>
<p>定理：任何沿着过原点的超平面H的反射都不是旋转。</p>
<p>定义：二维平面上的图像$\Delta$的对称群</p>
<script type="math/tex; mode=display">
\Phi(\Delta)=\{S\in O(2,R):S(\Delta)=\Delta\}</script><p>定理：如果$\Delta$是一个正n边形，那么$\Phi(\Delta)$是由n阶元素S（旋转）和2阶元素T（反射）生成的。</p>
<p>定义：二面体群$D_{2n}$是2n阶群，由两个元素s,t生成，满足</p>
<script type="math/tex; mode=display">
s^n=1,\:t^2=1,\:tst=s^{-1}</script><p>定理：如果G是有限群，如果$a,b\in G$阶都是2，那么存在n，$<a,b>\cong D_{2n}$。（只需取s=ab,t=a即可）</p>
<p>定义：三维平面上的图像$\Omega$</p>
<script type="math/tex; mode=display">
\Phi(\Omega)=\{S\in O(3,R):S(\Omega)=\Omega\}</script><p>如果$\Omega$是正n面体，每个面有k个边，那么这个群是nk阶的。</p>
<p>定义：函数$\phi:R^2\to R^2$是仿射映射如果有线性变换$\lambda$和向量z</p>
<script type="math/tex; mode=display">
\phi(v)=\lambda(v)+z</script><p>用Aff(2,R)记所有仿射映射的群。</p>
<h3 id="Sylow-Theorems"><a href="#Sylow-Theorems" class="headerlink" title="Sylow Theorems"></a>Sylow Theorems</h3><p>定义：素数p，p-群是每个元素的阶都是p的幂次。</p>
<p>引理：如果G是个有限阿贝尔群且阶可被素数p整数，那个G有阶为p的元素。</p>
<p>定理（Cauchy，1845）：如果有限G的阶被素数p整除，则G有阶为p的元素。</p>
<p>根据群分类定理：</p>
<script type="math/tex; mode=display">
|G|=|Z(G)|+\sum_i[G:C_G(x_i)]</script><p>可得$p|C_G(x_i)$或者$p||Z(G)|$。前者递归可证，后者是阿贝尔群。</p>
<p>另一种证明由J.H.McKay给出，定义$X=\{(a_1,a_2,…,a_p)|a_1a_2…a_p=1\}$，显然$|X|=|G|^{p-1}$，考虑X的每个元素都有p个轮换，除了满足$\forall i,a_i=a,\:a^p=1$。如果没有阶为1的元素，则只有a=1，那么</p>
<script type="math/tex; mode=display">
|X|=|G|^{p-1}=1+kp</script><p>与p||G|矛盾。</p>
<p>推论：有限群G是p群当且仅当|G|是p的幂次。</p>
<p>定理：如果$G\neq 1$是有限p群，那么它的中心$Z(G)\neq 1$。</p>
<p>推论：素数p，每个阶为$p^2$的群G都是阿贝尔群。（考察G/Z(G)易知）</p>
<p>定理：G是有限p群，如果H是G的真子群，那么$H&lt;N_G(H)$。</p>
<p>定理：G是有限p群，每个G的最大子群都是正规的，且序为p。（由上可知$N_G(H)=G$）</p>
<p>引理：如果有限p群G有$r_1$个阶为p的子群，那么$r_1=1\mod p$（证明：p阶元素central的mod p=-1，not central是p的幂次。$r_1(p-1)\cong -1\mod p$）</p>
<p>定理：有限p群G有$r_s$个阶为$p^s$的子群，那么$r_s\cong 1\mod p$</p>
<p>证明：H是阶为$p^s$的子群，K是阶为$p^{s+1}$的子群且包含H。那么由上定理可知N是K的正规子群，又由上述引理，这样的K个数a mod p = 1。又可以证明，K是阶为$p^{s+1}$的子群，K的$p^s$子群个数b mod p = 1。因此</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{r_s}a_i=\sum_{j=1}^{r_{s+1}}b_j</script><p>由此递归得证。</p>
<p>引理（Laudau，1903）：给定n&gt;0，有理数q，那么只有有限个n元正整数对满足$q=\sum_{j=1}^n(1/i_j)$</p>
<p>定理：给定n，只有有限多个有限群恰好有n个共轭类。（根据引理和共轭类分类定理可得）</p>
<p>定义：素数p，G的sylow p-子群是一个最大p-子群。</p>
<p>引理4.11：P是有限群G的一个sylow p-子群。那么</p>
<ul>
<li>$|N_G(P)/P|$和p互素</li>
<li>如果a是p的幂次阶元素，且$aPa^{-1}=P$，那么$a\in P$</li>
</ul>
<p>定理（Sylow，1872）：（sylow第二定理）如果P是有限群G的一个sylow p-子群，那么G的所有sylow p-子群和P共轭；（sylow第三定理）如果有r个sylow p-子群，那么r||G|，$r\cong 1\mod p$。</p>
<p>证明：定义X为G所有sylow p-子群的集合。定义G在X上的共轭作用，存在同态$\phi:G\to S_X$，定义为$\phi_a(P_i)=aP_ia^{-1}$。考虑sylow p-子群Q在X上的作用，那么X的所有轨道大小都是p的幂次。如果某个轨道大小为1，那么意味着$P_i=Q$。由此得到sylow第三定理。</p>
<p>推论：有限群G只有一个sylow p-子群P当且仅当P是正规子群。</p>
<p>定理：如果有限群G的阶为$p^em$，且$(p,m)=1$那么G的每个sylow p-子群阶为$p^e$。（根据引理4.11-1可得）</p>
<p>推论：如果有限群G，素数p，$p^k||G|$，那么G有一个阶为$p^k$的子群。</p>
<p>定理4.17（Wielandt的证明）：如果有限群G的阶为$p^em$，且$(p,m)=1$那么G有一个阶为$p^e$的子群。</p>
<p>证明：X是所有G的基数为$p^e$的子集的集合，显然p不能整除|X|。考虑G在X上的左乘作用，必有一个子集B满足|O(B)|不能被p整除。B的稳定化子$|G_B|=p^em’\geq p^e$。同时$|G_B|\leq |B|=p^e$，所以$|G_B|=p^e$。</p>
<p>定理4.18（Frattini Argument）K是有限群G的正规子群，如果P是K的sylow p-子群，那么$G=KN_G(p)$</p>
<p>定义：矩阵A是unitriangular，如果他是对角线为1的上三角矩阵。这样的的矩阵构成的群记为UT</p>
<p>定理：素数p，那么每个阶为2p的群G是循环群或者二面体群。</p>
<p>定理：素数p&gt;q，|G|=pg，那么G是循环群，或者G=<a,b>，满足$b^p=1,a^q=1,aba^{-1}=b^m$，且$m^q=1\mod p$，但$m\not\equiv 1 \mod p$。</p>
<p>推论：如果q不能整除p-1，那么G必然是循环群。</p>
<p>53</p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>王的日语笔记本</title>
    <url>/2020/02/21/japanese/</url>
    <content><![CDATA[<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><a id="more"></a>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>１　いち</p>
<p>２　に</p>
<p>３　さん</p>
<p>４　し／よん</p>
<p>５　ご</p>
<p>６　ろく</p>
<p>７　しち／なな</p>
<p>８　はち</p>
<p>９　く／きゅう</p>
<p>10　じゅう</p>
<p>100　ひゃく</p>
<p>1000 せん</p>
<p>0.1 れいてんいち</p>
<h2 id="亲属"><a href="#亲属" class="headerlink" title="亲属"></a>亲属</h2><p>父亲 おどうさん</p>
<p>母亲 おかあさん</p>
<p>爷爷 おじいさん</p>
<p>奶奶 おばあさん</p>
<h2 id="方位"><a href="#方位" class="headerlink" title="方位"></a>方位</h2><p>上 うえ</p>
<p>下　した</p>
<p>前　まえ　</p>
<p>后　うし</p>
<p>相邻　となり</p>
<p>中　なか</p>
<p>外　そと</p>
<h2 id="天气"><a href="#天气" class="headerlink" title="天气"></a>天气</h2><p>大雨 大雨（おおあめ）</p>
<p>小雨 小雨（こさめ）</p>
<p>夏天傍晚雷阵雨 夕立（ゆうだち）</p>
<p>骤雨 俄雨（にわかあめ）</p>
<p>梅雨 五月雨（さみだれ）</p>
<p>秋冬季的时雨 時雨（しぐれ）</p>
<p>大雪 大雪（おおゆき）</p>
<p>小雪 小雪（こゆき）</p>
<p>大风 大風（おおかぜ）</p>
<p>暴风 暴風（ぼうふう）</p>
<p>小风 小風（こかぜ）</p>
<p>微风 微風（そよかぜ）</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h3><p>周日 日曜日 にちようび</p>
<p>周一 月曜日　げつようび</p>
<p>周二 火曜日　かようび</p>
<p>周三 水曜日　すいようび</p>
<p>周四 木曜日　もくようび</p>
<p>周五 金曜日　きんようび</p>
<p>周六 土曜日　どようび</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>…时 じ</p>
<p>…分 ぶん</p>
<p>前天 おととい</p>
<p>昨天 きのう（昨日）</p>
<p>今日 きょう（今日）</p>
<p>明天 あした（明日）　</p>
<p>后天 あさって　</p>
<p>询问时间なんじ（几点）、いつ（什么时候）</p>
<p>…开始 时间+から</p>
<p>…结束 时间+まで</p>
<p>ごろ在时间后面，表大概</p>
<p>时间后面+過（す）ぎ 表示…过了</p>
<h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><h3 id="程度副词"><a href="#程度副词" class="headerlink" title="程度副词"></a>程度副词</h3><p>非常 とても／たいへん</p>
<p>一点儿　少（すこ）し／ちょっと</p>
<p>不太 あまり～ません</p>
<p>根本不 全然（ぜんぜん）～ません</p>
<p>正好 ちょうど</p>
<p>相当 ずいぶん</p>
<h3 id="频率副词"><a href="#频率副词" class="headerlink" title="频率副词"></a>频率副词</h3><p>总是 いつも</p>
<p>经常 よく</p>
<p>有时 時々（ときどき）</p>
<p>偶尔 たまに（偶に）</p>
<p>不太 あまり～ません</p>
<p>从不 ぜんぜん～ません</p>
<h3 id="其他副词"><a href="#其他副词" class="headerlink" title="其他副词"></a>其他副词</h3><p>好好地，也表示速度慢 ゆっくり</p>
<p>无意中 つい</p>
<h2 id="动词1"><a href="#动词1" class="headerlink" title="动词1"></a>动词1</h2><p><strong>ある</strong>，其否定形式为ありません，简体形的否定为ない</p>
<p>休息 やすみます</p>
<p>工作 はたらきます</p>
<p>开始 はじまります（始まります）</p>
<p>结束 おわります（終わります）</p>
<p>去 いきます</p>
<p>回来　かえり ます（帰ります）</p>
<p>学习 ならいます（習います）</p>
<p>かきます（書きます）</p>
<p>かきます（描きます）</p>
<p>かります（借ります）</p>
<p>かします（貸します）</p>
<h2 id="动词2"><a href="#动词2" class="headerlink" title="动词2"></a>动词2</h2><p>起床  おきます</p>
<p>睡觉 ねます（寝ます）</p>
<p>打（电话） かけます</p>
<p>足以　足ります（たります）</p>
<h2 id="动词3"><a href="#动词3" class="headerlink" title="动词3"></a>动词3</h2><p>学习 べんきようします（勉強します）</p>
<h2 id="形容词１"><a href="#形容词１" class="headerlink" title="形容词１"></a>形容词１</h2><p>简单的 やさしい（易しい）</p>
<p>难的 むずかしい（難しい）</p>
<p>无聊的 つまらない</p>
<p>有趣的 おもしろい（面白い）</p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>合起来   まとめて</p>
<h1 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h1><h2 id="疑问句"><a href="#疑问句" class="headerlink" title="疑问句"></a>疑问句</h2><p>问人用だれ，问东西用なん，问场所用どこ，</p>
<p>问价格用いくら，</p>
<p>询问时间なんじ（几点）、いつ（什么时候）</p>
<p>问怎么样用 どんな+名词　询问材料（内容）用なんの</p>
<p>询问对方意见どうですか，询问过去的事情どうでしだか，另一种询问方式いかがですか</p>
<p>询问原因 どうしてですか，完整的问题是どうして　～の／ん　ですか</p>
<p>多久 どの かかります</p>
<h2 id="词义辨析"><a href="#词义辨析" class="headerlink" title="词义辨析"></a>词义辨析</h2><p>建筑物的家用いえ，指家人用うち</p>
<p>刚刚，离现在很近たったいま，稍前一点用さっき</p>
<p>お湯（ゆ）指热水，水（みず）仅指凉水</p>
<p>三种店从大到小：馆 かん 店 てん 屋 や </p>
<p>从近到远これ、それ、あれ，修饰名词时要用この、その、あの，三个以上事物不能确定哪一个时用的疑问句どれ、どの</p>
<p>指示场所时用ここ、そこ、あそこ表示位置关系</p>
<p>声（こえ）是物体发出的声音，音（おと）是人/动物发出的声音。</p>
<p>間（ま）もなく和もう　すく都表示不久的意思，但前者更加书面</p>
<p>さらに和もっと都是更加的意思，前者更郑重</p>
<p>长期爱好是趣味（しゅみ），兴趣是興味（きょうみ）</p>
<h2 id="常用句子："><a href="#常用句子：" class="headerlink" title="常用句子："></a>常用句子：</h2><p>你好 こんにちは</p>
<p>早上好 おはよう</p>
<p>对不起 すみません</p>
<p>请 どうそ</p>
<p>请多关照 よろしく（おねがいします）</p>
<p>初次见面 はじめまして</p>
<p>是 そうです</p>
<p>不是 ちがいます</p>
<p>不知道 わかいますん</p>
<p>非常 どうも</p>
<p>感谢 （どうも）　ありがとう　ございます</p>
<p>对不起（搭话、提出请求的时候） あのう</p>
<p>表不确定 たしか</p>
<p>表正在思考 ええと</p>
<p>我先走了 お先（さき）に失礼（しつれい）します</p>
<p>离开（还要返回该处） いってまいります／いってきます（比较随便） 回答（去吧） いってらっしゃい</p>
<p>欢迎光临 いらっしゃいませ</p>
<p>请给我（点餐/购物时的） ～を　ください</p>
<p>明白了 かしこまりました</p>
<p>那么（接过话题或者中断谈话） じやあ</p>
<p>正合适 ちようど　いいです</p>
<p>转换话题 ところで</p>
<p>花费的钱或时间 かかいますか</p>
<p>赶快（暗示其他动作等一会） とりあえず</p>
<p>没错（口语） ちやんと</p>
<p>大丈夫   だいじょうぶ</p>
<p>根据…不同 ～に　よって</p>
<p>搭话（难以启齿的事情） あのう</p>
<p>打扰了（拜访别人） お邪魔（じゃま）します</p>
<p>太好了 よかったです</p>
<p>喜欢吗 気（き）に　入（い）りましたか</p>
<p>简体会话中，常有はい说成うん，いいえ说成ううん</p>
<p>感谢关照（分别的寒暄） お世話（せわ）に　なります。</p>
<p>向…问好 ～に　よろしく　お伝（つた）え　ください</p>
<p>请多保重 お元気で。</p>
<p>一路平安 お気を　つけて</p>
<h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><p>なん+量词+も+肯定形式 表示数量多</p>
<p>だいぶ 强调程度高（变化中）</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>と在两个名词中间，表示“和”，共同做某事的对象也用这个</p>
<p>や和と的差异在于と列举所有项目，や只用于许多项目中的两项。や常与など呼应。</p>
<p>か在名词之间，表示“或者”</p>
<p>は可以表对比或者强调（此时发音略重），此时可以单独使用加在名词后面，也可以加在助词后面构成复合形式</p>
<p>“何”根据后续音节不同，读音不同，基本读音是なに，但在助词の前面和量词前读なん，で前都可以　</p>
<p>たり表示列举：</p>
<ul>
<li>动词た形改为たり</li>
<li>一类形容词加かつたり(です)</li>
<li>二类形容词/名词加だつたり(です)</li>
</ul>
<p>小句+か表示不确定</p>
<ul>
<li>不包含疑问的疑问句：将动词、一类形容词变为简体形+か　どうか</li>
<li>疑问词小句+か</li>
</ul>
<p>（人/物+は）+小句（必须是简体形）+と+</p>
<ul>
<li>思（おも）います 想…</li>
<li>言（い）います 说…</li>
</ul>
<p>～のです／んです 表示所讲的内容与前句有关，包括解释情况等。前者更正式。</p>
<p>～に　ついて 关于…</p>
<p>あまり+否定形式 表示程度不高</p>
<p>名词+のところ 表示…的附近，把不是场所的名词变成场所</p>
<p>形式主语の</p>
<h2 id="句末语气词"><a href="#句末语气词" class="headerlink" title="句末语气词"></a>句末语气词</h2><p>句末+ね 表示征求同意或者同意对方的提议</p>
<p>句末+よね 对自己想法没有足够把握的时候的提议</p>
<p>よ在句末用来表示提醒，读升调　</p>
<p>+か 表示提问，也是应答时常用的说法</p>
<p>+が 而不把话说完显得委婉含蓄</p>
<p>二类形容词/名词+よ 一般是女性用</p>
<p>+わ 一般是女性用</p>
<p>+でしたね　用于表示确认</p>
<h2 id="连词语法"><a href="#连词语法" class="headerlink" title="连词语法"></a>连词语法</h2><p>那么（中断谈话） では／じゃあ（不正式）</p>
<p>所以 ですから／だから（不正式）</p>
<p>表转折 でも</p>
<p>表转折 けど</p>
<p>表并列 そして</p>
<p>表“正如所料”  やはり（日常可用 やっぱり）</p>
<p>建议(口语) さあ</p>
<p>表铺垫/转折 小句+が，小句</p>
<h2 id="助词语法"><a href="#助词语法" class="headerlink" title="助词语法"></a>助词语法</h2><ul>
<li>は：是…，在…</li>
<li>で：用…方式，在…地点，动作的场所、工具、手段、原材料+で+动词</li>
<li>が：<em>自动词</em>的宾语，或者表示<em>能力</em></li>
<li>に：在…时间/地点，也表收付关系宾语的人</li>
<li>を：<em>他动词</em>的宾语，名词（动作的对象）+を+动词，这里读作お，如果前面名词作话题时用は</li>
<li>も：代替は的位子，相当于“也是”，另外，疑问词+も+动词（否定）表示全面否定</li>
<li>から：从…，也可表示原因</li>
<li>へ：去….</li>
<li>より：比较的基准，空间/时间的起点</li>
<li>かな：原本只用于自言自语，也用来表明信息不准确</li>
<li>の：用于要求说明或确认</li>
</ul>
<p>表物体存在的两种用法</p>
<ul>
<li>（场所）には（物/人）が　あります／います</li>
<li>（物/人）は（场所）に　あります／います</li>
</ul>
<p>表示动作时间的</p>
<ul>
<li><p>时间+に+动词</p>
</li>
<li><p>时间+から+时间+まで+动词（持续时间）</p>
</li>
<li>表示时间数量的词语和动词一起使用，中间不加に</li>
</ul>
<p>表示移动动词时的用法</p>
<ul>
<li>场所+へ/に+动词 去哪儿</li>
<li>场所+から+动词 从哪来</li>
<li>场所+から+场所+まで+动词 从哪到哪</li>
<li>交通工具+で+动词 </li>
<li>场所+へ+动词（干什么）+に+动词 去哪儿干什么，移动行为目的的动词去掉ます</li>
<li>场所+を+动词 经过哪儿</li>
</ul>
<p>给予东西的表达</p>
<ul>
<li>名1（人）+は+名2（人）+に+名3（物）+を+あげます　表示1给2物品3</li>
<li>名1（人）+は+名2（人）+に+名3（物）+を+もらいます　表示1得到2的物品3</li>
</ul>
<p>名词（主体）+は+名词（对象）+が+わかります／できます 会/不会做某事</p>
<p>名词（主体）+は+名词（对象）+が+ほしいです 想要什么</p>
<p>名词（主体）+は+名词（对象）+を+动词基本形+たいです 想要干什么（有时也用が）</p>
<p>みんな＋で 表示动作主体的状态</p>
<h2 id="动词语法"><a href="#动词语法" class="headerlink" title="动词语法"></a>动词语法</h2><p>动词+ます／ません</p>
<p>动词+ました／ませんでした（过去时）</p>
<p>三类动词：</p>
<ul>
<li>ます形去掉ます后，最后一个音位于い段的动词绝大部分属于一类；</li>
<li>最后一个音位于え段的和少部分位于い段（初级大约15个）的属于第二类；</li>
<li>来ます和します<em>结尾</em>的动词属于第三类。汉字/外来词+します构成新的单词。</li>
</ul>
<p><strong>动词て形</strong></p>
<p>一类动词“て形”变换方式是去掉ます加て时，发音会有一些变化。</p>
<p>き变いて或いで，ひみに变んで，ちりい变って，し变して</p>
<p>二类和三类动词的“て形”变换方式是去掉ます直接加て。</p>
<p>动词て形+动词 表示相继发生（也可以用 动词て形+から+动词，但から只能在一个句子里用一次）</p>
<p>动词て形+ください 请某人做某事</p>
<p><u>动词て形+います 正在进行，或者结果状态（类似于认识、有这样的动词）</u></p>
<p>动词て形+も+いいます 表示许可</p>
<p>动词て形+は+いけません 表示禁止</p>
<p>（提问方式　～ても　いいですか）</p>
<p>まだ+动词否定 相当于还没有</p>
<p>动词将ます换成ましょう表示提议、也可用于回应提议</p>
<p><strong>动词ない形</strong></p>
<p>一类动词“ない形”变换方式是去掉ます最后一个音变相应的あ段音，然后加ない（注意い变成わ）。二、三类动词去掉ます直接加ない。</p>
<p>动词ない形+で+ください 表示否定的命令</p>
<p>动词ない形换成なければ　なりません表示必须（口语也可以用ないと　いけません，常省略为ないと）</p>
<p>动词ない形换成なくても+いいです表示不做也可以</p>
<p><strong>动词基本形</strong></p>
<p>一类动词的基本形最后发音变为う段</p>
<p>二、三类动词基本形为去掉ます加る（します变为する）</p>
<p><em>动词基本形+こと起到和名词相同的作用</em></p>
<p>名词/人+は+动词基本形+ことが　できます 询问允许或者可以吗（回答用できます／できません）</p>
<p>名词+は+动词基本形+こと　です 谓语是一种动作时使用</p>
<p>动词基本形+まえに、～　动作发生在另一个动作之前</p>
<p><strong>动词た形</strong></p>
<p>就是动词て形的て改为た，で改为だ</p>
<p>动词た形+ことが　あります 经历过（过去式）</p>
<p>动词た形+後（あと）で、～　动作发生在另一个动作之后</p>
<p>动词た形+ほうが　いいです 用于两种事物选择（否定用动词ない形）</p>
<p>动词+ましょうか　提议</p>
<p>动词ます形去掉ます加上かた就是“~的方法”的意思。</p>
<p>动词+たり用来列举：动词+たり 动词+たり します</p>
<p><strong>其他动词语法</strong></p>
<p>动词+ませんか 表面是疑问，实际是提议</p>
<p>动词ます形去掉ます加上方（かた）是“~的方法”的意思</p>
<p>表示某个动作进行用  ～中（ちゅう）</p>
<p>动词（简体形）+名词/小句（动词简体形）+名词 用来修饰名词</p>
<h2 id="形容词语法"><a href="#形容词语法" class="headerlink" title="形容词语法"></a>形容词语法</h2><p>形容词分两类，<strong>一类是以 い结尾</strong>，做<em>谓语</em>要加です</p>
<p>名+は+一类形容词+です</p>
<p>他的否定形式是将词尾的い变成く，再加上ないです或者ありません</p>
<p>过去式是将词尾的い变为かつた，再加です</p>
<p>过去形式的否定式是将词尾的い变成く，再加上ないつたです或者ありませんした</p>
<p>一类形容词可以直接<em>修饰名词</em></p>
<p><strong>第二类是不以 い结尾</strong>，做<em>谓语</em>要加です，过去式是加でした</p>
<p>否定形式是＋では　ありません</p>
<p>过去式的否定形式+ では　ありませんでした</p>
<p><em>修饰名词</em>时： 形容词+な+名词</p>
<p><u>形容词修饰名词时可以用 形容词+の 指代名词</u></p>
<p><strong>表达情感的形容词</strong>（如喜欢等）</p>
<p>名词（主体）+ は+名词（对象）+が+形容词+です</p>
<p><strong>比较</strong></p>
<p>名词（主体）+ は+名词（对象）+より+形容词+です（主体比对象更XX）</p>
<p>名词（主体）+ より+名词（对象）+の　ほうが+形容词+です（相比主体，对象更XX）</p>
<p>名词（主体）+ は+名词（对象）+ほど+形容词否定形式（主体不如对象XX） </p>
<p>ほうが …比较…　（ほうが　いいです表示建议）</p>
<p>いちばん最高级</p>
<p>提问：名词+と+名词+と+どちらが+形容词+ですか（どちら 哪个）</p>
<p>回答：名词+の+ほうが+形容词，两者相当则用どちらも　～です</p>
<p>问形容词时回答：形容词+ほうが+いいです</p>
<p><strong>形容词连用</strong></p>
<p>形容词て形+形容词 表并列（一类去掉い加くて，二类加で）</p>
<p><strong>形容词表示变化</strong></p>
<p>一类形容词去掉い+く+なります／します（后者是由于主观动作引起的变化）</p>
<p>二类形容词/名词+に+なります／します</p>
<h2 id="量词语法"><a href="#量词语法" class="headerlink" title="量词语法"></a>量词语法</h2><p>量词用在动词前面 </p>
<p>名词+が／を+数量+量词+动词</p>
<p>数量+量词+で+500円（1个时不加）</p>
<p>数量的词后面+くらい／ぐらい 表示大概</p>
<p>还有省去量词直接用３つ的</p>
<h2 id="名词语法"><a href="#名词语法" class="headerlink" title="名词语法"></a>名词语法</h2><p>名词做谓语的时候加です，过去式是加でした</p>
<p>否定形式是＋では　ありません</p>
<p>过去式的否定形式+ では　ありませんでした</p>
<p>下面两种方式等价，名词1是旧信息，名词2是新信息</p>
<p>名词1+は+名词2+です</p>
<p>名词2+が+名词1+です</p>
<p>动词（简体形）+名词/小句（动词简体形）+名词 用来修饰名词</p>
<p>小句（一类形/二类形/名）+名词 也可以修饰名词</p>
<h2 id="礼貌用语"><a href="#礼貌用语" class="headerlink" title="礼貌用语"></a>礼貌用语</h2><p>对应该尊敬的对象或者交往不多的人，会将この人后面的人（ひと）变为方（かた）</p>
<p>ここ、そこ、あそこ、どこ的礼貌用语こちら、そちら、あちら、どちら</p>
<p>なかなか还不错，只能用于对下级</p>
<p>ください（＋ませんか）表达请求</p>
<p>…の　件（けん）　…一事，正式说法</p>
<h2 id="敬体形和简体形"><a href="#敬体形和简体形" class="headerlink" title="敬体形和简体形"></a>敬体形和简体形</h2><p>动词～ます／～です都是敬体形，用于对长辈或不亲密的人。动词的基本形、ない形、た形都属于简体形。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>敬体形</th>
<th>简体形</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在将来形式</td>
<td>肯定</td>
<td>～ます</td>
<td>う段和る（基本形）</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～ません</td>
<td>あ段+ない（ない形）</td>
</tr>
<tr>
<td>过去形式</td>
<td>肯定</td>
<td>～ました</td>
<td>て形变化+た（た形）</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～ませんでした</td>
<td>あ段+なかった（なかった形）</td>
</tr>
</tbody>
</table>
</div>
<p>一类形容词、二类形容词和名词本身没有敬体形和简体形之分，<strong>只有作谓语的时候</strong></p>
<p>一类形容词（い结尾）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>敬体形</th>
<th>简体形</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在将来形式</td>
<td>肯定</td>
<td>～いです</td>
<td>～い</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～く　ないです</td>
<td>～く　ない</td>
</tr>
<tr>
<td>过去形式</td>
<td>肯定</td>
<td>～かったです</td>
<td>～かった</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～く　なかったです</td>
<td>～く　なかった</td>
</tr>
</tbody>
</table>
</div>
<p>二类形容词：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>敬体形</th>
<th>简体形</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在将来形式</td>
<td>肯定</td>
<td>～です</td>
<td>～だ</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～では　ありません</td>
<td>～では　ない</td>
</tr>
<tr>
<td>过去形式</td>
<td>肯定</td>
<td>～でした</td>
<td>～だった</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～では　ありませんでした</td>
<td>～では　なかった</td>
</tr>
</tbody>
</table>
</div>
<p>名词和二类形容词一样</p>
<ul>
<li>简体疑问省略敬体的ですか，读升调。</li>
<li>かな和の这两个助词只用在简体形后面</li>
</ul>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Language</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化问题-应用和算法</title>
    <url>/2020/02/21/ConvexOptimization2/</url>
    <content><![CDATA[<p><a href="/2020/02/14/ConvexOptimization/">上一篇：凸优化问题</a></p>
<h3 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h3><h4 id="逼近和拟合"><a href="#逼近和拟合" class="headerlink" title="逼近和拟合"></a>逼近和拟合</h4><p>范数逼近</p>
<script type="math/tex; mode=display">
min\:||Ax-b||</script><p>罚函数逼近（$l_p$-范数的一个有用的推广）</p>
<script type="math/tex; mode=display">
min\:\sum\phi(r_i)\\
subject\:to\:r=Ax-b</script><p>对<strong>野值</strong>不敏感的函数称为<strong>鲁棒</strong>的。当限定为凸的罚函数时，最不敏感的就是线性增长函数。例子就是绝对值函数和<strong>Huber罚函数</strong>。</p>
<p>基本问题</p>
<script type="math/tex; mode=display">
min\:||x||\\
subject\:to\:Ax=b</script><p>这是个凸优化问题。</p>
<a id="more"></a>
<p>正则化逼近：</p>
<script type="math/tex; mode=display">
min\:||Ax-b||+\gamma||x||</script><p><strong>Tikhonov正则化</strong>：</p>
<script type="math/tex; mode=display">
min\:||Ax-b||_2^2+\delta||x||_2^2</script><p>有解析解</p>
<script type="math/tex; mode=display">
x=(A^TA+\delta I)^{-1}A^Tb</script><p>重构、光滑、去噪声：</p>
<script type="math/tex; mode=display">
min\:(||x-x_{cor}||_2,\phi(x))</script><p><strong>函数拟合与插值</strong>：</p>
<p>考虑一族函数，通过</p>
<script type="math/tex; mode=display">
f(u)=\sum_{i=1}^nx_nf_n(u)</script><p>将x与映射$f:R^M\to R$联系起来。</p>
<p>另外还有插值<strong>条件约束</strong>，或者插值的不等式约束。以及对f的凸约束，比如Lipschitz约束。</p>
<p><strong>基筛选</strong>中寻找较少数目的基函数，使得能够在card(x)很小的情况下进行拟合。称为<strong>稀疏描述</strong>。</p>
<h4 id="统计估计"><a href="#统计估计" class="headerlink" title="统计估计"></a>统计估计</h4><p>最大似然问题可以表述如下</p>
<script type="math/tex; mode=display">
max\:l(x)=log(p_x(y))\\
subject\:to\:x\in C</script><p>Chebyshev界：我们希望给$prob(X\in C)$定界，假设$f(z)\geq 1_C(z)$，那么可以求解凸优化问题</p>
<script type="math/tex; mode=display">
min\:x_o+\sum a_ix_i\\
subject\:to\:f(z)=\sum x_if_i(z)\geq1\:\forall z\in C\\
f(z)=\sum x_if_i(z)\geq0\:\forall z\notin C</script><p>Chernoff界：定义为$prob(X\geq u)\leq inf_{\lambda\geq 0}Ee^{\lambda(X-u)}$同样得到</p>
<script type="math/tex; mode=display">
log(prob(X\in C))\leq\mu+logEe^{\lambda^Tx}</script><p>（这里略过数章…）</p>
<h3 id="无约束优化算法"><a href="#无约束优化算法" class="headerlink" title="无约束优化算法"></a>无约束优化算法</h3><script type="math/tex; mode=display">
min\:f(x)</script><p>其中$f$二次可微凸函数。那么最优点应该满足一阶导数为0，我们需要通过迭代求解。首先需要一个适当的初始点$x_0$，且$f(x_0)$下水平集必须是闭集。（下水平集的形状影响收敛速度）</p>
<p>我们假设目标函数是<strong>强凸</strong>的，即存在m&gt;0，满足$\nabla^2 f(x)\succeq mI$。（好处是梯度足够小的点都可以计算得到近似最优解。）</p>
<p>通用下降方法：确定下降方向；选择步长；修改x。</p>
<p>利用负梯度作为搜索方向是一种自然的选择，称为<strong>梯度下降法</strong>。</p>
<p>我们假设强凸，因此存在$mI\preceq \nabla^2f(x)\preceq MI$，那么可以得到上界</p>
<script type="math/tex; mode=display">
f(t)\leq f(x)-t||\nabla f(x)||_2^2+\frac{Mt^2}{2}||\nabla f(x)||_2^2</script><p>采用<strong>精确直线搜索</strong>的话，右边的最小值为$f(x)-(1/2M)||\nabla f(x)||_2^2$，所以</p>
<script type="math/tex; mode=display">
f(x^+)-p^*\leq (1-m/M)(f(x)-p^*)</script><p>因此是<strong>线性收敛</strong>的。事实上，即使是<strong>回溯直线搜索</strong>，满足$0\leq t\leq 1/M$，也可以达到<strong>线性收敛</strong>。</p>
<p><strong>最速下降方法</strong>是通过定义<strong>规范化的最速下降方向</strong>，即找到</p>
<script type="math/tex; mode=display">
\Delta x_{nsd}=argmin\{\nabla f(x)^Tv|||v||=1\}</script><p>上面范数取Euclid范数时即为梯度下降，采用二次范数$||·||_P$时，$\Delta x_{nsd}=-(\nabla f(x)^TP^{-1}\nabla f(x))^{-1/2}P^{-1}\nabla f(x)$。</p>
<p><strong>Newton方法</strong>：$\Delta x_{nt}=-\nabla^2 f(x)^{-1}\nabla f(x)$，这其实等价于Hessian矩阵定义的二次范数下的最速下降方法</p>
<p>可以表明，Newton方法的迭代过程分为两个阶段，第一阶段称为<strong>阻尼Newton阶段</strong>，步长t&lt;1，线性收敛速度，第二阶段为<strong>纯Newton阶段</strong>，步长t=1，二次收敛速度。</p>
<p><strong>自和谐函数</strong>的Newton方法分析不依赖未知常数（强凸性常数、李普西茨常数），且具有仿射不变性。</p>
<p>定义凸函数$f:R\to R$满足对所有x</p>
<script type="math/tex; mode=display">
|f'''(x)|\leq 2f''(x)^{3/2}</script><p>就是<strong>自和谐</strong>的。常数2可以被任何常数k替代。这个条件可以写成</p>
<script type="math/tex; mode=display">
|\frac{d}{dt}(f''(t)^{-1/2})|\leq1</script><p>由此得到$f’’(t)$的上下界</p>
<script type="math/tex; mode=display">
\frac{f''(0)}{(1+tf''(0)^{1/2})^2}\leq f''(t)\leq \frac{f''(0)}{(1-tf''(0)^{1/2})^2}</script><p>由此可以得到次优性的界。</p>
<p><strong>共轭梯度法</strong>：每次下降要求梯度在共轭空间里</p>
<p>定义$\alpha,\beta$Q-共轭为$\alpha^TQ\beta = 0$</p>
<p>每次计算</p>
<script type="math/tex; mode=display">
g^{k+1}=\nabla f(x^{k+1})\\
d^{k+1}=-g^{k+1}+\beta_kd^k=-g^{k+1}+\frac{(g^{k+1})^TQd^k}{(d^k)^TQd^k}d^k\\
x^{k+2}=x^{k+1}+\alpha_{k+1}d^{k+1}=x^{k+1}-\frac{(g^{k+1})^Td^{k+1}}{(d^{k+1})^TQd^{k+1}}d^{k+1}</script><p>对二次式$f(x)=\frac12 x^TQx-b^Tx$进行优化时可以证明$d^i$是Q-共轭的，因而</p>
<script type="math/tex; mode=display">
(g^{k+1})^Td^i=0</script><p>根据这个式子，</p>
<script type="math/tex; mode=display">
\beta_k=\frac{(g^{k+1})^Tg^{k+1}}{(g^k)^Tg^k}</script><p>$\alpha_k$可以通过线性搜索得到。以此避免计算Hessian矩阵。</p>
<p><strong>Quasi-Newton</strong></p>
<p>用$H^K$来拟合$F(X^k)^{-1}$</p>
<script type="math/tex; mode=display">
d^k=-H_kg^k\\
\alpha_k=\arg\min_\alpha f(x^k+\alpha d^k)\\
x^{k+1}=x^k+\alpha_k d^k</script><p>对$H_k$的更新有三种</p>
<ul>
<li>Rank One Correction</li>
<li>Davidon-Fletcher-Powell（DFP）</li>
<li>Broyden-Fletcher-Goldfarb-Shanno（BFGS）</li>
</ul>
<h3 id="等式约束优化"><a href="#等式约束优化" class="headerlink" title="等式约束优化"></a>等式约束优化</h3><script type="math/tex; mode=display">
\min f(x)\\s.t. Ax=b</script><p>考虑二阶Taylor近似</p>
<script type="math/tex; mode=display">
\min f(x+v)=f(x)+\nabla f(x)^Tv+(1/2)v^T\nabla^2f(x)v\\
s.t.A(x+v)=b</script><p><strong>Newton方向</strong>$\Delta x_{nt}$由以下方程确定</p>
<script type="math/tex; mode=display">
\begin{pmatrix}\nabla^2f(x)&A^T\\A&0\end{pmatrix}\begin{pmatrix}\Delta x_{nt}\\w\end{pmatrix}=\begin{pmatrix}-\nabla f(x)\\0\end{pmatrix}</script><p>对于<strong>不可行初始点</strong>的newton方向，</p>
<script type="math/tex; mode=display">
\begin{pmatrix}\nabla^2f(x)&A^T\\A&0\end{pmatrix}\begin{pmatrix}\Delta x_{nt}\\w\end{pmatrix}=\begin{pmatrix}-\nabla f(x)\\b-Ax\end{pmatrix}</script><h3 id="线性规划问题的解法"><a href="#线性规划问题的解法" class="headerlink" title="线性规划问题的解法"></a>线性规划问题的解法</h3><p><strong>Primal单纯形法</strong></p>
<p>对于线性规划</p>
<script type="math/tex; mode=display">
min\:c^Tx\\
s.t.\:Ax=b\\
x\geq 0</script><p>和对偶问题</p>
<script type="math/tex; mode=display">
max\:b^Ty\\
s.t.\:A^Ty+s=c\\
s\geq 0</script><p>得到KKT条件</p>
<script type="math/tex; mode=display">
Ax=b,x\geq 0\\
A^Ty+s=c,s\geq 0\\
x_is_i=0</script><p>Primal单纯形法得到</p>
<script type="math/tex; mode=display">
x_B=B^{-1}b\geq 0,x_N=0\\
y=B^{-T}c_B\\
s_B=c_B-B^Ty=0,s_N=c_N-N^Ty？？0</script><p>（B是一个基，N是自由基）然后判断$s_N$和0的大小关系，决定是否停止迭代。如果$s_j\geq 0$那么x是最优解，否则可以找到q，$s_q&lt;0$。那么就找到$p\in B$移出基。</p>
<p>令$u=B^{-1}A_q$，那么$x_B^+=x_B-ux_q^+$。如果$u\leq 0$则原问题无界；否则找到$u_k&gt;0$，就可以找到$x_q^+$和$p$满足$ x_B^+\geq 0$和$x_p^+=0，确定</p>
<script type="math/tex; mode=display">
p=argmin\frac{x_B(i)}{u_i}</script><p><u>单纯形法工业级应用还需要解决很多问题，比如快速求逆、防止循环迭代等等。</u></p>
<p><strong>对偶单纯形法</strong></p>
<script type="math/tex; mode=display">
x_B=B^{-1}b？？0,x_N=0\\
y=B^{-T}c_B\\
s_B=c_B-B^Ty=0,s_N=c_N-N^Ty\geq 0</script><p> 如果$x_B\geq 0$，则达到最优，否则找到$q\in B$使得$x_q&lt;0$退出基，选择r加入基，$s_r^+=0$。然后进行更新：</p>
<script type="math/tex; mode=display">
s_B^+=s_b+ae_q\\
y^+=y+av(e_q=-B^Tv)</script><p><u>对偶单纯形法和单纯形法有时候速度差距很大。</u></p>
<p><strong>内点法</strong></p>
<p>$(x,y,s)$为当前估计，$(\Delta x,\Delta y,\Delta s)$是搜索方向，定义$\mu=\sum x_is_i/n$。所以要找到</p>
<script type="math/tex; mode=display">
A(x+\Delta x)=b\\
A^T(y+\Delta y)+s+\Delta s=c\\
(x_i+\Delta x_i)(s_i+\Delta s_i)=\sigma_\mu</script><p>舍弃二阶小量得到</p>
<script type="math/tex; mode=display">
A\Delta x=r_p:=b-Ax\\
A^T\Delta y+\Delta s=r_d:=c-A^Ty-s\\
x_i\Delta s_i+\Delta x_is_i=(r_c)_i:=\sigma_\mu-x_is_i</script><p>写成矩阵形式如下，令$L_x=Diag(x)$，$L_s=Diag(s)$</p>
<script type="math/tex; mode=display">
\begin{pmatrix}A&0&0\\
0&A^T&I\\
L_s&0&L_x\end{pmatrix}
\begin{pmatrix}\Delta x\\
\Delta y\\
\Delta s\end{pmatrix}
=
\begin{pmatrix}r_p\\
r_d\\
r_c
\end{pmatrix}</script><p>如果A满秩，$AL_s^{-1}L_xA^T$是对称正定的，可以解得到</p>
<script type="math/tex; mode=display">
\Delta y=(AL_s^{-1}L_xA^T)^{-1}(r_p+AL_s^{-1}(L_xr_d-r_c))\\
\Delta s = r_d-A^T\Delta y\\
\Delta x = -L_s^{-1}(L_x\Delta s-r_c)</script><p>然后进行步长搜索，保证$(x^{k+1},s^{k+1})&gt;0$。</p>
<p><u>步长搜索用Central Path，具体定义如下：</u> $C=\{(x_\tau,y_\tau,s_\tau|\tau&gt;0\}$满足</p>
<script type="math/tex; mode=display">
Ax_\tau=b,x_\tau>0\\
A^Ty_\tau+s_\tau=c,s_\tau>0\\
(x_\tau)_i(s_\tau)_i=\tau</script><p>Central Path neighborhoods是对$\theta,\gamma\in[0,1)$：</p>
<script type="math/tex; mode=display">
N_2(\theta)=\{(x,y,s)|||L_xL_se-\mu e||_2\leq\theta\mu\}\\
N_{-\infty}(\gamma)=\{(x,y,s)|x_is_i\geq\gamma\mu\}</script><p>一般而言$\theta=0.5$，$\gamma=10^{-3}$。</p>
<p>Path-Following：设定步长$\alpha_k$为最大的满足$(x^{k+1},y^{k+1},s^{k+1})\in N_{-\infty}(\gamma)$的值。那么$|\Delta x\cdot\Delta s|\leq 2^{-3/2}(1+1/\gamma)n\mu$，更新</p>
<script type="math/tex; mode=display">
\mu_{k+1}\leq(1-\delta/n)\mu_k,\delta=2^{3/2}\gamma\frac{1-\gamma}{1+\gamma}\sigma(1-\sigma)</script><p>那么如果$(x^0,y^0,s^0)\in N_{-\infty}(\gamma)$，存在$K=O(nln(1/\epsilon))$使得$\mu_k\leq\epsilon\mu_0$</p>
<p><u>内点法是很少见的多项式时间算法</u></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>随机过程论</title>
    <url>/2020/02/18/StochasticProcess/</url>
    <content><![CDATA[<h1 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h1><p>给定概率空间$(\Omega,F,P)$，随机变量X，定义随机变量$Y=E(X|F)$如果它满足</p>
<ul>
<li>$Y\in F$</li>
<li>for all $A\in F$，$\int_A XdP = \int_A YdP$</li>
</ul>
<p>显然Y可积且唯一</p>
<p><strong>Radon-Nikodym定理</strong>：测度$\nu &lt;&lt;\mu$，那么存在函数$f\in F$，对所有$A\in F$，</p>
<script type="math/tex; mode=display">
\int_A fd\mu=\nu(A)</script><p>先假设$X\geq 0$然后显然$\nu(A)=\int_A XdP$是测度，所以易证条件期望存在。</p>
<a id="more"></a>
<p>几个例子（小污猫说“这几个例子很重要”）</p>
<ul>
<li><p>$X\in F$，那么$E(X|F)=X$</p>
</li>
<li><p>$X$与$F$独立，则$E(X|F)=EX$</p>
</li>
<li><p>$F=\sigma(\Omega_1,\Omega_2,…)$，则$E(X|F)=\frac{E(X;\Omega_i)}{P(\Omega_i)}\:on\:\Omega_i$。所以初等概率论里的条件期望是其一个特例。</p>
</li>
<li><p>$X$，$Y$有联合概率密度$f(x,y)$，则</p>
<script type="math/tex; mode=display">
E(g(X)|Y)=h(Y)=\frac{\int g(x)f(X,y)dx}{\int f(X,y)dx}</script></li>
<li><p>$X$，$Y$独立，$E(\phi(X,Y)|X)=E(\phi(x,Y))$</p>
</li>
</ul>
<p>性质：</p>
<ul>
<li>$E(aX+Y|F)=aE(X|F)+E(Y|F)$</li>
<li>$X\leq Y\Rightarrow E(X|F)\leq E(Y|F)$</li>
<li>$X_n\geq 0$，$X_n\uparrow X$，$EX&lt;\infty$，那么$E(X_n|F)\uparrow E(X|F)$（Levi单调收敛定理）</li>
<li>$X_n\geq 0$，$E(lim_{n\to\infty}X_n|F)\leq lim_{n\to\infty}E(X_n|F)$（Fatou引理，由lim xn=lim inf xk）</li>
<li>$|X_n|&lt;Y&lt;\infty$，$lim_{n\to\infty}X_n=X$，那么$lim_{n\to\infty}E(X_n|F)=E(X|F)$（Lebesgue控制收敛定理）</li>
<li>如果$\phi$凸，则$\phi(E(X|F))\leq E(\phi(X)|F)$（Jensen不等式，直线显然，然后利用直线包络）</li>
<li>$F\subset G$，且$E(X|G)\in F$，那么$E(X|F)=E(X|G)$</li>
<li>$F\subset G$，那么$E(E(X|F)|G)=E(E(X|G)|F)=E(X|F)$（条件期望平滑性）</li>
</ul>
<p>如果$X\in F$且$E|X|\:,\:E|XY|&lt;\infty$，那么$E(XY|F)=XE(Y|F)$。（典型four-step的证明）</p>
<h2 id="正则条件概率："><a href="#正则条件概率：" class="headerlink" title="正则条件概率："></a>正则条件概率：</h2><p>可测映射$X\::\:(\Omega,F)\rightarrow (S,S)$（随机变量）。for X given G，<strong>正则条件分布</strong>$\mu\::\:\Omega\times S\rightarrow [0,1]$满足</p>
<ul>
<li>对每个A，$\omega\rightarrow\mu(\omega,A)$是$P(X\in A|G)$的一个版本</li>
<li>对a.e. $\omega$，$A\rightarrow\mu(\omega,A)$是一个$(S,S)$上的测度。</li>
</ul>
<p>如果$S=\Omega$，X是恒等映射，$\mu$是<strong>正则条件概率</strong>。（此时$\mu(A)=PX^{-1}(A)=P(X\in A)$）</p>
<p>正则条件分布可以<strong>同时计算X的所有函数的条件期望</strong>。</p>
<p>由$E(f(x))=\int_R f(x)dPX^{-1}$可得</p>
<p>定理：$\mu(\omega,A)$是<strong>正则条件分布</strong>，$f:(S,S)\rightarrow (R,R)$，且$E|f(X)|&lt;\infty$，那么f关于测度$\mu(\omega,·)$的积分存在，且</p>
<script type="math/tex; mode=display">
E(f(x)|F)(\omega)=\int \mu(\omega,dx)f(x)\:a.s.</script><p>正则条件分布并不总是存在。但是当$(S,S)$ <strong>is nice</strong>的时候，它总是存在。(定义：<strong>好的可测空间是指标准Borel空间</strong>，即存在从$S\to R$的一一可测映射。若S是<strong>Polish空间（完备+可分）的Borel子集</strong>，S是S上Borel $\sigma$域，那么是一个好的可测空间）</p>
<p>证明：设$\phi:S\to R$是一一可测映射。则$\phi(X):(\Omega,F)\to(R,R)$，那么，$\forall A\in S$</p>
<script type="math/tex; mode=display">
P(X\in A|G)=P(\phi(X)\in\phi(A)|G)\\
=P(Y\in\phi(A)|G)=P(Y\in B|G)\\
(B=\phi(A)\in R)</script><p>然后构造$Y=\phi(x)$关于G的正则条件分布函数$P(Y\leq y|G)$：取除掉一个零测集以外的集合$\Omega_0$使得任意$\omega\in\Omega_0$</p>
<script type="math/tex; mode=display">
G(q,\omega)=P(Y\leq q|G)(\omega)</script><p>然后$F(x,\omega)=inf\{G(q,\omega),q&gt;x\}$。所以$F(x,\omega)$是$P(\phi(X)\leq x|G)$的一个版本。然后得到度量$\nu(\omega,·)$</p>
<script type="math/tex; mode=display">
\nu(w,(-\infty,x])=F(x,\omega)</script><p>然后得到$\mu(\omega,A)=\nu(\omega,\phi(A))$</p>
<p>定理：X，Y在<strong>nice space</strong> (S,S)中取值，$G=\sigma(Y)$，那么存在$\mu\::\:S\times S\rightarrow [0,1]$，</p>
<ul>
<li>对每个A，$\mu(Y(\omega),A)$是$P(X\in A|G)$</li>
<li>对a.e. $\omega$，$A\rightarrow\mu(Y(\omega),A)$是$(S,S)$上的测度</li>
</ul>
<h1 id="鞅过程Martingales"><a href="#鞅过程Martingales" class="headerlink" title="鞅过程Martingales"></a>鞅过程Martingales</h1><p>$F_n$是一个递增的$\sigma$-域序列，如果序列$X_n$满足</p>
<ul>
<li>$E|X_n|&lt;\infty$</li>
<li>$Xn\in F_n$</li>
<li>$E(X_{n+1}|F_n)=x_n$</li>
</ul>
<p>则称$X_n$为<strong>鞅过程</strong>。</p>
<p>如果第三个条件改为$E(X_{n+1}|F_n)\geq(\leq) X_n$，则称为<strong>下鞅（上鞅）</strong></p>
<p>最常见的是线性鞅：$S_n=S_0+\sum_{k=1}^n e_k$，$E(e)=0$。如果$E(e)\leq(\geq)0$，则为上鞅（下鞅）。</p>
<p>定理：鞅过程满足$E(X_n|F_m)=X_m$，$m&lt;n$</p>
<p>定理：凸函数$\phi$，那么$\phi(X_n)$下鞅。即$E(\phi(X_{n+1})|F_n)\geq \phi(E(X_{n+1}|F_n))=\phi(X_n)$。如果$X_n$下鞅，$\phi$增也有此结论。</p>
<p>定义$H_n$为<strong>可预测序列</strong>，即$H_n\in F_{n-1}$。定理：$X_n$上鞅，那么如果$H_n\geq 0$有界，则$(H\cdot X)_n$也是上鞅。显然对下鞅和鞅也有类似结论。</p>
<p>定理：若N是停时，$X_n$上鞅，则$X_{N\wedge n}$也是上鞅。</p>
<h2 id="鞅收敛定理"><a href="#鞅收敛定理" class="headerlink" title="鞅收敛定理"></a>鞅收敛定理</h2><p>$\lim_{n\to\infty}X_n(\omega)$不存在$\Leftrightarrow\lim_{n\to\infty}inf\:X_n(\omega)&lt;\lim_{n\to\infty}sup\:X_n(\omega)$，也等价于存在有理数a,b：</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}inf\:X_n(\omega)<a<b<\lim_{n\to\infty}sup\:X_n(\omega)</script><p>定义$N_{2k-1}$为第k次下穿a的停时，$N_{2k}$是第k次上穿b的停时。定义$U_n=\{sup\:k|N_{2k}&lt;n\}$为上穿[a,b]的次数。而</p>
<script type="math/tex; mode=display">
\{\lim_{n\to\infty}inf\:X_n(\omega)<a<b<\lim_{n\to\infty}sup\:X_n(\omega)\}\subset \{\lim_{n\to\infty}U_n(\omega)=+\infty\}</script><p>定义$H_m=1_{\bigcup\{N_{2k-1}\leq m\leq N_{2k}\}}$，$W_n=\sum_{m-1}^nH_m(X_m-X_{m-1})$，</p>
<p>（<strong>下鞅上穿不等式</strong>）若$X_n$下鞅，则对a&lt;b，$(b-a)EU_n\leq E(X_n-a)^+-E(X_0-a)^+$（证明：定义$Y_n=a+(X_n-a)^+$，则也是下鞅且上穿次数与$X_n$相等。那么$W_n=\sum_{m=1}^nH_m(Y_m-Y_{m-1})$\geq (b-a)U_n$。又令$K_m=1-H_m$，$V_n=\sum_{m=1}^nK_m(Y_m-Y_{m-1})$。那么$W_n+V_n=Y_n-Y_0$，且$V_n$下鞅，$EV_N\geq EV_0=0 $。所以</p>
<script type="math/tex; mode=display">
E(Y_n-Y_0)=EW_n+EV_n\geq EW_n\geq(b-a)EU_n</script><p> 即得证）</p>
<p>利用上穿不等式，得到</p>
<p>（<strong>下鞅基本收敛定理</strong>） 如果下鞅$X_n$满足$sup\:EX_n^+&lt;\infty$，则$X_n\to X$a.s.，且$E|X|&lt;+\infty$。（证明：$(X_n-a)^+$是下鞅，根据上穿不等式$EU_n\leq E(X_n-a)^+/(b-a)$有界，而根据$U_n$单调上升必有极限$U$，因此</p>
<script type="math/tex; mode=display">
P(\lim_{n\to\infty}inf\:X_n<a<b<\lim_{n\to\infty}sup\:X_n)=0</script><p>所以$X_n$极限a.s.存在。又由于$EX_n\geq EX_0$，$EX_n^-=EX_n^+-EX_n\leq sup\:EX_n^+-EX_0&lt;+\infty$然后由Fatou引理易得$E|X|&lt;+\infty$。）</p>
<p> 定理：若$X_n$非负上鞅，则$\lim X_n=X$a.s.，且$EX\leq EX_0$。（证明：$-X_n$下鞅有界，a.s.收敛到极限X。）</p>
<p><strong>注意：L1收敛并不成立。</strong>一个简单的反例就是$S_0=1$，$P(e_i=-1)=P(e_i=1)=1/2$，N为$S_n=0$的停时，$X_n=S_{n\wedge N}$是鞅。但是由上面的定理可知$X\to 0$a.s.，与$EX_n=1$矛盾。</p>
<h2 id="四个例子"><a href="#四个例子" class="headerlink" title="四个例子"></a>四个例子</h2><h3 id="有界增长"><a href="#有界增长" class="headerlink" title="有界增长"></a>有界增长</h3><p>$X_n$为鞅过程，且$|X_{n+1}-X_n|\leq M&lt;\infty$，那么要么$lim\:X_n$存在且有限，要么$X_n$在正负无穷之间摇摆。(停时$N=inf\{X_n\leq k\}$，那么$x_{n\wedge N}+k+M$a.s.收敛)</p>
<p>（Doob分解）下鞅$X_n$可以写成$X_n=M_n+A_n$。其中$M_n$是鞅过程，$A_n$是可预测序列。(令$A_n-A_{n-1}=E(X_n|F_{n-1})-X_{n-1}$)</p>
<p>（第二Borel-Cantelli引理）$A_n\in F_n$，那么</p>
<script type="math/tex; mode=display">
\{A_n\:i.o.\}=\{\sum_{n=1}^\infty P(A_n|F_{n-1})=\infty\}</script><p>（第二B-C引理是第一引理的推广，去掉了独立性要求）</p>
<p>证明：由Doob分解可得$M_n=\sum_{m=1}^n 1_{A_m}-P(A_m|F_{m-1})$是有界增长的鞅过程。</p>
<h3 id="Polya’s-Urn-Scheme"><a href="#Polya’s-Urn-Scheme" class="headerlink" title="Polya’s Urn Scheme"></a>Polya’s Urn Scheme</h3><p>坛子模型：坛子里有r个红球、g个绿球，每次取出一个并放进与之同色的c+1个球。n次抽取后绿球比例$X_n$是鞅。</p>
<p>如果r=g=c=1，可得$P(X_n=\frac{k}{n+2})=\frac{1}{n+1}$。</p>
<p>实际上，$X_\infty$有参数为$g/c$和$r/c$的beta分布：</p>
<script type="math/tex; mode=display">
\frac{\Gamma((g+r)/c)}{\Gamma(g/c)\Gamma(r/c)}x^{(g/c)-1}(1-x)^{(r/c)-1}</script><h3 id="R-N微分"><a href="#R-N微分" class="headerlink" title="R-N微分"></a>R-N微分</h3><p>有限测度$\mu$，$\nu$，上升的$\sigma-$域$F_n$，定义$\mu_n=\mu|F_n$，$\nu_n=\nu|F_n$。</p>
<p>定理：若$\mu_n&lt;&lt;\nu_n$，定义$X_n=\frac{d\mu_n}{d\nu_n}$，令$X=\lim_{n\to\infty}sup\:X_n$，则</p>
<script type="math/tex; mode=display">
\mu(A)=\int_AXd\nu+\mu(A\cap\{X=+\infty\})</script><p>证明：根据定义，$A\in F_n$，则$\mu(A)=\int_AX_nd\nu$。$X_n$是非负鞅，所以$X_n\to X$a.s.。又令$\rho=(\mu+\nu)/2$，$\rho_n=\rho|F_n$，$Y_n=\frac{d\mu_n}{d\rho_n}$，$Z_n=\frac{d\nu_n}{d\rho_n}$。显然$Y_n$和%Z_n$都是非负鞅，且$Y_n+Z_n=2$a.s.。所以有$Y_n\to Y$，$Z_n\to Z$。记$Y=\frac{d\mu}{d\rho}$，$Z=\frac{d\nu}{d\rho}$。那么对$A\in F_n$，则由有界收敛</p>
<script type="math/tex; mode=display">
\mu(A)=\mu_n(A)=\int_AY_nd\rho\to\int_AYd\rho</script><p>$X_n=Y_n/Z_n$a.s.，而$Y+Z=2$a.s.，且$\rho(Y=0,Z=0)=0$。所以$X=Y/Z$,$\rho-$a.s.。</p>
<p>令$W=\frac{1}{Z}1_{\{Z&gt;0\}}$所以$1=WZ+1_{\{Z=0\}}$。所以可得</p>
<script type="math/tex; mode=display">
\mu(A)=\int_AYd\rho=\int_AYWZd\rho+\int_AY1_{\{Z=0\}}d\rho</script><p>马上得证（第二部分由$\{Z=0\}=\{X=\infty\}$得到）。</p>
<p>由此推出<strong>Kakutani关于无穷乘积测度的二分法</strong>：$\mu$，$\nu$都是$(R^N,R^N)$上的概率测度，$e_n$独立，令$F_n(x)=\mu(e_n\leq x)$，$G_n(x)=\nu(e_n\leq x)$。</p>
<p>$\lambda_{F_n}&lt;&lt;\lambda_{G_n}$，令$q_n=\frac{d\lambda_{F_n}}{d\lambda_{G_n}}$。令$F_n=\sigma(e_m,m\leq n)$，$X_n=\frac{d\mu_n}{d\nu_n}=\prod q_n$。根据上面的定理，$X_n\to X$ $\nu-$a.s.，所以根据Kolmogorov 0-1律，$\nu(X=0)\in\{0,1\}$。因而$\mu&lt;&lt;\nu$或者两者正交。</p>
<p><strong>定理：$\mu\sim\nu$或者两者正交，根据$\prod\int\sqrt{q_m}dG_m$&gt;0或=0进行判断</strong></p>
<p>证明：先证无穷乘积是有定义的。</p>
<p>如果$\prod\int\sqrt{q_m}dG_m=0$，那么$\int X_n^{1/2}d\nu\to 0$。而$\int X^{1/2}d\nu\leq\lim inf\:\int X_n^{1/2}d\nu =0$。所以$\nu(X=0)=1$，$\mu$和$\nu$相互独立。</p>
<p>反之，令$Y_n=X_n^{1/2}$，则$E(X_n)=E(Y_n^2)=1$。下证$Y_n$L2-基本列：$E(Y_{n+k}-Y_n)^2=2(1-\prod_{n+1}^{n+k} \int \sqrt{q_m}dG_m\to 0$。$E|X_{n+k}-X_n|\leq 2(E(Y_{n+k}-Y_n)^2)^{1/2}\to 0$，故而$X_n$是L1-基本列，$X_n\to X$。所以对$A\in F_n$</p>
<script type="math/tex; mode=display">
\mu(A)=\mu_n(A)=\int_AX_nd\nu_n=\int_AX_nd\nu\to\int_AXd\nu</script><p>有$\pi-\lambda$方法，A可以扩展到$R^N$，故而$\mu&lt;&lt;\nu$。</p>
<p>$EX=\lim EX_n=1$，所以$\nu(X=0)<1$，故而$\nu(X=0)=0$，$\nu(X>0)=1$，$\mu\sim\nu$。</p>
<h3 id="分支过程"><a href="#分支过程" class="headerlink" title="分支过程"></a>分支过程</h3><p>$e_n$独立非负，定义$Z_n$，满足$Z_0=1$以及</p>
<script type="math/tex; mode=display">
Z_{n+1}=\left\{\begin{array}.e_1^{n+1}+...+e_{Z_n}^{n+1}\:if\:Z_n>0\\0\:otherwise\end{array} \right.</script><p>也叫做Galtom-Watson过程，描述繁衍过程。</p>
<p><em>引理：令$\mu=E(e_i^n)$，则$\{Z_n/\mu^n\}$是鞅过程 。</em></p>
<p>定理：若$\mu&lt;1$，则对所有足够大的n，$Z_n=0$。因此$Z_n/\mu^n\to^{a.s.}0$</p>
<p>(由$E(Z_n/\mu^n)=E(Z_0)=1$得$E(Z_n)=\mu^n\to 0$可得)</p>
<p>定理：若$\mu=1$且$P(e_i^m=1)&lt;1$，那么对所有足够大的n，$Z_n=0$。</p>
<p>（证明从$P(Z_n=k,n\geq N)=0$入手）</p>
<p>定理：若$\mu&gt;1$，$P(Z_n&gt;0,\forall n)&gt;0$</p>
<p>定理：(Kesten-Stigum)</p>
<script type="math/tex; mode=display">
P(W=\lim \frac{Z_n}{\mu^n}>0)>0\Leftrightarrow\sum P_kkln(k)<+\infty</script><h2 id="Doob不等式-以及LP收敛"><a href="#Doob不等式-以及LP收敛" class="headerlink" title="Doob不等式(以及LP收敛)"></a>Doob不等式(以及LP收敛)</h2><p>定理：设$X_n$下鞅，N有界停时，$P(N\leq k)=1$，那么$EX_0\leq EX_N\leq EX_k$。</p>
<p>证明：$X_n$和$X_{N\wedge n}$下鞅，$Y_n=X_n-X_{N\wedge n}$下鞅，$EY_0\leq EY_k$得到$EX_N\leq EX_k$。</p>
<p>(反例：当N不是有界的时候，不一定成立，考虑SRW，$S_0=1$，停时N为0的首达时，此时$ES_N=0$。)</p>
<p><strong>(Doob不等式)</strong>$X_m$下鞅，令$\bar{X_n}=\max_{0\leq m\leq n}X_m^+$，$A=\{\bar{X_n}\geq\lambda\}$，那么</p>
<script type="math/tex; mode=display">
\lambda P(A)\leq EX_n1_A\leq EX_n^+</script><p>证明：令$N=\inf\{m\geq 0, X_m\geq\lambda\}\wedge n$，在A上$X_N\geq\lambda$，所以$X_N1_A\geq \lambda 1_A$，$\lambda P(A)\leq EX_N1_A$，根据$A^C$上$N=n$，$EX_N1_A\leq EX_n1_A$。右边不等号显然。</p>
<p><strong>（LP不等式）</strong>下鞅$X_n$，p&gt;1，那么</p>
<script type="math/tex; mode=display">
E(\bar{X_n})^p\leq(\frac{p}{p-1})^pE(X_n^+)^p</script><p>特别的，若$Y_n$是鞅过程，$Y_n^*=\max|Y_m|$，那么</p>
<script type="math/tex; mode=display">
E(Y_n^*)^p\leq (\frac{p}{p-1})^pE|Y_n|^p</script><p>证明：$E(X_n^+)^p=+\infty$则显然成立。下设$E(X_n+)^p&lt;+\infty$，考虑$\bar{X_n}\wedge M$，所以</p>
<script type="math/tex; mode=display">
E(\bar{X_n}\wedge M)^p=\int_0^\infty p\lambda^{p-1}P(\bar{X_n}\wedge M\geq\lambda)d\lambda\\
\leq\int_0^\infty p\lambda^{p-1}(\lambda^{-1}EX_n^+1_{\{\bar{X_n}\wedge M\}\geq\lambda})d\lambda\\
=\int X_n^+\int_0^{\bar{X_n}\wedge M}p\lambda^{p-2}d\lambda dp\\
=\frac{p}{p-1}\int X_n^+(\bar{X_n}\wedge M)^{p-1}dp\\
\leq\frac{p}{p-1}(E(X_n^+)^p)^{1/p}(E(\bar{X_n}\wedge M)^p)^{(p-1)/p}</script><p>移项并令$M\to+\infty$由单调收敛定理可得证。</p>
<p><strong>（LP收敛定理）</strong>若$X_n$鞅，满足$sup\:E|X_n|^p&lt;+\infty$，$p&gt;1$，那么</p>
<script type="math/tex; mode=display">
X_n\to^{a.s.}X,\:X_n\to^{LP}X</script><p><strong>（鞅增量正交性）</strong>若$X_n$鞅，$EX_n^2&lt;\infty$，若$Y\in F_m$，$EY^2&lt;\infty$，那么$E(X_n-X_m)Y=0$。</p>
<p><strong>（条件方差公式）</strong>若$X_n$鞅，$EX_n^2&lt;\infty$，则$E((X_n-X_m)^2|F_m)=E(X_n^2|F_m)-X_m^2$。</p>
<h3 id="平方可积鞅"><a href="#平方可积鞅" class="headerlink" title="平方可积鞅"></a>平方可积鞅</h3><p>$X_n$鞅，$X_0=0$，且$EX_n^2&lt;+\infty$，$X_n^2$下鞅，因而可以Doob分解为$X_n=M_n+A_n$，$M_n$鞅，而$A_n$非降。定义$A_\infty=\lim_{n\to\infty}A_n$。</p>
<script type="math/tex; mode=display">
A_n=\sum_{m=1}^nE((X_m-X_{m-1})^2|F_{m-1})</script><p>定理：$E\sup_{n\geq 0}|X_n|^2\leq 4 EA_\infty$（由LP不等式和单调收敛定理即得）</p>
<p>定理：在$\{A_\infty&lt;\infty\}上$\lim_{n\to\infty}X_n$a.s.存在有限。</p>
<p>证明：取停时$N=\inf\{n\geq 0,\:A_{n+1}&gt;a^2\}$，所以$X_{N\wedge n}$鞅。根据LP收敛定律，$X_{N\wedge n}$极限存在有限。所以在$\{A_\infty\leq a^2\}上$N=+\infty$，然后取并可得。</p>
<p>定理：设$f:[0,+\infty)\to [1,+\infty)$非降且$\int_0^\infty \frac{1}{f^2(t)}dt&lt;+\infty$，则在$\{A_\infty=\infty\}$上$\frac{X_n}{f(A_n)}\to^{a.s.}0$</p>
<p>证明：$H_n=\frac{1}{f(A_m)}$可料有界，则$Y_n=\sum_{m=1}^nH_m(X_m-X_{m-1})$鞅。分解$Y_n^2=N_n+B_n$，可证$B_\infty&lt;+\infty$，$Y_n\to^{a.s.}T_\infty$有限，由Kronecker引理得证。</p>
<p>定理（第二Borel-Cantelli定理）：$P_n=P(B_n|F_{n-1})$，那么在$\{\sum_{n=1}^\infty P_n=\infty\}$上</p>
<script type="math/tex; mode=display">
\frac{\sum_{m=1}^n1_{B_m}}{\sum_{m=1}^nP_m}\to^{a.s.}1</script><p>证明：定义$X_n=\sum_{m=1}^n1_{B_m}-\sum_{m=1}^nP_m$，定义$f(t)=t\vee 1$，由上可得。</p>
<h3 id="一致可积L1收敛"><a href="#一致可积L1收敛" class="headerlink" title="一致可积L1收敛"></a>一致可积L1收敛</h3><p>一致可积$\{X_i,\:i\in I\}$满足</p>
<script type="math/tex; mode=display">
\lim_{M\to\infty}\sup E|X_i|1_{|X_i|>M}=0</script><p>（一致）绝对连续$\{X_i,\:i\in I\}$满足</p>
<script type="math/tex; mode=display">
\lim_{p(A)\to 0}\sup E|X_i|1_A=0</script><p><u>一致可积当且仅当绝对连续+L1有界</u></p>
<p>定理：$X\in L1(\Omega,F_0,P)$，那么$\{E(X|F),\:F是子\sigma-域\}$一致可积</p>
<p>定理：若$X_n\to^P X$则下列叙述等价</p>
<ul>
<li>$\{X_n\}$一致可积</li>
<li>$X_n\to{L1}X$</li>
<li>$E|X_n|\to E|X|&lt;+\infty$</li>
</ul>
<p>证明：$(1)\Rightarrow (2)$：构造辅助函数$\phi_M(x)=trunc(x, -M, M)$。$(2)\Rightarrow (3)$：显然。$(3)\Rightarrow (1)$：构造辅助函数</p>
<script type="math/tex; mode=display">
\phi_M(x)=\left\{\begin{align}&x,&x\in[0,M-1]\\&-(M-1)(x-M),&x\in[M-1,M]\\&0,&x\in[M,+\infty)\end{align} \right.</script><p>定理：设$p\in (0,+\infty)$，$\{X_n\}\subset LP(\Omega, F, p)$，随机变量$X_n\to^P X$那么下列叙述等价</p>
<ul>
<li>$\{|X_n|^p\}一致可积</li>
<li>$X\in LP$，$X_n\to^{LP}X$</li>
<li>$X\in LP$，$E|X_n|^p\to E|X|^p$</li>
</ul>
<p>定理：对下鞅$\{X_n\}$，下列叙述等价</p>
<ul>
<li>$\{X_n\}$一致可积</li>
<li>$X_n\to ^{a.s.}X$，且$X_n\to^{L1}X$</li>
<li>$X_n\to^{L1}X$</li>
</ul>
<p>引理：$X_n\to^{L1}X$，那么$\forall A$，$EX_n1_A\to EX1_A$</p>
<p>引理：若鞅$\{X_n\}$满足$X_n\to^{L1}X$，那么$X_n=E(X|F_n)$</p>
<p>定理：对鞅$\{X_n\}$，下列叙述等价</p>
<ul>
<li>$\{X_n\}$一致可积</li>
<li>$X_n\to ^{a.s.}X$，且$X_n\to^{L1}X$</li>
<li>$X_n\to^{L1}X$</li>
<li>存在可积随机变量X，$X_n=E(X|F_n)$</li>
</ul>
<p>定理：若$\sigma$域流$F_n\uparrow F_\infty$，$F_\infty=\sigma(\bigcup F_n)$，随机变量X满足$E|X|&lt;+\infty$，那么$E(X|F_n)\to^{a.s.,L1} E(X|F_\infty)$。</p>
<p>证明：定义$Y_n=E(X|F_n)$是鞅过程。通过典型方法可得$EX1_A=EY_\infty 1_A$，因而$Y_n\to Y_\infty$。</p>
<p>定理（Levy 0-1律）：若$F_n\uparrow F_\infty$，$A\in F_\infty$，那么$E(1_A|F_n)\to^{a.s.}1_A(n\to\infty)$</p>
<p>特例：独立随机变量$X_n$，$A\in\tau(尾\sigma 代数)$，则$E(1_A|F_n)=E1_A=P(A)$。（$\tau=\bigcap_{n\geq 1}\sigma(X_{n+1},…)$）此时即为Kolmogorov 0-1律。</p>
<p>定理（条件期望控制收敛）：$Y_n\to^{a.s.}Y$，$|Y_n|\leq Z$，$EZ&lt;+\infty$，$F_n\uparrow F$，那么$E(Y_n|F_n)\to^{a.s.}E(Y|F_\infty)$</p>
<p>证明：</p>
<script type="math/tex; mode=display">
|E(Y_n|F_n)-E(Y|F_\infty)|\leq |E(Y_n|F_n)-E(Y|F_n)|+|E(Y|F_n)-E(Y|F_\infty)|</script><p>后一部分易证。为证明前一部分，令$W_N=\sup\{|Y_n-Y_m|,n,m\geq N\}$单调收敛可证。</p>
<h2 id="倒向鞅"><a href="#倒向鞅" class="headerlink" title="倒向鞅"></a>倒向鞅</h2><p>鞅$\{X_n:n\leq 0\}$称为倒向鞅，定义$F_{-\infty}=\bigcap F_n$</p>
<p>定理：$X_{-\infty}=\lim_{n\to -\infty}X_n$a.s.存在且L1收敛</p>
<p>证明：记$U_n[a,b]$为$X_{-n}$上穿$[a,b]$的次数，根据上穿不等式，$(b-a)EU_n\leq E(X_0-a)^+$，根据单调收敛定理，$U_\infty[a,b]&lt;+\infty$。所以$X_{-n}$的极限a.s.存在。 然后根据一致可积得到L1收敛。</p>
<p>定理：$\{X_n\}$倒向鞅，则</p>
<script type="math/tex; mode=display">
X_{-\infty}=E(X_0|F_{-\infty})</script><p>证明：先证$X_{-\infty}\in F_{-\infty}$，然后证明条件概率。</p>
<p>定理：若$F_n\downarrow F_{-\infty}$且$E|Y|&lt;+\infty$，那么</p>
<script type="math/tex; mode=display">
\lim_{n\to-\infty}E(Y|F_n)=E(Y|F_{-\infty}),a.s.,L1</script><p>令$A_n(\omega)=\omega_n$</p>
<p>如果单+满的映射$\pi:N\to N$，使得仅对有限个i，有$\pi(i)=i$，则称$\pi$为<strong>有限置换</strong>。定义$(\pi\omega)_i=\omega_{\pi(i)}$。若对任意有限置换$\pi$，$\pi^{-1}A=A$，则称A为<strong>可置换集合</strong>。$\{A|A可置换\}$构成$\sigma-$域，即为E。</p>
<p>例：$(S,S)=(R,R)$，$S_n(\omega)=\sum_{i=1}^nX_i(\omega)$，那么</p>
<ul>
<li>$\{\omega|S_n(\omega)\in B\}$是可置换的，对$\forall B$Borel</li>
<li>任意正常数列$C_n$，$\{\omega|\bar{\lim}S_n(\omega)/C_n\geq 1\}$可置换</li>
<li>任意$A\in \tau$可换，则$\tau\subset E$</li>
</ul>
<p>$E_n=\{\A|\forall 有限置换\pi s.t.\pi(n+k)=n+k有\pi^{-1}A=A}$，$E=\bigcap E_n$</p>
<p>定理（Hewitt-Savage 0-1律）：若$X_n$独立同分布，则任意$A\in E$，$P(A)=0或1$。</p>
<p>证明：引理：若$X_n$独立同分布，$\phi:R^k\to R$，令$A_n(\phi)=\frac{1}{A_n^k}\sum\phi(X_{i_1},…,X_{i_k})$其中$A_n^k=\frac{n!}{(n-k)!}$。若$\phi$有界可测，则$A_n(\phi)\to E\phi(X_1,…,X_k)$a.s.。</p>
<p>引理的证明：$A_n(\phi)\in E_n$，$A_n(\phi)=E(\phi(X_1,…,X_k)|E_n)$，令$F_{<em>**</em>-m}=E_m$，所以$E(\phi(X_1,…,X_k)|E_n)\to{a.s.L1}E(\phi(X_1,…,X_k)|E)$</p>
<p>通过引理可知$E(\phi(X_1,…,X_k)|E)=E\phi(X_1,…,X_k)$，所以E与$\sigma(X_1,…,X_k)$独立，所以E与F独立。又由$E\subset F$可证。</p>
<p>引理：若$EX^2&lt;\infty$，$E(X|G)\in F$，X和F独立，则$E(X|G)=EX$。</p>
<p>例：（强大数律）：$e_n$独立同分布，$E|e_1|&lt;+\infty$，令$X_{-n}=S_n/n$。$F_{-n}=\sigma(S_n,…)$，可证$\{X_{-n},F_{-n}\}$倒向鞅。因而$X_{-n}\to{a.s.L1}E(X_{-1}|F_{-\infty})$。由于$F_{-n}\subset E_n$，所以$F_{-\infty}\subset E$，由H-S 0-1律，$E(X_{-1}|F_{-\infty})=EX_{-1}$</p>
<p>例：（选票定理）设$e_n$非负整数，$G=\{S_j&lt;j\}$，则$P(G|S_n)=(1-\frac{S_n}{n})^+$</p>
<h2 id="停时定理"><a href="#停时定理" class="headerlink" title="停时定理"></a>停时定理</h2><p>问题：若$X_n$下鞅，任意停时$M\geq N$，什么条件下$E(X_M|F_N)\geq X_N$，$X_M\geq X_N$？</p>
<p>定理：若$X_n$下鞅一致可积，则对停时N，则$X_{N\wedge n}$一致可积。（由下鞅基本收敛定理，$X_{n\wedge N}\to^{a.s.}X_N$，易证）</p>
<p>定理：对独立同分布的随机变量$X_n$和非负整数N，s.t. $E|X_N|&lt;+\infty。如果$\{|X_n|1_{N&gt;n}\}$一致可积，那么$\{X_{N\wedge n\}$一致可积。若还有$X_n$下鞅，停时$N&lt;+\infty$，则$EX_0\leq X_N$。</p>
<p>定理：若$X_n$下鞅一致可积，任意停时$N\leq +\infty$，有$EX_0\leq EX_N\leq EX_\infty$。</p>
<p>定理：若$X_n$非负上鞅，停时$N&lt;+\infty$，则$EX_0\geq EX_N$</p>
<p>定理：$X_n$下鞅，$E(|X_{n+1}-X_n||F_n)\leq B$，那么对任意停时$EN&lt;+\infty$，有$\{X_{N\wedge n}\}$一致可积，从而$EX_0\leq EX_N$。</p>
<p>定理（Wald等式）：$e_n$独立同分布，停时N有限，则$ES_N=EeEN$</p>
<p>证明：$S_n-nEe$是鞅，由上面的定理可证。</p>
<p>定理（Doob可选停止定理）：若$L\leq M$是停时，$Y_n\in F_n$，$\{Y_{M\wedge n}\}$一致可积，下鞅，则$EY_L\leq EY_M$，$Y_L\leq E(Y_M|F_L)$。其中$F_L=\{\A\in F|A\cap \{L=n\}\in F_n}$</p>
<p>证明：令$X_n=Y_{M\wedge n}$，则$EX_N\leq EX_\infty=EY_M$，取N=L，则$EY_L\leq EY_M$。对任意A，N在A上取L，否则取M，则N为停时，$EY_N\leq EY_M$，所以$EY_L1_A\leq EY_M1_A=E(E(Y_M1_A|F_L))$。令$A_n=\{Y_L-E(Y_M|F_L)&gt;1/n\}$，所以$1/nP(A_n)\leq 0$</p>
<p>例：随机游动，$\mu=Ee$有限，则$S_n-n\mu$鞅。这里设$\mu=0$，$Ee^2=\sigma^2&lt;+\infty$。则$S_n^2-n\sigma^2$也是鞅。</p>
<p>（简单对称随机游动）$P(e=1)=P(e=-1)=1/2$，$S_0=x\in(a,b)$，停时N为S首次出区间(a,b)的时间。则$P(S_N=a)=\frac{b-x}{b-a}$，$E_xN=(x-a)(b-x)$</p>
<p>(非对称简单随机游动)$P(e=1)=p$，$P(e=-1)=q=1-p$。设$0<p<1$，$\phi(y)=(\frac{1-p}{p})^y$，则$\phi(S_n)$鞅。令$T_Z=\inf\{S_n=z\}$，$P_x(T_a<T_b)=\frac{\phi(b)-\phi(x)}{\phi(b)-\phi(a)}$。设$1/2<p<1$，$a<0$，则$P_0(\inf S_n\leq a)=P_0(T_a<+\infty)=()(1-p)/p)^{-a}。$b>0$，则$P_0(T_b&lt;+\infty)=1$，$E_0T_b=b/(2p-1)$</p>
<h1 id="遍历定理"><a href="#遍历定理" class="headerlink" title="遍历定理"></a>遍历定理</h1><p>如果r.v.s. $X_n$使得$\{X_n\}$和$\{X_{n+k\}$同分布称为<strong>（严）平稳随机变量序列</strong>。</p>
<p><strong>Birkhoff遍历定理</strong>：若$f:R\to R$可测，$E|f(x_n)|&lt;+\infty$，则</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac1n\sum_{m=0}^{n-1}f(X_m)</script><p>a.s.存在。</p>
<p>若$\{X_n\}$遍历，则极限为$f(X_0)$</p>
<p>例子：iid序列、随机游动、马氏链</p>
<p>这里<strong>马氏链</strong>定义为任意$B\in S$，$P(X_{n+1}\in B|F_n)=P(X_{n+1}\in B|X_n)$</p>
<p><strong>转移概率函数</strong>$p:S\times S\to[0,1]$满足：</p>
<ul>
<li>任意$x\in S$，$A\to p(x,A)$是一个概率测度</li>
<li>任意$A\in S$，$x\to p(x,A)$可测</li>
</ul>
<p>对马氏链$X_n$，定义$p_n(x,A)=P(X_{n+1}\in A|X_n=x)$，则$P(X_{n+1}\in A|F_n)=p_n(X_n,A)$。若正则条件分布存在，则$p_n(x,A)$是转移概率。若$p_n(x,A)$不依赖于n，则称$X_n$时齐。特别的，当S可数集时，$p_n(i,j)$构成转移概率矩阵。</p>
<p>如果可测映射$\phi$满足对任意A，$P(\phi^{-1}A)=P(A)$，则称$\phi$<strong>保测映射</strong>。$X_n(\omega)=X(\phi^n\omega)$是平稳序列。</p>
<p>若$Y_n$平稳序列，取值于nice space，可构造概率测度p，使得</p>
<script type="math/tex; mode=display">
P(\omega\in S^N,(\omega_0,\omega_1,...,\omega_n)\in B)=P(B\times\prod_{i=n+1}^\infty S)=\bar{P}((Y_0,Y_1,...,Y_n)\in B)</script><p>（Kolmogorov相容性定理）令$X_n(\omega)=\omega_n$，则$X_n$与$Y_n$同分布。（可以构造推移算子，可以证明这个算子是保测映射）</p>
<p>保测映射$\phi$对A，满足$P(A\Delta \phi^{-1}A)=0$，称A为<strong>不变集</strong>。若$A=\phi^{-1}A$，称A为<strong>强不变集</strong>。若任意不变集有$P(A)=0$或$1$，则称$\phi$<strong>遍历（ergodic）</strong>。</p>
<p>定义$I=\{A|\phi^{-1}A=A,a.s.\}$，称为<strong>不变$\sigma$域</strong>，则$\phi 遍历\Leftrightarrow I 平凡$</p>
<p>时齐马氏链$X_n$状态空间S可数，平稳分布$\pi$满足对任意状态$\pi(x)&gt;0$（正常返），那么$X_n遍历\Leftrightarrow X_n不可约$。</p>
<p>证明：必要性：反证，可约推出不遍历。充分性：任何不变集A满足，$1_A\theta_n=1_A$，P(A)为0或1，I平凡。</p>
<p><strong>Birkhoff个别遍历定理</strong>：保测变换$\phi$，X期望有限，则</p>
<script type="math/tex; mode=display">
\frac1n \sum_{k=0}^{n-1}X(\phi^k\omega)\to^{a.s.L1}E(X|I)</script><p>若$\phi$遍历，则$E(X|I)=EX$。</p>
<p>引理（极大遍历定理）：令$X_r(\omega)=X(\phi^r\omega)$，$S_k(\omega)=\sum_{r=0}^{k-1}X_r(\omega)$，$M_k(\omega)=\max(0,S_1(\omega),…,S_k(\omega))$，则</p>
<script type="math/tex; mode=display">
EX1_{\{M_k>0\}}\geq 0</script><p>引理的证明：$X(\omega)\geq S_{j+1}(\omega)-M_k(\phi(\omega))$ 对任意$j\leq k$。所以$X(\omega)\geq \max S_{j+1}(\omega)-M_k(\phi(\omega))$。那么$EX1_{\{M_k&gt;0\}}\geq \int_{\{M_k&gt;0\}}(M_k(\omega)-M_k(\phi(\omega)))dP=0$。</p>
<p>遍历定理的证明：不妨设$E(X|I)=0$，只需证</p>
<script type="math/tex; mode=display">
\sup\lim_{n\to\infty}\frac1n S_n(\omega)\leq 0</script><p>令$D=\{\omega|\sup\lim_{n\to\infty}\frac1n S_n(\omega)&gt;\epsilon\}$。令$X^*(\omega)=(X(\omega)-\epsilon)1_D(\omega)$，如此定义$S_n^*(\omega)$和$M_n^*(\omega)$。定义$F_n=\{M_n^*&gt;0\}$，F定义为它们的并集。</p>
<p>那么F=D。由极大遍历定理，$EX^*1_{F_n}\geq 0$，$E|X^*|\leq E|X|+\epsilon$，由控制收敛定理，$X^*1_F$存在且大于等于0，即$EX^*1_D\geq 0$，这就推出$P(D)\leq 0$。由此可以证明a.s.收敛。根据有界收敛+控制收敛可得L1收敛。</p>
<p><u>Birkhoff遍历定理可以直接推出强大数律</u></p>
<p>根据Birkhoff遍历定理在圆周旋转上的应用，如果$\theta\in(0,1)$是无理数，$\phi(\omega)=\omega+\theta\:mod\:1$，令$X(\omega)=1_A(\omega)$，那么</p>
<script type="math/tex; mode=display">
\frac1n\sum_{m=1}^{n-1}1_{(\phi^m\omega\in A)}\to|A|,a.s.</script><p>当$\omega=0$时，也称做<strong>Weyl等分布定理</strong>。由此得到以下数论结论</p>
<p>定理：如果$A=[a,b)$，那么倒外集为空集。</p>
<p><strong>常返</strong></p>
<p>设$X_n$取值$R^d$的平稳序列，定义</p>
<script type="math/tex; mode=display">
R_n=\#\{S_1,S_2,...,S_n\}</script><p>定理：</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac{R_n}{n}=E(1_A|I)</script><p>其中$A=\{S_k\neq 0,\forall k\geq 1\}$</p>
<p>证明：对$l\geq m$，$S_l=S_m+S_{l-m}(\phi^m\omega)$，</p>
<script type="math/tex; mode=display">
R_n\geq\sum_{m=1}^n1_A(\phi^m\omega)=\#\{m|S_l\neq S_m,\forall l>m\}</script><p>由Birkhoff，</p>
<script type="math/tex; mode=display">
\inf\lim_{n\to\infty}\frac{R_n}n\geq\lim_{n\to\infty}\frac1n\sum_{m=1}^n1_A(\phi^m\omega)=E(1_A|I)</script><p>令$A_k=\{S_m\neq 0, m\leq k\}$</p>
<script type="math/tex; mode=display">
\sum_{m=1}^{n-k}1_{A_k}(\phi^m\omega)=\#\{m|S_l\neq S_m,\forall>m\}</script><p>所以$R_n\leq k+\sum_{m=1}^{n-k}1_{A_k}(\phi^m\omega)$，如此</p>
<script type="math/tex; mode=display">
\sup\lim\frac{R_n}n\leq E(1_{A_k}|I)</script><p>由于$A_k\downarrow A$，由控制收敛可证上界。</p>
<p>Durrent第四章、第六章</p>
<p>206</p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化问题</title>
    <url>/2020/02/14/ConvexOptimization/</url>
    <content><![CDATA[<p>凸优化问题具有如下形式</p>
<script type="math/tex; mode=display">
min\:f_0(x)</script><script type="math/tex; mode=display">
subject\:to\:f_i(x)\leq b_i\:, \:i=1,...,m</script><p>其中 $f_i$ 是凸函数</p>
<h3 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h3><p>C的<strong>仿射包</strong>为C中的点的所有仿射组合，即为<strong>affC</strong></p>
<p>定义集合C的<strong>仿射维数</strong>为其<strong>仿射包</strong>的维数。</p>
<p>定义集合C的<strong>相对内部</strong>为<strong>affC</strong>里C的内部，记为<strong>relintC</strong></p>
<script type="math/tex; mode=display">
relint\:C=\{x\in C|B(x, r)\cap aff\: C\subseteq C \: for \:some\: r \}</script><p><strong>凸集</strong>定义为对$x_1\:,\:x_2\in C\:,\:0\leq\theta\leq 1$</p>
<script type="math/tex; mode=display">
\theta x_1+(1-\theta)x_2\in C</script><a id="more"></a>
<p><strong>锥</strong>定义为<strong>非负齐次</strong>集合，对$x_1\:,\:x_2\in C\:,\:0\leq\theta_1\:,\:theta_2$</p>
<script type="math/tex; mode=display">
\theta_1 x_1+\theta_2 x_2\in C</script><p>集合C的<strong>锥包</strong>是C中元素的所有锥组合，也是包含C的<strong>最小凸锥</strong>。</p>
<p>凸集的例子</p>
<ul>
<li><p>空集、单点、直线、全空间</p>
</li>
<li><p>任意子空间都是<strong>凸锥</strong></p>
</li>
<li><p>超平面定义的半空间</p>
</li>
<li><p>Euclid球和椭球</p>
</li>
<li><p>范数球和范数锥</p>
</li>
<li><p>多面体和单纯形</p>
<p><u>如何表示多面体：凸包描述和不等式解集，n很大时两种描述规模相差极大。</u></p>
</li>
<li><p>半正定锥（半正定矩阵的元素在n(n+1)/2的向量空间里）</p>
</li>
</ul>
<p>保凸运算</p>
<ul>
<li><p>交集</p>
</li>
<li><p><strong>仿射</strong>函数</p>
</li>
<li><p>透视函数：$P:R^{n+1}\to R^n\:,\: P(z,t)=z/t \:,\: t&gt;0$</p>
</li>
<li><p>线性分式：</p>
<script type="math/tex; mode=display">
f(x)=(Ax+b)/(c^T x+d)\:,\:dom\: f = \{x|c^T x+d>0\}</script><p><u>凸集在透视函数或线性分式下的原相也是凸的。</u></p>
</li>
</ul>
<p><strong>正常锥</strong>K是满足下列条件的锥</p>
<ul>
<li>凸集</li>
<li>闭集</li>
<li><strong>实</strong>的：有非空内部</li>
<li><strong>尖</strong>的：不包含直线的</li>
</ul>
<p><strong>正常锥</strong>K可以用来定义<strong>广义不等式</strong> ，即偏序关系</p>
<script type="math/tex; mode=display">
x\preceq_K \: y \Leftrightarrow y - x \in K</script><p>（$K=R^+$时这个偏序关系就是通常意义上的不等式）</p>
<p>广义不等式定义的偏序关系$\preceq_K$具有加法保序性、传递性、自反性、反对称性等等。</p>
<p>但是它不具有<strong>线性序</strong>，即并非任意两点都可比。如果对每个$y\in S$，都有$x\preceq_K \: y$，那么我们称x为S的<strong>最小元</strong>，类似可定义<strong>最大元</strong>。最小元符号定义为</p>
<script type="math/tex; mode=display">
S \subseteq x +K</script><p>如果$y\in S$，而且$y\preceq_K \: x$可以推得$y=x$，那么我们称x为S的<strong>极小元</strong>，类似可定义<strong>极大元</strong>。极小（极大）元不一定唯一。极小元符号定义为 </p>
<script type="math/tex; mode=display">
(x-K)\cap S=\{x\}</script><p><strong>超平面分离定理</strong>：两个不相交的凸集C、D可以用一个超平面分离，即存在a，b</p>
<script type="math/tex; mode=display">
a^Tx+b\leq 0 \:for \:x\in C</script><script type="math/tex; mode=display">
a^Tx+b\geq 0 \:for \:x\in D</script><p><strong>严格分离</strong>是更强的条件（上式为严格不等号时），不相交的凸集也不一定能被严格分离。</p>
<p>超平面分离定理逆定理<strong>不成立</strong>，但是加上条件的如下结论：任何两个凸集C、D，如果其中至少有一个是<strong>开集</strong>，那么当且仅当存在分离超平面时，它们不相交。</p>
<p><strong>支撑超平面</strong>是指对C<strong>边界(bd C)</strong>上一点$x_0$，如果对</p>
<script type="math/tex; mode=display">
a\neq0\:,\:\forall x\in C\:,\:a^Tx\leq a^Tx_0</script><p>那么称$\{x|a^Tx=a^Tx_0\}$为C在$x_0$处的支撑超平面。一个基本结论<strong>支撑超平面定理</strong>：对任意凸集C和任意$x_0\in bd\:C$，存在支撑超平面。一个<strong>不完全的逆定理</strong>：具有非空内部的闭集，若其边界每个点都存在支撑超平面，那么他是凸的。（证明大概是从内点出发找到不满足凸集要求的点？</p>
<p>对一个锥K，集合</p>
<script type="math/tex; mode=display">
K^*=\{y|x^Ty\geq 0\:,\forall x\in K\}</script><p>称为K的<strong>对偶锥</strong>。几何上看，$y\in K^*$当且仅当-y是K在原点的一个支撑超平面的法线。</p>
<p>对偶锥的例子：</p>
<ul>
<li>子空间的对偶锥是其正交补</li>
<li>非负象限、半正定锥自对偶</li>
<li>范数锥的对偶由<strong>对偶范数</strong>定义</li>
</ul>
<p>一些性质：</p>
<ul>
<li>$K^*$总是闭+凸的</li>
<li>K有非空内部，则$K^*$是尖的</li>
<li>K的闭包是尖的，则$K^*$有非空内部</li>
<li>$K^{**}$是K的凸包的闭包</li>
<li>由上述性质可知当K是正常锥时$K^{**}=K$</li>
</ul>
<p><strong>广义不等式的对偶的性质</strong>：$x\preceq_K\:y$ 当且仅当对任意$\lambda\succeq_{K^<em>}0$有$\lambda^Tx\leq \lambda^Ty$。由于$K^{*</em>}=K$，显然对K的对偶也成立。</p>
<p><strong>线性严格广义不等式的择一定理</strong>：考虑严格广义不等式</p>
<script type="math/tex; mode=display">
Ax\prec_K\:b</script><p>，假设它不可行，即仿射集合$\{b-Ax\}$和int K不相交，那么存在一个分离超平面，因此存在$\lambda$和$\mu$使得对任意x，$\lambda^T(b-Ax)\leq\mu$，以及对任意$y\in K$，$\lambda^Ty\geq\mu$。第一个条件表明$A^T\lambda=0$以及$\lambda^Tb\leq\mu$；第二个条件表明$\lambda\in K^{*}$以及$\mu\leq 0$。所以，即存在$\lambda$，</p>
<script type="math/tex; mode=display">
\lambda\succeq_{K^*}0\:,\:A^T\lambda=0\:,\:\lambda^Tb\leq0</script><p>由此两个不等式构成一对择一，仅有一个可行。</p>
<p><strong>最小元的充要条件</strong>：对所有$\lambda\succ_{K^*}0$，x是极小化$\lambda^Tz$的唯一最优解。</p>
<p><strong>极小元的充要条件</strong>：如果有$\lambda\succ_{K^*}0$，x是极小化$\lambda^Tz$。（如果S不是凸集，则必要性不一定成立）</p>
<h3 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h3><p>定义f为<strong>凸函数</strong>如果dom f是凸集且对任意$x,y\in dom\: f$和任意$0\leq\theta\leq 1$有</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq\theta f(x)+(1-\theta)f(y)</script><p><strong>严格凸</strong>即上式在$x\neq y$且$0&lt;\theta &lt;1$时严格成立。<strong>凹函数</strong>类似定义。</p>
<p><strong>扩展值延伸</strong>：可以通过定义凸函数在定义域外的值为$\infty$来将这个凸函数延伸到全空间。</p>
<p>假设f<strong>可微</strong>，则f是凸函数的充要条件是dom f是凸集且对于任意$x,y\in dom\:f$，</p>
<script type="math/tex; mode=display">
f(y)\geq f(x)+\nabla f(x)^T(y-x)</script><p>假设f<strong>二阶可微</strong>，则f是凸函数的充要条件是dom f是凸集且对于任意$x\in dom\:f$，</p>
<script type="math/tex; mode=display">
\nabla^2f(x)\succeq 0</script><p>凸函数的例子：</p>
<ul>
<li>线性函数、仿射函数</li>
<li>指数、幂函数、对数、负熵</li>
<li>范数、最大值</li>
<li>指数和的对数</li>
</ul>
<p>凹函数的例子</p>
<ul>
<li>线性函数、仿射函数</li>
<li>几何平均、对数-行列式</li>
</ul>
<p><strong>$\alpha$-下水平集</strong>定义为</p>
<script type="math/tex; mode=display">
C_\alpha=\{x\in dom\:f\:|\:f(x)\leq \alpha\}</script><p>显然凸函数的下水平集仍然是凸集，反之不然。</p>
<p><strong>上境图</strong>定义为</p>
<script type="math/tex; mode=display">
epi\:f=\{(x,t)|x\in dom\:f\:,\:f(x)\leq t\}</script><p>一个函数是凸函数当且仅当它的上境图是凸集。一个函数是凹函数当且仅当它的<strong>亚图</strong>是凸集。</p>
<p><strong>Jensen不等式</strong>：如果f是凸函数，则</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq\theta f(x)+(1-\theta)f(y)</script><p>可以推广到多点、无穷项和、积分、期望等。</p>
<p><strong>保凸运算</strong>是保持函数凸性的运算</p>
<ul>
<li>非负加权求和</li>
<li>复合仿射映射</li>
<li>逐点最大（或上确界）：本质上是上境图的交集</li>
<li>一族仿射函数的逐点上确界</li>
</ul>
<p><strong>复合函数</strong>$f(x)=h(g(X))$的一些性质</p>
<ul>
<li>标量复合：h凸（凹）且单调，g凸或凹，则f是凸（凹），如果不再假设h、g可微，或者$dom\:g=R^n$，则要求h的扩展值延伸$\tilde{h}$单调。</li>
<li>矢量复合：和标量复合相似，但要求h的每个维度分量上单调</li>
</ul>
<p>特殊形式的<strong>最小化</strong>也可以得到凸函数，假设$f(x,y)$是凸函数，集合C是非空凸集，则</p>
<script type="math/tex; mode=display">
g(x)=inf_{y\in C}f(x,y)</script><p>若$g(x)&gt;-\infty$，则g关于x是凸函数。</p>
<p>定义f的<strong>透视函数</strong>$g(x,t)=tf(x/t)$，透视运算是保凸运算。</p>
<p>f的<strong>共轭函数</strong>定义为</p>
<script type="math/tex; mode=display">
f^*(y)=sup_{x\in dom\:f}(y^Tx-f(x))</script><p>显然$f^*$是凸函数。</p>
<p>共轭函数的例子：</p>
<ul>
<li>仿射函数$f(x)=ax+b$，$f^*$定义域为单点集{a}，值为-b。</li>
<li>负对数函数$f(x)=-log(x)$，$f^*(y)=-log(-y)-1$定义域为{y|y&lt;0}</li>
<li>指数函数$f(x)=e^x$，$f^*(y)=y\cdot log(y)-y$定义域为{y|y&gt;0}</li>
<li>严格凸的二次函数$f(x)=\frac12 x^TQx$，$f^*(y)=\frac12 y^TQ^{-1}y$</li>
<li>对数-行列式$f(X)=log(det(X^{-1}))$，$f*(Y)=log(det(-Y^{-1}))-n$</li>
<li>示性函数的共轭函数$f^*(y)=sup_{x\in S}y^Tx$，是集合S的支撑函数</li>
</ul>
<p><strong>Fenchel不等式</strong>：有定义可知$f(x)+f*(y)\geq x^Ty$</p>
<p>共轭的共轭：如果f是凸函数且是闭的，$f^{**}=f$</p>
<p><strong>可微</strong>函数f的共轭函数也称为函数f的<strong>Legendre变换</strong>。此时$y=\nabla f(x^*)$</p>
<p>复合仿射的共轭函数：f(Ax+b)的共轭函数为$f*(A^{-T}y)-b^TA^{-T}y$</p>
<p><strong>拟凸函数</strong>定义为满足<strong>定义域和所有下水平集都是凸集</strong>的函数。<strong>拟凹函数</strong>函数类似定义，如果一个函数拟凸且拟凹，则称为<strong>拟线性函数</strong>。</p>
<p>一些例子</p>
<ul>
<li>对数函数、上取整函数（都是拟线性函数）</li>
<li>线性分式函数（也是拟线性）</li>
</ul>
<p>拟凸函数的Jensen不等式：</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq max\{f(x),f(y)\}</script><p>在R上函数f拟凸当且仅当一下条件至少一个成立：</p>
<ul>
<li>f单调</li>
<li>存在一点c，在其左边f非增，在其右边f非减</li>
</ul>
<p>可微拟凸函数的充要条件：</p>
<ul>
<li>一阶条件：$f(y)\leq f(x) \Rightarrow \nabla f(x)^T(y-x)\leq 0$</li>
<li>二阶条件：$y^T\nabla f(x)=0\Rightarrow y^T\nabla^2 f(x)y \geq 0$</li>
</ul>
<p>保拟凸运算</p>
<ul>
<li>非负加权最大（可以扩展到逐点上确界）</li>
<li>拟凸函数和一个非减函数、仿射函数或线性分式函数复合</li>
<li>最小化也是保拟凸的</li>
</ul>
<p>拟凸函数可以通过<strong>一族凸函数</strong>进行表示。这些凸函数满足</p>
<script type="math/tex; mode=display">
f(x)\leq t \Leftrightarrow\phi_t(x)\leq0</script><p><strong>对数-凹函数</strong>和<strong>对数-凸函数</strong>定义为log(f)为凸函数和凹函数。非负凸（凹）函数是对数-凸（凹）函数；对数-凸（凹）函数是拟凸（凹）函数。</p>
<p><strong>二次可微</strong>函数f是对数-凸函数当且仅当</p>
<script type="math/tex; mode=display">
f(x)\nabla^2f(x)\succeq\nabla f(x)\nabla f(x)^T</script><p>对数-凸（凹）性对加法、乘法、积分、<strong>卷积</strong>封闭。</p>
<p>非负函数p的Laplace变换$P(z)=\int p(x)e^{-z^T x}dx$，是对数-凸函数。$M(z)=P(-z)$是矩生成函数，$log(M(z))$是累积量生成函数。</p>
<p><strong>广义不等式的单调性</strong>：$x\preceq_K y\Rightarrow f(x)\leq f(y)$，称函数<strong>K-非减</strong>。当上式严格成立时，称函数<strong>K-增</strong>。类似定义<strong>K-非增</strong>和<strong>K-减</strong>。</p>
<p>可微函数f，定义域是凸集，它是<strong>K-非减</strong>的，当且仅当$\nabla f(x)\succeq_{K*}0$。严格情形下反过来不一定正确。</p>
<p><strong>广义不等式的凸性</strong>：f是<strong>K-凸</strong>的，如果对于任意x，y，以及$0\leq\theta\leq 1，</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\preceq_K \theta f(x)+(1-\theta)f(y)</script><p>当$x\neq y$和$0&lt;\theta&lt;1$时上式严格成立，则称其为<strong>严格K-凸</strong>的。</p>
<p>一些例子</p>
<ul>
<li>当K为$R^N_+$时，即在每个分量上凸</li>
<li>当K为正定矩阵时，称为<strong>矩阵凸性</strong>。等价定义就是对任意z，$z^Tf(x)z$凸。例如$f(X)=XX^T$</li>
</ul>
<p>对偶刻画：f是K-凸的当且仅当对任意$w\succeq_{K^*}0$，$w^Tf$是凸的。</p>
<p><strong>可微的K-凸函数</strong>：充要条件</p>
<script type="math/tex; mode=display">
f(y)\succeq_K f(x)+Df(x)(y-x)</script><p>函数复合保留凸性的结论都可以推广到K-凸的情形。</p>
<h3 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h3><p>一般<strong>标准形式问题</strong></p>
<script type="math/tex; mode=display">
min\:f_0(x)</script><script type="math/tex; mode=display">
subject\:to\:f_i(x)\leq 0\:,\:i=1,...,m \\
h_i(x)=0\:,\:i=1,...,p</script><p><strong>最优值</strong>$p^*=inf\:f_0(x)$。如果$x^*$可行且$f_0(x^*)=p^*$，称$x^*$为<strong>最优点</strong>。最优点的集合称为<strong>最优集</strong>。最优集是空集，则称最优值<strong>不可得（不可达）</strong>。满足$f_0(x)\leq p^* + \epsilon$的可行解x称为<strong>$\epsilon-$次优</strong>。所有$\epsilon-$次优的集合称为<strong>$\epsilon-$次优集</strong>。</p>
<p>称可行解x为<strong>局部最优</strong>，如果存在$R&gt;0$，使得在$||z-x||_2\leq R$的条件下x是最优解。</p>
<p>等价问题：</p>
<ul>
<li>数乘</li>
<li>一一映射的变量代换</li>
<li>目标（约束）函数的单调变换</li>
<li>松弛变量替换不等式约束</li>
<li>显式/隐式约束替换</li>
<li>优化独立的部分变量</li>
<li>上境图形式</li>
</ul>
<p><strong>凸优化问题</strong>是形如</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq 0\:,\:i=1,...,m \\
a_i^Tx=b_i\:,\:i=1,...,p</script><p>相比一般标准形式，要求目标函数和约束函数是<strong>凸函数</strong>，等式约束必须是<strong>仿射</strong>的。显然它的<strong>可行集</strong>和<strong>最优集</strong>是凸的。所以，<strong>局部最优解就是全局最优解</strong>。($f_0$是拟凸函数的时候，称为<strong>拟凸优化</strong>)</p>
<p>可微函数$f_0$的最优性准则：$\forall y\:,\:\nabla f_0(x)^T(y-x)\geq 0$，相当于定义了可行集的一个支撑超平面。（拟凸问题中，这是个充分不必要条件）</p>
<p><strong>解决拟凸优化的一般方法</strong>是把$f_0$表示成一族凸函数，然后解决可行性问题。</p>
<p><strong>线性规划（LP）</strong>问题是</p>
<script type="math/tex; mode=display">
min\:c^Tx+d\\
subject\:to\:Gx\preceq h\\
Ax=b</script><p><strong>标准形式线性规划</strong>是</p>
<script type="math/tex; mode=display">
min\:c^Tx+d\\
subject\:to\:Ax=b\\
x\succeq0</script><p>可以通过引入松弛变量、把$x$分解为$x^+$和$x^-$把线性规划转换为标准形式。</p>
<p><strong>线性分式规划</strong>问题是</p>
<script type="math/tex; mode=display">
min\:f_0(x)=\frac{c^Tx+d}{e^Tx+f}\:,\:dom\:f_0=\{x|e^Tx+f>0\}\\
subject\:to\:Gx\preceq h\\
Ax=b</script><p>作变量替换$y=\frac{x}{e^Tx+f}$和$z=\frac{1}{e^Tx+f}$，可以转换为等价的线性规划。</p>
<p>线性分式规划的一个推广是<strong>广义线性分式规划</strong>，目标函数是r个线性分式的最大值，这是个拟凸优化。</p>
<p><strong>二次优化问题（QP）</strong>是</p>
<script type="math/tex; mode=display">
min\:(1/2)x^TPx+q^Tx+R\\
subject\:to\:Gx\preceq h\\
Ax=b</script><p>如果约束也是二次的，称为<strong>二次约束二次规划（QCQP）</strong>。</p>
<p><strong>二阶锥规划（SOCP）</strong>是</p>
<script type="math/tex; mode=display">
min\:f^Tx\\
subject\:to\:||A_ix+b_i||_2\leq c^T_ix+di\:,\:i=1,...,m\\
Fx=g</script><p>当$c_i=0$时，SOCP退化为QCQP。</p>
<p><strong>鲁棒线性规划</strong>：约束条件的系数为一个给定的椭球。</p>
<p><strong>随机约束下的线性规划</strong>：要求约束成立的概率</p>
<p><strong>几何规划（GP）</strong>是</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq 1\:,\:i=1,...,m \\
h_i(x)=1\:,\:i=1,...,p</script><p>其中$f_i$是<strong>正项式</strong>，$h_i$是<strong>单项式</strong>。通过$y_i=log(x_i)$的换元可以简单的转换为凸优化问题。</p>
<p><strong>广义不等式意义下的凸优化问题</strong>：</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\preceq_{K_i} 0\:,\:i=1,...,m \\
a_i^Tx=b_i\:,\:i=1,...,p</script><p>其中$f_i$是$K_i-$凸的。可行集和最优集也是凸的，任何局部最优都是全局最优。</p>
<p>广义不等式凸优化问题中，最简单的是<strong>锥规划</strong>：</p>
<script type="math/tex; mode=display">
min\:c^Tx\\
subject\:to\:Fx+g\preceq_K 0\\
Ax=b</script><p>当K为半正定矩阵锥时，相应锥问题称为<strong>半定规划（SDP）</strong>，这时不等式是<strong>线性矩阵不等式（LMI）</strong>。</p>
<script type="math/tex; mode=display">
\sum x_iF_i+G\preceq 0</script><p><strong>标准形式的SDP</strong>：</p>
<script type="math/tex; mode=display">
min\:tr(CX)\\
subject\:to\:tr(A_iX)=b_i\\
X\succeq0</script><p>注意tr(CX)是S上一般实值线性函数的形式。</p>
<p><strong>广义向量优化问题</strong>记为</p>
<script type="math/tex; mode=display">
min（关于K）\:f_0(x)\\
subject\:to\:f_i(x)\leq 1\:,\:i=1,...,m \\
h_i(x)=1\:,\:i=1,...,p</script><p>如果$f_0$是$K-$凸的，称为<strong>凸向量优化问题</strong>。</p>
<p>点$x^*$是<strong>最优</strong>的当且仅当<strong>可达目标值集合</strong>$O\subseteq f_0(x^*)+K$</p>
<p>点$x^*$是<strong>Pareto最优</strong>当且仅当$O\cap (f_0(x^*)-K)=\{f_0(x^*)\}$，可以证明Pareto最优值集合$P\subseteq O\cap bd\:O$。</p>
<p><strong>标量化</strong>是寻找Pareto最优的标准技术。选择任意$\lambda\succ_{K^*}0$，最优化$\lambda^Tf_0(x)$的最优解是Pareto最优的。</p>
<p><strong>多准则优化</strong>：当向量优化函数关于锥$K=R^q_+$时，称为多准则优化。多准则问题的Pareto最优值集合称为<strong>最优权衡曲面</strong>。我们通过加权来标量化多准则问题。</p>
<h3 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a>对偶</h3><p>考察标准形式优化问题</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq 0\\
h_i(x)=0</script><p><strong>Lagrange函数</strong>定义为</p>
<script type="math/tex; mode=display">
L(x,\lambda,\nu)=f_0(x)+\sum\lambda_if_i(x)+\sum\nu_ih_i(x)</script><p><strong>Lagrange对偶函数</strong>定义为Lagrange函数关于x取得的最小值</p>
<script type="math/tex; mode=display">
g(\lambda,\nu)=inf_xL(x,\lambda,\nu)</script><p>这是原问题$f_0(x)$的下界，即$\forall\lambda\succeq 0\:,\:g(\lambda,\nu)\leq p^*$。</p>
<p><strong>Lagrange对偶函数和共轭函数紧密相关：</strong>比如下面的优化问题</p>
<script type="math/tex; mode=display">
min\:f_0(x)\:subject\:to\:Ax\preceq b\:,\:Cx=d</script><script type="math/tex; mode=display">
g(\lambda,\nu)=-b^T\lambda-d^T\nu-f_0^*(-A^T\lambda-C^T\nu)</script><p><strong>Lagrange对偶问题</strong>表述为</p>
<script type="math/tex; mode=display">
max\:g(\lambda,\nu)\\
subject\:to\:\lambda\succeq 0</script><p>对偶问题的差值称之为<strong>最优对偶间隙</strong>=$p^*-d^*$。</p>
<p>如果$d^*=p^*$成立，那么<strong>强对偶性</strong>成立。一般情况下，强对偶性不成立，<strong>凸优化问题</strong>中强对偶性成立的条件称为<strong>约束准则</strong>。</p>
<p>一个简单的约束准则是<strong>Slater条件</strong>：存在一点$x\in relint\:D$，<strong>严格可行</strong>，即</p>
<script type="math/tex; mode=display">
f_i(x)<0\:,\:i=1,...,m,\:Ax=b</script><p>这个条件可以进一步改进为<strong>仿射条件不需要严格成立，其他条件严格成立</strong>。因而对于线性规划问题，根据Slater条件弱化形式，只要原问题可行，强对偶性都成立。</p>
<p>由此推论：<strong>矩阵对策的混合策略</strong>满足强对偶条件，所以知道对方策略并不影响博弈的策略。</p>
<h4 id="对偶问题的几何解释"><a href="#对偶问题的几何解释" class="headerlink" title="对偶问题的几何解释"></a>对偶问题的几何解释</h4><p>定义集合</p>
<script type="math/tex; mode=display">
G=\{(f_1(x),...,f_m(x),h_1(x),...,h_p(x),f_0(x)\}</script><p>很容易定义优化问题最优解</p>
<script type="math/tex; mode=display">
p^*=inf\{t|(u,v,t)\in G,u\preceq 0,v=0\}</script><p>对偶函数</p>
<script type="math/tex; mode=display">
g(\lambda,\nu)=inf\{(\lambda,\nu,1)^T(u,v,t)|(u,v,t)\in G\}</script><p>如果下确界有限，则不等式</p>
<script type="math/tex; mode=display">
(\lambda,\nu,1)^T(u,v,t)\geq g(\lambda,\nu)</script><p>定义了集合G的一个支撑超平面。假设有$\lambda\succeq 0$，那么$p^*\geq g(\lambda,\nu)$，即弱对偶性成立。</p>
<p>如果以G的上境图A来描述</p>
<script type="math/tex; mode=display">
A=\{(u,v,t)|\exists x\in D,f_i(x)\leq u_i,h_i(x)=v_i,f_0(x)\leq t\}</script><p>那么最优值</p>
<script type="math/tex; mode=display">
p^*=inf\{t|(0,0,t)\in A\}</script><p>同上也是定义了A的支撑超平面。特别的，因为$(0,0,p^*)\in bd\:A$，若对偶性成立。</p>
<p>在几何意义下，<strong>Slater条件意味着分离超平面必非竖直</strong>，强对偶成立。证明如下：先如上定义集合A，另一个凸集</p>
<script type="math/tex; mode=display">
B=\{(0,0,s)|s<p^*\}</script><p>可以找到超平面分离AB，因而$g(\lambda,\nu)\geq p^*$，然后通过说明对偶问题能达到最优，说明强对偶成立。</p>
<h4 id="鞍点解释"><a href="#鞍点解释" class="headerlink" title="鞍点解释"></a>鞍点解释</h4><p>弱对偶性可以描述为</p>
<script type="math/tex; mode=display">
sup_{\lambda\succeq 0}inf_x L(x,\lambda)\leq inf_x sup_{\lambda\succeq 0}L(x,\lambda)</script><p>强对偶性即为上式取等。</p>
<p>我们称一对$\hat{w}$，$\hat{z}$是<strong>鞍点</strong>如果</p>
<script type="math/tex; mode=display">
f(\hat{w},z)\leq f(\hat{w},\hat{z})\leq f(w,\hat{z})</script><p>上式意味着<strong>极大极小性质</strong>成立。</p>
<h4 id="最优性条件"><a href="#最优性条件" class="headerlink" title="最优性条件"></a>最优性条件</h4><p>如果找到对偶可行解$(\lambda,\nu)$那么就对原问题的最优值建立了一个下界。定义差值</p>
<script type="math/tex; mode=display">
f_0(x)-g(\lambda,\nu)</script><p>是<strong>对偶间隙</strong>。这可以用在优化算法中给出<strong>非启发式停止准则</strong>。</p>
<p>如果强对偶性成立，且$x^*,\lambda^*,\nu^*$取到最优，那么</p>
<script type="math/tex; mode=display">
\lambda_i^*f_i(x^*)=0</script><p>称为<strong>互补松弛性</strong>。</p>
<p>非凸问题的<strong>KKT条件</strong>：</p>
<script type="math/tex; mode=display">
\nabla f_0(x^*)+\sum \lambda_i^*\nabla f_i(x^*)+\sum v_i^* \nabla h_i(x^*)=0\\
f_i(x^*)\leq 0\\
h_i(x^*)=0\\
\lambda_i^*\geq 0\\
\lambda_i^* f_i(x^*)=0</script><p>KKT条件是任何一对原问题最优解和对偶问题最优解必须满足的条件。当原问题是<strong>凸优化问题</strong>时，满足KKT条件的点也是原、对偶问题的最优解。</p>
<h4 id="扰动问题"><a href="#扰动问题" class="headerlink" title="扰动问题"></a>扰动问题</h4><script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq u_i\\
h_i(x)=v_i</script><p>定义最优解为$p^*(u,v)$。假设原问题强对偶性成立并且最优值可以达到，那么</p>
<script type="math/tex; mode=display">
p^*(u,v)\geq p^*(0,0)-\lambda^{*T}u-\nu^{*T}v</script><h4 id="择一定理"><a href="#择一定理" class="headerlink" title="择一定理"></a>择一定理</h4><p>严格不等式系统的可行性</p>
<script type="math/tex; mode=display">
f_i(x)<0,\:h_i(x)=0</script><p>和</p>
<script type="math/tex; mode=display">
\lambda\succeq 0,\:g(\lambda,\nu)\geq0</script><p>是<strong>弱择一</strong>的。当原不等式系统是凸的，那么则是<strong>强择一</strong>的。</p>
<p>推导Farkas引理：考虑线性规划</p>
<script type="math/tex; mode=display">
min\:c^Tx\\
subject\:to\:Ax\preceq 0</script><p>和对偶问题</p>
<script type="math/tex; mode=display">
max\:0\\
subject\:to\:A^Ty+c=0,\:y\succeq 0</script><p>显然强对偶成立。可以证明<strong>Farkas引理</strong>：</p>
<script type="math/tex; mode=display">
Ax\preceq 0,\:c^Tx<0</script><p>和</p>
<script type="math/tex; mode=display">
A^Ty+c=0,\:y\succeq0</script><p>是一对强择一系统。</p>
<p><u>Lagrange对偶对广义不等式同样成立，对偶条件和KKT条件中$\lambda$的约束从$\geq 0$改为$\succeq_{K^*}0$。</u></p>
<p><a href="/2020/02/21/ConvexOptimization2/">下一篇：凸优化问题（算法与应用）</a></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>从四开始的汇编</title>
    <url>/2020/02/14/csapp10/</url>
    <content><![CDATA[<p><a href="/2020/02/08/csapp7/">上一篇：从三开始的汇编</a></p>
<h3 id="系统I-O"><a href="#系统I-O" class="headerlink" title="系统I/O"></a>系统I/O</h3><p>打开关闭文件/改变文件位置/读写文件</p>
<p>RIO包（Robust I/O)提供两类函数</p>
<ul>
<li>无缓冲的输入输出：直接在存储器和文件间传送数据</li>
<li>带缓冲的输入：rio_readlineb 他是线程安全的</li>
</ul>
<p>读取文件元数据：stat/fstat</p>
<p>内核用三个数据结构表示打开的文件：</p>
<ul>
<li>描述符表：每个进程有独立的描述符表，每个描述符表指向文件表的一个表项</li>
<li>文件表：文件表的表项包括当前的文件位置、引用计数和指向v-node的指针，所有进程共享</li>
<li>v-node表：包含stat大多数信息，所有进程共享</li>
</ul>
<p><em>共享文件即多个文件表指向一个v-node表</em></p>
<p>I/O重定向（&gt;）：拷贝旧的描述符表项到新的描述符表项</p>
<p>标准I/O：libc的fopen/fclose、fread/fwrite、fgets/fputs、scanf/printf</p>
<p>三个流stdin、stdout、stderr</p>
<p><img src="io.png" alt=""></p>
<p>一般使用标准I/O，但是网络输入输出等情况需要用低级Unix I/O（或者RIO）</p>
<p><u>这是因为Unix对网络的抽象为<em>套接字</em>类型文件，对流的限制和对套接字的限制会有冲突。标准I/O是在同一个流输入输出的，而套接字需要打开两个流一个读一个写。</u></p>
<a id="more"></a>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>网络是个I/O设备</p>
<p>最低层的是局域网LAN，流行的局域网技术是以太网Ethernet，每个以太网适配器有一个全球唯一的48位地址。使用网桥bridge可以将多个以太网段连接成桥接以太网bridged ethernet。</p>
<p>多个不兼容的局域网可以通过路由器router连接，组成互联网络internet。每台路由器对它连接的每个网络都有一个适配器（端口）。路由器也能连接高速点到点通话，这就是广域网WAN。</p>
<p>网络协议消除不同网络之间的差异，他需要两种基本能力：</p>
<ul>
<li>命名机制：一致的主机格式</li>
<li>传送机制：把数据捆扎成不连续片（称为包）</li>
</ul>
<h3 id="全球IP因特网Internet"><a href="#全球IP因特网Internet" class="headerlink" title="全球IP因特网Internet"></a>全球IP因特网Internet</h3><p>最成功的的互联网络的实现。</p>
<p>每台主机都实现TCP/IP协议，这实际上是个协议族。</p>
<p>IP协议提供基本的命名方法和传送机制；UDP扩展了IP协议，包可以在进程间传递；TCP则是一个复杂协议，提供进程间双向连接。</p>
<ul>
<li><p>主机集合被映射为一组32位的IP地址</p>
<p><em>用机构存放IP地址这一标量是套接字接口早期实现的不幸产物。</em></p>
<p>总是以大端法存放在包头，常以点分十进制表示。</p>
</li>
<li><p>这组IP地址被映射为一组被称为因特网域名的标识符</p>
<p>一级域名由ICANN定义，常见的有com、edu、gov、org、net</p>
<p>二级域名由ICANN各个授权代理分配</p>
<p>本机回传地址总是为localhost 127.0.0.1</p>
<p>一般域名和IP地址是一一映射，也有多个域名映射到多个IP地址的</p>
</li>
<li><p>主机上的进程能和其他任何主机上的进程通信</p>
<p>一个套接字是连接的一个端口，每个套接字都有相应的地址，是一个因特网地址和16位整数端口组成。客户端端口是内核自动分配的，称为临时端口；然而服务器端口通常是知名端口，如Web常用80，电子邮件使用25。连接由两端的套接字地址唯一确定。</p>
<p><img src="connect.png" alt=""></p>
</li>
</ul>
<h3 id="套接字端口"><a href="#套接字端口" class="headerlink" title="套接字端口"></a>套接字端口</h3><p>套接字接口（socket interface）是一组函数。</p>
<p><img src="socket.png" alt=""></p>
<p>套接字地址结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connet bind and accept)*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sa_family; <span class="comment">/*protocol family*/</span></span><br><span class="line">    <span class="keyword">char</span>           sa_data[<span class="number">14</span>]; <span class="comment">/*address data*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet-syle socket address structure*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sin_family; <span class="comment">/*address family (always AF_INET)*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sin_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP address in network*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端和服务器用socket函数创建一个套接字描述符。</p>
<p>客户端调用connect函数建立连接，得到的连接是套接字对(x:y, serv.sin_addr:serv.sin_port)刻画的。x是客户端IP地址，y是临时端口。</p>
<p>open_clientfd包装socket和connect函数。</p>
<p>open_listenfd包装socket、bind和listen函数。</p>
<p>accept等待客户端的连接请求。</p>
<h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>基于文本的应用级协议HTTP。Web内容可以用HTML来编写。</p>
<p>Web内容是与MIME（多用途国际邮件扩充协议，multipurpose Internet mail extensions)相关的字节序列。</p>
<p>URL可以用“？”分割文件名和参数，参数用“&amp;”隔开。</p>
<p>HTTP支持不同的方法包括GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE</p>
<p>HTTP请求由一个请求行和零个或更多请求报头，加上一个空行组成。请求行的形式是<code>&lt;method&gt;&lt;uri&gt;&lt;version&gt;</code>，请求报头的形式为<code>&lt;header name&gt;: &lt;header data&gt;</code>。</p>
<p>HTTP响应由一个响应行和零个或多个响应报头，加上响应主体组成。响应行格式为<code>&lt;version&gt;&lt;status code&gt;&lt;status message&gt;</code>。响应报头中最重要的是Content-Type告知类型和Content-Length指示大小。</p>
<p>CGI（通用网关接口Common Gateway Interface）提供标准解决服务动态内容的问题。服务器接收请求后，fork创建子进程，并调用execve在子进程上下文执行程序（CGI程序）。</p>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h5 id="基于进程的并发："><a href="#基于进程的并发：" class="headerlink" title="基于进程的并发："></a>基于进程的并发：</h5><p>fork、exec、waitpid</p>
<p>服务器并发的注意问题</p>
<ul>
<li>必须要SIGCHLD处理程序处理僵死子进程</li>
<li>父子进程必须关闭connfd的拷贝</li>
</ul>
<p>进程共享状态信息困难，为了共享信息，必须使用显式的IPC机制</p>
<h5 id="基于I-O多路复用的并发"><a href="#基于I-O多路复用的并发" class="headerlink" title="基于I/O多路复用的并发"></a>基于I/O多路复用的并发</h5><p>使用select函数，要求内核挂起进程，只有I/O事件发生才将控制返回。</p>
<p>优点是给了程序员更多的对程序行为的控制，流之间共享数据变得容易</p>
<p>缺点是编码复杂</p>
<h5 id="基于线程的并发"><a href="#基于线程的并发" class="headerlink" title="基于线程的并发"></a>基于线程的并发</h5><p>线程就是运行在进程上下文中的逻辑流。线程由内核自动调度，每个线程有自己的线程上下文。</p>
<p>线程上下文比进程上下文小得多，因而切换更快。线程没有严格的层次，而能对等的读写相同数据。</p>
<p>Posix线程是个标准接口。</p>
<p>线程存储器模型：根据存储类型映射到VM</p>
<ul>
<li>全局变量/静态变量：VM只包含它的一个实例</li>
<li>本地自动变量：每个线程的栈包含他自己所有本地自动变量的实例</li>
</ul>
<p>利用信号量实现互斥、共享资源</p>
<p>四个线程不安全函数</p>
<ul>
<li>不保护共享变量的函数</li>
<li>跨越多个调用的状态（比如随机数）</li>
<li>返回静态变量指针</li>
<li>调用线程不安全函数的函数</li>
</ul>
<p>竞争：一个线程要在另一个线程到达y点前到达x点，会发生竞争（race）。为了消除竞争，我们可以动态地为y分配一个独立的块并传递给线程例程一个指向这个块的指针。</p>
<p>信号量会导致一种错误叫死锁（deadlock），就是一组线程被阻塞，等待永远不真的条件。</p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>从三开始的汇编</title>
    <url>/2020/02/08/csapp7/</url>
    <content><![CDATA[<p><a href="/2020/01/29/csapp5/">上一篇：从二开始的汇编</a></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>C预处理器cpp 将 .c 翻译成 .i</p>
<p>C编译器cc1 将.i 翻译成汇编 .s</p>
<p>汇编器as 将 .s 翻译成可重定向目标文件 .o</p>
<p>连接器程序 ld 将 .o 结合起来创建可执行文件</p>
<p>连接器的两个任务</p>
<ul>
<li>符号解析 symbol resolution 将每个符号引用和符号定义联系起来</li>
<li>重定位 relocation 将符号定义与存储器位置联系起来</li>
</ul>
<p>目标文件</p>
<ul>
<li>可重定位目标文件</li>
<li>可执行目标文件</li>
<li>共享目标文件</li>
</ul>
<p>最早的Unix使用.out，现代Unix使用ELF，Windows NT使用COFF的变种PE。</p>
<a id="more"></a>
<h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>一个典型的ELF可重定位目标文件格式。</p>
<p><img src="elf.png" alt=""></p>
<ul>
<li>ELF头以16字节序列描述生成该文件的系统的字的大小和字节顺序，然后是语法分析和解释（包括ELF头大小、目标文件类型、机器类型、节头部表的文件偏移等。</li>
<li>.text：已编译的代码</li>
<li>.rodata：只读数据</li>
<li>.data：初始化的全局变量</li>
<li>.bss：未初始化的全局变量</li>
<li>.symtab：符号表，存放程序中定义和引用的函数和全局变量</li>
<li>.rel.text：.text中位置的列表</li>
<li>.rel.data：全局变量的重定位信息</li>
<li>.debug：调试符号表 -g才会得到</li>
<li>.line ：行号 -g才会得到</li>
<li>.strtab：字符串表，包括.symtab和.debug和节头部的名字</li>
</ul>
<p><u>static变量是在符号表定义</u>。</p>
<p><u>重载函数类名为原始名字前加上名字中字符数，比如Foo被编码成3Foo；方法被编码为原始方法加上类名加上每个参数的单字母编码，比如Foo::bar(int, long)被编码为bar__3Fooil。</u></p>
<p><u>多重定义：会选择强定义（初始化的定义），不同类型可能导致错误。</u></p>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>代码的重定位条目放在.rel.text</p>
<p>已初始化数据的重定位条目放在.rel.data</p>
<p>重定位条目格式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">/* offset of the refence to relocate*/</span></span><br><span class="line">    <span class="keyword">int</span> symbol:<span class="number">24</span>, <span class="comment">/*symbol the reference should point to*/</span></span><br><span class="line">    	type:<span class="number">8</span>; <span class="comment">/*Relocation type 有11中不同类型*/</span></span><br><span class="line">&#125; Elf32_Rel</span><br></pre></td></tr></table></figure>
<p>重定位符号引用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">refptr = s + r.offset;</span><br><span class="line"><span class="comment">/* 相对引用 */</span></span><br><span class="line"><span class="keyword">if</span> (r.type == R_386_PC32) &#123;</span><br><span class="line">    refaddr = ADDR(s) + r.offset;</span><br><span class="line">    *refptr = (<span class="keyword">unsigned</span>)(ADD(r.symbol) + *refptr - refaddr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绝对引用 */</span></span><br><span class="line"><span class="keyword">if</span> (r.type == R_386_32) &#123;</span><br><span class="line">    *refptr = (<span class="keyword">unsigned</span>)(ADD(r.symbol) + *refptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>下图是个典型的ELF可执行文件</p>
<p><img src="elfexe.png" alt=""></p>
<p>ELF头部包含程序的入口（entry point)，.init定义了初始化函数，不再需要.rel。</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库（.o）是所有相关的目标打包称为独立的文件。</p>
<p>优点：不需要重复定义、只拷贝被引用的模块、只需要较少的库文件名</p>
<p><em>AR工具创建库</em></p>
<h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><p>.so（Unix）或者.dll（Windows）</p>
<p>解决静态库需要显式链接、浪费资源的问题</p>
<p><em>gcc -shared -fPIC 创建库</em> </p>
<blockquote>
<p>PIC是位置无关代码 position-independent code，通过全局偏移量表实现，但是有性能缺陷。</p>
<p>因而ELF有延迟绑定lazy binding技术，通过GOT和PLT。</p>
<p>GOT[1] 是连接器标识信息，GOT[2] 是连接器入口点</p>
<p>调用时控制传递到PLT中，然后通过GOT做间接跳转。第一次调用时，GOT跳转回PLT下一条指令，通过将标识信息压入栈中并跳转动态链接器，覆盖GOT跳转地址。以后调用时，只是间接引用而没有额外开销。</p>
</blockquote>
<p><u>应用程序还可能在运行时要求链接共享库而无需在编译时链接。（dlopen、dlsym、dlclose）</u></p>
<h3 id="异常控制流（Exception-Control-Flow）"><a href="#异常控制流（Exception-Control-Flow）" class="headerlink" title="异常控制流（Exception Control Flow）"></a>异常控制流（Exception Control Flow）</h3><p>异常处理是在内核模式（kernel mode）</p>
<p>每个异常有一个异常号。异常可分为四类</p>
<ul>
<li>中断 interrupt：来自I/O设备，异步</li>
<li>陷阱 trap：有意的异常，提供系统调用接口，比如system call</li>
<li>故障 fault</li>
<li>终止 abort</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个执行中的程序的实例</p>
<ul>
<li>独立的逻辑控制流</li>
<li>私有的地址空间</li>
</ul>
<p>内核为每个进程维持一个上下文context，内核通过上下文切换context switch来实现多任务。在进程执行的某些时刻，内核可以通过调度器进行调度schedule，选择一个新的进程运行。</p>
<p>获取ID getpid（进程PID） getppid（父进程PID）</p>
<p><u>fork在新的子进程中运行相同程序，而execve函数在当前进程上下文加载并运行新程序，会覆盖当前进程的地址，仍然有相同的PID。Unix和Web服务器大量使用fork和execve。</u></p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>终止而未被回收的称为僵死进程zombie，它们仍然消耗系统资源。</p>
<ul>
<li>判定等待集合成员 pid</li>
<li>修改默认行为 WNOHANG 和 WUNTRACED</li>
<li>waitpid函数</li>
<li>检查已回收子进程的退出状态 WIFEXITED等 见wait.h</li>
<li>错误条件：没有子进程 waitpid=-1 ECHILD/被信号中断 返回-1 EINTR</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>Unix信号允许进程中断其他进程。</p>
<p>一个发送而没被接受的信号为待处理信号pending signal。一个类型至多只有一个待处理信号，多余的会简单丢弃。一个待处理信号只能被接受一次。</p>
<p>发送信号的机制基于进程组。一个负的PID会导致信号被发送到进程组PID中的每个进程。</p>
<p>可以通过signal函数修改接收到信号的默认行为。</p>
<p>几个信号处理中的问题</p>
<ul>
<li>信号会阻塞和不会排队等待：改成while尽可能多的接收信号</li>
<li>系统调用被中断的可能性：while手动重启</li>
</ul>
<p>Signal是sigaction的一个包装函数，提供了可移植的信号处理。</p>
<p>sigprocmask显式改变阻塞信号集合。</p>
<p><u>同步流以避免并发问题。这个问题称之为竞争race，通过阻塞信号来就解决。暴露竞争的问题的方法就是随机决定父进程和子进程执行的顺序。</u></p>
<h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><p>用户级异常控制流，直接从一个函数跳转另一个函数。</p>
<p>setjmp和longjump（catch相当于setjmp，throw相当于longjump</p>
<h3 id="虚拟存储器VM"><a href="#虚拟存储器VM" class="headerlink" title="虚拟存储器VM"></a>虚拟存储器VM</h3><p>虚拟寻址时，CPU生成虚拟地址来访问主存。</p>
<p><img src="pte.png" alt=""></p>
<p>这里DRAM缓存是全相连的。</p>
<p><u>页面调度</u></p>
<p>虚拟存储器作为存储器管理工具</p>
<ul>
<li>简化链接</li>
<li>简化加载</li>
<li>简化共享</li>
<li>简化存储器分配</li>
</ul>
<p>同时能通过读写权限控制保护存储器。</p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>符号定义</p>
<ul>
<li>N 虚拟空间地址数 M 物理空间地址数 P 页大小</li>
<li>VPO 虚拟页面偏移 VPN 虚拟页号 </li>
<li>TLBI TLB索引 TLBT TLB标记</li>
<li>PPO 物理页面偏移 PPN 物理页号</li>
<li>CO 缓冲块偏移</li>
<li>CI 高速缓存索引 CT 高速缓存标记</li>
</ul>
<p>地址翻译：虚拟地址空间VAS到物理地址空间PAS的映射</p>
<p><img src="translate.png" alt=""></p>
<p>MMU利用VPN选择适当的PTE，得到PPN，PPO和VPO是相同的。</p>
<p><u>利用TLB加速地址翻译：TLB是个小的虚拟寻址的缓存，每行保存一个PTE块。VPN的t个低位组成TLB索引，其余n-p-t位是TLB标记。</u></p>
<p><u>每次MMU从TLB取出相应PTE，如果TLB不命中，则从L1缓存取出PTE并存放在TLB。</u></p>
<p><img src="tlb.png" alt=""></p>
<p><u>多级页表：减小主存压力，地址翻译也并不比单级页表慢很多。</u></p>
<p>Core i7地址翻译概况如下</p>
<p><img src="corei7translate.png" alt=""></p>
<p><u>优化地址翻译：CPU翻译时，发送VPN到MMU，发送VPO到L1，同时进行。</u></p>
<h3 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h3><p>存储器映射是将虚拟存储器区域和一个磁盘上的对象关联起来。这个对象可以是普通文件，也可以是匿名文件。一旦一个虚拟页面被初始化了，就在一个专门的交换文件（也叫做交换空间或交换区域）之间转换。</p>
<p><u>一个对象可以被映射到虚拟存储器的一个区域，要么作为共享对象，要么作为私有对象。共享对象即使被映射到了多个共享区域，也只需存放它的一个拷贝。私有对象使用写时拷贝copy-on-write的技术充分使用了稀有的物理存储器。</u></p>
<h3 id="动态存储器分配"><a href="#动态存储器分配" class="headerlink" title="动态存储器分配"></a>动态存储器分配</h3><p>低级的mmap和munmap可以创建和删除虚拟存储器的区域。</p>
<p>动态存储器分配dynamic memory allocater更方便且更好移植。它维护一个进程的虚拟存储器区域，称为堆heap。每个进程维护一个brk，指向堆的顶部。</p>
<ul>
<li><p>显式分配</p>
<p>malloc和free（C++里的new和delete）</p>
<p>想要已初始化的动态存储calloc，改变已分配块大小realloc</p>
<p>sbrk通过移动brk指针来改变堆</p>
</li>
<li><p>隐式分配</p>
<p>也叫垃圾收集器，自动释放未使用的已分配块，见JAVA等高级语言。</p>
</li>
</ul>
<p>分配器的目标</p>
<ul>
<li><p>最大化吞吐率</p>
</li>
<li><p>最大化利用率</p>
<p>利用率低是因为碎片fragmentation</p>
<ul>
<li>内部碎片：已分配块比有效载荷大（对齐约束）</li>
<li>外部碎片：组织/放置/分割/合并 空闲块（空闲链表）</li>
</ul>
</li>
</ul>
<h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>因为双字的对齐约束，块大小总是8的倍数，块大小最低三位总是0，所以只需存储块大小的29个高位，剩余3位编码其他信息。1表示已分配，0表示空闲。</p>
<p><img src="list.png" alt=""></p>
<p>优点是简单，缺点是开销与块总数呈线性关系。</p>
<p>放置策略：首次适配、下次适配（对首次适配的改进）、最佳适配</p>
<p>合并策略：立即合并（会产生抖动？）、推迟合并</p>
<p><u>Knuth提出边界标记（boundary tag），通过在块结尾处添加脚部（头部的副本），允许常数时间内对前面块进行合并。</u></p>
<h4 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h4><p>加入pred和succ的指针，使得开销与<strong>空闲块</strong>总数呈线性关系</p>
<p>缺点是空闲块必须足够大，潜在提高了内部碎片程度</p>
<h4 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h4><p>维护多个空闲链表，每个表中块大小大致相等</p>
<ul>
<li>简单分离存储：快速但是容易造成碎片</li>
<li>分离适配：GNU malloc就是这种方法</li>
<li>伙伴系统：特殊的分离适配，都是2的幂次；块地址和伙伴地址只有一位不同、主要缺点是要求块大小为2的幂次，导致显著的内部碎片。</li>
</ul>
<h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>C和C++保守的垃圾收集器：每个可达的都被正确标记了，但一些不可达的也被错误标记为可达了（因为int或float可以伪装成指针，而收集器无法判断）</p>
<p>Mark&amp;Sweep：由于C的保守，需要维护一个已分配块的平衡二叉树</p>
<h3 id="常见存储器错误"><a href="#常见存储器错误" class="headerlink" title="常见存储器错误"></a>常见存储器错误</h3><ul>
<li>间接引用坏指针：错误的把int或float当做指针</li>
<li>读未初始化的存储器：<strong>堆存储器</strong>不总是初始化为零，正确方法是用calloc代替malloc或者显式初始化</li>
<li>缓冲区溢出</li>
<li>假设指针和对象相同大小</li>
<li>引用不存在的变量/空闲堆栈</li>
<li>存储器泄露（不释放空间）</li>
</ul>
<p><a href="/2020/02/14/csapp10/">下一篇：从四开始的汇编</a></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>从二开始的汇编</title>
    <url>/2020/01/29/csapp5/</url>
    <content><![CDATA[<p><a href="/2020/01/10/csapp4/">上一篇：从一开始的汇编</a></p>
<h3 id="编写高效程序"><a href="#编写高效程序" class="headerlink" title="编写高效程序"></a>编写高效程序</h3><ul>
<li>合适的算法和数据结构</li>
<li>高效执行的源代码</li>
</ul>
<p>GCC 命令行标志 -01 到 -03 提供不同程度的优化</p>
<p>妨碍优化的几个因素</p>
<ul>
<li><p>存储器别名使用：两个指针可能指向同一个存储器</p>
</li>
<li><p>函数调用：大多数编译器不会判断函数是否有副作用，并保持所有函数调用不变</p>
<p>可以使用内联函数替换（将函数代码展开）对此进行优化（-finline或者-02以上）</p>
</li>
</ul>
<p>运行时间可以通过最小二乘拟合得到，线性因子系数称为每元素的周期数（CPE）的有效数</p>
<p>CPE是主要的优化目标</p>
<p>两种优化界限：</p>
<ul>
<li>延迟界限：指令级并行的能力</li>
<li>吞吐量界限：终极限制，处理器功能单元的计算能力</li>
</ul>
<p>整体操作：分为指令控制单元ICU和执行单元EU，可以乱序执行指令</p>
<p>功能单元的性能：</p>
<ul>
<li>延迟：完成运算总时间</li>
<li>发射：连续运算需要的时钟周期数，发射时间为1即为完全流水线化的</li>
</ul>
<a id="more"></a>
<h3 id="循环里的优化"><a href="#循环里的优化" class="headerlink" title="循环里的优化"></a>循环里的优化</h3><ul>
<li>代码移动：将strlen或vec_length的计算移出循环（特别是strlen，因为它是O(n)的）</li>
<li>减少过程调用</li>
<li>减少不必要的存储调用：在临时变量里存放结果代替直接访问</li>
<li>-02 的优化：会最后将结果写到目标位置，而不是重复读写</li>
<li><u>循环展开：通过增加每次迭代计算的元素数量，减少循环迭代次数。比如在求数组累加和的时候，每次计算两个元素。因为减少了循环分支以及减少了关键路径操作数量，可以提升延迟界限。但是并不能提升浮点数计算的CPE。</u></li>
<li><u>并行计算：将一组合并运算分割成两个或更多的部分，最后合并结果以提高性能。但是需要注意浮点乘法和加法由于四舍五入或溢出的不可结合性，可能会改变最终结果。</u></li>
<li><u>重新结合变换：在循环中改变元素合并顺序，减少关键路径操作。同上，可能改变最终结果。</u></li>
</ul>
<p>高级设计、编码原则、低级优化</p>
<h3 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h3><p>SSE=Streaming SIMD Extensions</p>
<p>SIMD是单指令多数据Single-Instruction, Multiple-Data</p>
<p>16字节的XMM可以存放多个值，因此指令会读取多个值并行计算</p>
<p>-msse4</p>
<h3 id="一些限制"><a href="#一些限制" class="headerlink" title="一些限制"></a>一些限制</h3><ul>
<li>寄存器溢出</li>
<li>分支预测和预测错误处罚<ul>
<li>可预测的分支不太影响</li>
<li>使用功能式风格的代码（用条件操作计算值），而非命令式（用条件语句来选择更新）</li>
</ul>
</li>
<li>加载/存储性能</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>程序剖析 GCC -pg </p>
</li>
<li><p>Amdahl定律 </p>
<p>加速比S，其中\alpha是加速部分所占时间比例，k是加速到的倍数。</p>
<script type="math/tex; mode=display">
S=\frac{1}{1-\alpha+\alpha/k}</script></li>
</ul>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul>
<li>高速缓存存储器</li>
<li>主存储器</li>
<li>磁盘</li>
</ul>
<p><img src="memory.png" alt=""></p>
<p>随机访问存储器（RAM），SRAM更快更贵，作为高速存储，一般不超过几MB，而DRAM有可以有几GB</p>
<ul>
<li><p>静态RAM（SRAM）</p>
<p>存储在双稳态单元，用六晶体管来实现，可以无限保持在两个不同状态，其他状态都是不稳定的，即使有干扰，也能在干扰消除时恢复稳态。</p>
</li>
<li><p>动态RAM（DRAM）</p>
<p>存储为对一个电容充电，因此对干扰敏感。</p>
</li>
<li><p>传统DRAM</p>
<p>DRAM芯片中的单元被分成d个超单元(supercell)，每个超单元有w个DRAM单元，信息通过引脚(pin)流入流出。</p>
</li>
<li><p>存储器模块</p>
<p>DRAM芯片包装在存储器模块里，常见的168引脚的双列直插存储器模块DIMM，以64位为块，也有72个引脚的单列直插存储器模块SIMM，以32位为块。存储器将地址A转换为超单元地址，然后广播到每个DRAM，每个DRAM输出超单元地址处的8位内容，然后将他们合并为64位双字。</p>
</li>
<li><p>增强的DRAM</p>
<ul>
<li>快页模式 FPM DRAM 允许对同一行连续地址从缓存区访问</li>
<li>扩展数据输出 EDO DRAM 允许单独CAS信号时间上更紧密</li>
<li>同步 SDRAM 用外部时钟信号上升代替控制信号，输出更快</li>
<li>双倍速率同步DRAM（DDR SDRAM）通过两个时钟作为控制，不同DDR是根据预取缓存区大小来划分的 DDR（2位）DDR2（4位） DDR3（8位）</li>
<li>Rambus DRAM 最大带宽更高</li>
<li>视频RAM（Video RAM） 对内部缓存区整个内容移位</li>
</ul>
</li>
<li><p>非易失性存储器</p>
<p>即使断电也能保存，ROM、PROM、EPROM、EEPROM、闪存</p>
</li>
<li><p>读取主存</p>
<p>I/O通过主线(bus)</p>
</li>
</ul>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘存储，比DRAM慢10万倍，比SRAM慢100万倍。</p>
<p>磁盘由多个盘片（platter）构成，盘片有表面（surface）和主轴（spindle），有固定的旋转速率（54k-150k RPM）。每个表面是一组同心圆（磁道track）组成，每个磁道划分为一组扇区（sector）用以储存等长的数据，扇区之间有间隙（gap）。</p>
<p>磁盘操作时，通过传动臂（actuator arm）连接到读写头，通过寻道（seek）定位到磁道上，然后进行读写。读写时间=寻道时间+旋转时间+传送时间，其中寻道时间和旋转延迟大致相等。</p>
<p>磁盘还有逻辑磁盘块，维护逻辑块好和磁盘扇区的映射关系。</p>
<p>连接到I/O设备：通用串行总线（USB）、图形卡、主机总线适配器（将磁盘连接到I/O总线，包括SCSI和SATA）</p>
<p><img src="IObus.png" alt=""></p>
<p>磁盘控制器收到CPU读命令后，将逻辑块号翻译成扇区地址，然后将这些内容直接传送到主存，不需要CPU干涉，称为直接存储器访问（DMA）。</p>
<p>固态硬盘 SSD：基于闪存技术，更快能耗也更低。</p>
<p>趋势：降低成本（增加密度）比降低访问时间更容易。</p>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>DRAM和磁盘的性能滞后于CPU的性能。现代计算机频繁使用基于SRAM的高速缓存试图弥补这一差距（利用局部性）。</p>
<p>一个编写良好的程序具有良好的局部性（倾向于引用最近引用数据的邻近数据或其本身）。</p>
<p>步长为k的引用模式：stride-k reference pattern，一个连续向量中，每隔k个元素进行访问，随着步长的增加，空间局部性下降。步长为1的引用模式有良好的空间局部性。</p>
<p>取指令的局部性：循环具有好的时间局部性。</p>
<h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p>离CPU越远的存储器缓存越大，延迟越高，传送的块越大。</p>
<p>核心思想是k层的存储设备作为k+1层的存储设备的缓存</p>
<ul>
<li>缓存命中</li>
<li>缓存不命中<ul>
<li>冷缓存（强制性不命中）：缓存是空的</li>
<li>冲突不命中</li>
<li>容量不命中</li>
</ul>
</li>
</ul>
<p>高速缓存（S，E，B，m）的通用组织：S个高速缓存组数组，每个组含有E个高速缓存行，每个行有B字节的数据块，1个有效位和t个标记位。m个地址划分为t个标记位，s个组索引位和b个块偏移位。</p>
<p><img src="cache.png" alt=""></p>
<p><u>抖动冲突不命中问题：即使有良好的空间局部性，引用还是会导致冲突不命中，因为这些块被映射到了同一个高速缓存组，一个简单的方法就是在数组结尾放B子节的填充。</u></p>
<p><u>用中间位做索引，使得连续存储器映射到不同的高速缓存块。</u></p>
<p>写的问题：</p>
<ul>
<li>直写 write-through</li>
<li>写回 write-back 块要被驱逐时才更新存储器，能显著减少总线流量，但是需要维护额外的修改位</li>
<li>写分配 write-allocate（加载之后写）/ 非写分配 not-write-allocate</li>
</ul>
<p><u>越往下层传送时间更差，因此越可能使用写回。</u></p>
<p>举例：矩阵乘法 C=AB</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>乘法版本</th>
<th>存储次数</th>
<th>A不命中次数</th>
<th>B不命中次数</th>
<th>C不命中次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>ijk&amp;jik</td>
<td>0</td>
<td>0.25</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>jki&amp;kji</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>kij&amp;ikj</td>
<td>1</td>
<td>0</td>
<td>0.25</td>
<td>0.25</td>
</tr>
</tbody>
</table>
</div>
<p>kij和ikj性能最好。</p>
<p><a href="/2020/02/08/csapp7/">下一篇：从三开始的汇编</a></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年初的几部电影</title>
    <url>/2020/01/29/2020%E5%B9%B4%E5%88%9D%E7%9A%84%E5%87%A0%E9%83%A8%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<h3 id="教宗的承继-8-5-10"><a href="#教宗的承继-8-5-10" class="headerlink" title="教宗的承继 8.5/10"></a>教宗的承继 8.5/10</h3><p>源自真实的故事，讲述了2013年罗马教皇权力更迭背后的故事。剧情简介可以参看豆瓣</p>
<blockquote>
<p>主教贝尔格利奥对教会的发展方向感到十分失望，因此向教皇本笃申请在 2012 年退休。然而，面对丑闻和自我怀疑，善于内省的教皇本笃召见对他最严厉的批判者和未来的继任者来到罗马，在梵蒂冈的围墙之内，展开了一场传统与进步、罪恶与宽恕之间的斗争，这两位截然不同的人直面各自的过去，以图寻找共同点，以及为全世界十亿信徒开创未来。</p>
</blockquote>
<p>影片基于两位教皇的观点展开演绎，本笃十六世象征着保守，本片中也处处表现出保守和传统，比如强调宗教的意义，提出对传统的恢复；而方济各一世则代表着自由主义，他批评教会和教宗，在底层的人群中受到欢迎。以方济各向本笃申请退休为契机，两人在梵蒂冈相会。借着这两位教皇对于教会发展方向的深入探讨，影片试图表达自己在其中的观点。</p>
<p>来自南美洲的导演费尔南多无疑是阿根廷人方济各的支持者，在片中方济各表现出近乎完美的形象：进步现代、关注经济、关心民众、抨击教会弊端，而本笃十六世只能在方济各的各种问题的责问下无力地表示</p>
<blockquote>
<p>I don’t agree with anything you just said。</p>
</blockquote>
<p>在片中，为了展现出全面的自由主义的胜利，本笃表示”听不到上帝的声音了“，因而要退位；而那个不时出现打断剧情的提醒他步行的医疗仪器也似乎为了反衬他的保守。但是，我们可以看到，片中着重讲述了方济各的过去，但是对本笃的过去却没有多少笔墨。影片关注了方济各指出的教会内部腐败的问题、经济问题、贫民问题，但也没能回答本笃关注的同性恋、宗教意义的问题。我们很难说对于一个教宗而言，哪一个问题更加重要。</p>
<p>当然，作为一部电影而言，无疑是成功的。两位教皇用拉丁语/西班牙语/英语轮番探讨宗教的意义显得很decent。看到两位爷爷一起吃披萨、看足球，甚至一起跳探戈、讨论beatles，就是一件很有趣的事情了。（虽然说我是不信的……但方济各一直以来的形象确实能支撑起这样的剧情。</p>
<p>最后我还是觉得方济各就是宗教界的戈尔巴乔夫。</p>
<a id="more"></a>
<h3 id="囧妈-6-0-10"><a href="#囧妈-6-0-10" class="headerlink" title="囧妈 6.0/10"></a>囧妈 6.0/10</h3><p>囧妈大火无疑是占了大年初一抖音免费观看的热度。（虽然我觉得确实是很有意义的一种尝试，但还是要说，徐峥聪明在于商人而非导演</p>
<p>囧妈的剧本完成度比较差（就算是小成本电影），相比于它的几部前作也大大不如。影片分两线，一条是主角和母亲的感情线，另一条是主角和妻子的感情/商业竞争线。前一条线是主线，后一条线就显得无关紧要，感觉有强行附会的嫌疑。</p>
<p>在妻子感情线里，把主角母亲想控制主角的心情等同于主角想控制主角妻子的心情，这是完全不同的感情啊，毕竟主角和妻子从没有表现出“爱情”，而看得出主角母亲溢出屏幕的母爱。影片塑造了一个近乎完美的妻子：性格独立、工作能力强、孝敬主角母亲，而主角一直不肯离婚，乃至在妻子的事业不断制造麻烦的唯一理由就是一句轻描淡写的”还爱着“，这是何等的扭曲啊。</p>
<p>主线里母亲为了圆梦莫斯科大剧院表演，坐火车去莫斯科（这里我就不吐槽身为负责人怎么这么随便了），主角由于意外决定陪母亲去。明显由于母子这个主题没有很好的素材，影片成了很多段与主题无关的独立故事的合集。俄罗斯娜塔莎突然出现，和主角一路缠绵，然后飘然下车；母亲下车后遭遇熊出没，得到猎人解救（典型的机械降神）；赶不上火车，然后乘着热气球感到剧院……整个故事充满着机械降神的情节，而缺乏整体的连贯性。</p>
<p>最后说一下这部影片的优点，第一肯定是特殊时期娱乐大众，第二是母亲这个主题表现得有点做作，不过可以接受，第三是贾冰这个列车员可以（他在春晚的小品也可以）。</p>
<h3 id="1917-8-0-10"><a href="#1917-8-0-10" class="headerlink" title="1917 8.0/10"></a>1917 8.0/10</h3><p>传闻中的一镜到底（虽然是伪一镜，但都是长镜头的组合</p>
<p>整体的故事性偏弱，情节没有太突出的地方</p>
<blockquote>
<p>1917年，第一次世界大战进入最激烈之际，两个年仅16岁的英国士兵接到的命令，需立即赶往死亡前线，向那里的将军传达一个“立刻停止进攻”讯息。 时间只有八小时，武器弹药有限，无人知晓前方敌况：死亡寂静之地、布满尸体的铁丝网、突入其来的敌军、随时毙命的危险境况…… </p>
</blockquote>
<p>一镜到底确实有很好的代入感，看得出导演和演员在拍摄中应该付出了比寻常多几倍的努力。抛开外在形式上的创新，这部电影也有感人之处。</p>
<p>下士Schofield片头到片尾都是靠在树下休息，但可以想到，经历了这么多他的心境一定不一样了；将军说的一段话（今天撤退，明天又要进攻，反反复复的命令更加折磨）虽然不深刻，但是直击人心。另外教堂那一段的光影效果值得关注一下。</p>
<h3 id="利刃出鞘-8-5-10"><a href="#利刃出鞘-8-5-10" class="headerlink" title="利刃出鞘  8.5/10"></a>利刃出鞘  8.5/10</h3><p>原以为是一部本格推理，但是和我想的不太一样。整个推理没什么大的漏洞，硬要说就是警察太菜了，不仅第一时间的证据找不到，还让人炸了证据中心……</p>
<p>电影开头对每个人有一段问询，每个人都说了一些假话，侦探007（丹尼尔·克雷格）轻易地推理出了每个人隐瞒了什么秘密。然后….影片直接告诉了我们整个作案过程，之后就是最后的大反转。<strong>这是一部悬疑喜剧，而非烧脑的推理剧。</strong></p>
<p>值得一提的是，片中藏了很多小彩蛋，还有政治隐喻。比如</p>
<blockquote>
<p>贵为美国白人的众卿家内讧一无所获，仰望着从巴基斯坦人手里买来的生父老宅； 身为巴西移民的本宫站在老宅阳台，端起“My House My Rules My Coffee”杯具轻呷，俯视着一切。 哈哈哈哈……吐！</p>
</blockquote>
<p>就是<em>粉刺</em>川普大帝的移民政策。还有那个用装饰画挡住的窗，也暗指了偷渡。</p>
<h3 id="别告诉她-7-5-10"><a href="#别告诉她-7-5-10" class="headerlink" title="别告诉她 7.5/10"></a>别告诉她 7.5/10</h3><p>偶然看见的电影，故事并不复杂</p>
<blockquote>
<p>影片讲述一个华人家庭的奶奶被诊断罹癌，但家人选择隐瞒奶奶，假借一场婚礼的名义让所有家人回家见奶奶最后一面，但在纽约长大的碧莉（奥卡菲娜饰演）认为知道自己病况是奶奶的人权，因此在华人家庭中上演一场中西文化冲突，一部寻根家庭喜剧。</p>
</blockquote>
<p>整体上探讨了中西文化，但是影片却意外地西方。相比之下，我猜导演更了解西方（或者为了面向西方社会），所以对于西方的个人主义和bili所主张的知情权有较为深刻的认识，而对中国的人情只有一句“生命是集体的”来概括。整体比较轻松，观影体验还行。</p>
<h3 id="哪吒之魔童降世7-5-10"><a href="#哪吒之魔童降世7-5-10" class="headerlink" title="哪吒之魔童降世7.5/10"></a>哪吒之魔童降世7.5/10</h3><p>去年以来名声很大的一部动画电影</p>
<blockquote>
<p>天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？</p>
</blockquote>
<p>动画效果感觉比不上玄机娘娘（反正都是“国产动漫最高水平“啦）</p>
<p>细细看完，却发现设定上有问题。哪吒生性顽劣因为魔丸附身（考虑到哪吒对关心爱护他的父母师父也这么残暴），那么灵丸附身的小龙就不会因为龙族水淹陈塘关了。</p>
<p>更重要的是，仔细一想这部电影三观并不是那么正。哪吒魔丸附身，被村民视为妖怪，之后再李靖等人的感化之下，想要反抗命运。但是那句高燃台词“我命由我不由天”却是对小龙喊出的；而在天尊引天雷的时候，哪吒却束手就擒。细想之下，是魔丸还是灵丸本是天尊所定，那些村民不过是无知的愚民罢了，而真正应该反抗的命运应该是天尊（或者其化身天雷）。影片消解了这层对天的反抗，就退化成了纨绔子弟哪吒作威作福多年终于良心发现的故事了。</p>
<h3 id="爱尔兰人-9-5-10"><a href="#爱尔兰人-9-5-10" class="headerlink" title="爱尔兰人 9.5/10"></a>爱尔兰人 9.5/10</h3><p>爱尔兰人没能得奥斯卡奖很可惜（虽然因为《教父》在前，这也是必然的</p>
<blockquote>
<p>　　《爱尔兰人》为马丁·斯科塞斯执导的传奇巨制，罗伯特·德尼罗、阿尔·帕西诺和乔·佩西主演。通过二战老兵弗兰克·希兰的视角，讲述了战后美国有组织犯罪的故事。弗兰克·希兰是一名骗子和杀手，曾经在 20 世纪最恶名昭彰的人物身边工作。该电影跨越数十年，记录了美国历史上最大的悬案之一，即传奇工会领袖吉米·霍法失踪案，以宏大的故事之旅，展现有组织犯罪的隐秘通道：其内部运作、仇敌以及与主流政治的瓜葛。</p>
</blockquote>
<p>电影属于半纪实的性质，讲述了黑帮的往事。电影中的很多事情都是历史上的悬案，很难说黑帮的这些人物到底在里面参与了多少。整部电影很明显带着《教父》的风格（从整体的布景、到人物的谈吐甚至是四个小时的片长），讲述故事的方式也有《阿甘正传》的味道（意外参与了当时的重大事件的感觉），以主角黑帮杀手Frank Sheeran的视角展开意识流的叙事。</p>
<p>整部片中没有什么伟光正的人物，气氛都比较压抑。三个老戏骨扮演着三个黑道的重要人物，互相飙戏确实精彩（虽然都不是什么好人</p>
<p>Frank作为黑帮杀手，冷酷无情而且计划周密，是个心狠手辣的人物。他因为工会的起诉搭上了黑帮的船，而后一步步成长为令人闻风丧胆的“爱尔兰人”。影片从Frank的自传改编，选取了一些看起来比较可信的片段（虽然也很大一部分不可考证，依旧被认为悬案）。Frank对于生死的思考是超越常人的（当然不是说这种理解是正确的），他对黑帮的一切都感到坦然，因而保持着绝对的冷静，到最后一刻问及Hoffa的死时第一反应还是找律师。可以说，电影塑造的Frank的形象，诠释了一个近乎完美的黑帮杀手。</p>
<p>Russell是黑帮大佬，提携Frank的恩人。地位很高，但是身形很小，说话很轻柔。片中表现的性格还是比较单一的（当然演技没的说</p>
<p>Jimmy Hoffa是历史上的传奇人物，创立了美国分布最广的工会，鼎盛时有两百三十万会员，而最后又神秘失踪，称为一桩悬案。剧里的Hoffa也表现出了对工会的热爱和重视，他在重新夺回工会的时候揭露黑帮和工会的内幕交易也并非只是为了竞选，相比之下他可能不是那么“黑帮”，所以最后Hoffa一定会和黑帮分道扬镳。</p>
<p>最后Frank杀Hoffa这段是全剧的高潮，整个刺杀行动策划的看着随意，实则周密。比如对一切一无所知的大侄子运送Frank和Hoffa，降低了Hoffa的警惕心；Frank必须亲手杀了Hoffa，一方面为了让Hoffa彻底放心，另一方面也为了表明立场。刺杀过程中也有死鱼的暗喻这样的表现手法，Frank一瞬间的犹豫……在Hoffa被刺杀之后的四十分钟倒显得比较平淡，这些辉煌一时的黑帮大佬也都渐渐老去（情节虽然缓和，镜头也放的很慢，但就是有一种深深的悲凉？</p>
<p>最后片中两句著名的黑话（看了影评才懂…当时就这么划过去了</p>
<blockquote>
<p>Jimmy Hoffa：”I heard you paint houses“</p>
<p>Frank Sheeran：”I do my own carpentry work, too.” </p>
</blockquote>
]]></content>
      <categories>
        <category>喵后记</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>吉斯尼亚传奇</title>
    <url>/2020/01/12/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%8701/</url>
    <content><![CDATA[<h2 id="序章：初雪"><a href="#序章：初雪" class="headerlink" title="序章：初雪"></a>序章：初雪</h2><p>​        今年的冬天虽然来得晚了些，但是来得够快。十二月初的时候，京城还像是延续刚刚过去的夏天一样，温暖的仿佛阳春三月。然而人们根本没有想到，寒气来的迅猛，就连北面大兴安岭绵延的山脉，也只能略微延缓寒气南下的步伐。短短几天里，凛冬真的来了，京城冷的像另一个世界。永定河结起了薄冰，西山上萧瑟地立着满山枯木，庭院里只有几枝梅花迎风傲立，人们都已经不愿意出门了，街上仅存的行人也都把自己裹得严严实实。</p>
<a id="more"></a>
<p>​        罗一成清早就出门了，带着他的行李箱，迎着略有些刺骨的微风，登上了前往机场的列车。由于才刚刚过七点，车上还很空，罗一成随意地坐下了。他看向窗外，只见清冷的早晨，整个城市都昏昏沉沉；加上这是个没有生气的季节，平日里喜爱热闹的鸟儿，也消踪匿迹了，一切都显得灰蒙蒙的。<br>​        列车跑的很快，罗一成的思绪没有飘多远，就发现自己已经出了城。城外的这一站，平日就没什么人，罗一成心想，他往车里挪了挪，以躲避车外的冷风。一声提示音响起来，车厢的门整齐地打开了，猛地一阵风吹过，罗一成缩了缩脖子，那一瞬间他仿佛看见车外一只橘猫跑过，但仔细看去却没了踪迹。罗一成转头看去，却发现隔壁车厢不知何时上来了个三十岁左右的年轻人。</p>
]]></content>
      <categories>
        <category>吉斯尼亚传奇</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>从一开始的汇编</title>
    <url>/2020/01/10/csapp4/</url>
    <content><![CDATA[<p><a href="/2020/01/02/csapp3/">上一篇：从零开始的汇编</a></p>
<h3 id="Y86-一个玩具"><a href="#Y86-一个玩具" class="headerlink" title="Y86(一个玩具)"></a>Y86(一个玩具)</h3><p>定义Y86指令集只处理四字节的数据</p>
<p><img src="y86.png" alt=""></p>
<ul>
<li>将movl拆分成四个指令，显示指定源和目的。i表示立即数，r表示寄存器，m表示存储器。</li>
<li>OPl包含四个整数操作，分别是addl,subl,andl,xorl</li>
<li>三个条件码ZF、SF和OF</li>
<li>7个跳转指令jmp、jle、jl、je、jne、jge、jg</li>
<li>6个条件传送cmovle、cmovl、cmove、cmovne、cmovge、cmovg（属于rrmovl类）</li>
<li>call、ret、pushl、popl不变</li>
<li>halt相当于X86里的hlt，会直接导致处理器暂停</li>
</ul>
<p>指令集模拟器YIS</p>
<a id="more"></a>
<h3 id="HCL"><a href="#HCL" class="headerlink" title="HCL"></a>HCL</h3><p>位级电路-&gt;字级电路</p>
<p>多路复用电路</p>
<p>ALU（算术单元）：根据输入做一次算术运算</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器操作时，输出会一直保存在当前寄存器状态上，直到时钟信号上升。</p>
<p><img src="register.png" alt=""></p>
<p>这是一个典型的寄存器文件，这样一个多端口随机访问存储器允许同时进行多个读写操作。向寄存器文件写入字是由时钟信号控制的。</p>
<p><img src="register2.png" alt=""></p>
<p>数据存储器只有一个输入输出。</p>
<p><em>现实中更为复杂</em></p>
<h3 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h3><p>一个指令的各个阶段</p>
<ul>
<li>取指 fetch</li>
<li>解码 decode</li>
<li>执行 execute（包括计算和设置条件码）</li>
<li>访存 memory</li>
<li>写回 write back</li>
<li>更新PC PC update，将PC设置成下一条指令的地址</li>
</ul>
<p>大多数指令比较简单，最难实现的应该是pushl和popl（举例如下）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>call Dest</th>
<th>ret</th>
</tr>
</thead>
<tbody>
<tr>
<td>fetch</td>
<td>icode: ifun &lt;-M[PC]<br>valC&lt;-M[PC+1]<br>valP&lt;-PC+5</td>
<td>icode: ifun &lt;-M[PC]<br>valP&lt;-PC+1</td>
</tr>
<tr>
<td>decode</td>
<td>valB&lt;-R[%esp]</td>
<td>valA&lt;-R[%esp]<br>valB&lt;-R[%esp]</td>
</tr>
<tr>
<td>execute</td>
<td>valE&lt;-valB-4</td>
<td>valE&lt;-valB+4</td>
</tr>
<tr>
<td>memory</td>
<td>M[valE]&lt;-valP</td>
<td>valM&lt;-M[valA]</td>
</tr>
<tr>
<td>write back</td>
<td>R[%esp]&lt;-valE</td>
<td>R[%esp]&lt;-valE</td>
</tr>
<tr>
<td>PC update</td>
<td>PC&lt;-valC</td>
<td>PC&lt;-valM</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>pushl rA</th>
<th>popl rA</th>
</tr>
</thead>
<tbody>
<tr>
<td>fetch</td>
<td>icode: ifun &lt;-M[PC]<br> rA:rB&lt;-M[PC+1]</td>
<td>icode: ifun &lt;-M[PC]<br/> rA:rB&lt;-M[PC+1]</td>
</tr>
<tr>
<td>decode</td>
<td>valP&lt;-PC+2</td>
<td>valP&lt;-PC+2</td>
</tr>
<tr>
<td>execute</td>
<td>valA&lt;-R[rA] <br/>valB&lt;-R[%esp]</td>
<td>valA&lt;-R[%esp]<br/> valB&lt;-R[%esp]</td>
</tr>
<tr>
<td>memory</td>
<td>valE&lt;-valB+(-4)</td>
<td>valE&lt;-valB+4</td>
</tr>
<tr>
<td>write back</td>
<td>M[valE]&lt;-valA <br/>R[%esp]&lt;-valE</td>
<td>valM&lt;-M[valA]<br/> R[%esp]&lt;-valE <br/>R[rA]&lt;-valM</td>
</tr>
<tr>
<td>PC update</td>
<td>PC&lt;-valP</td>
<td>PC&lt;-valP</td>
</tr>
</tbody>
</table>
</div>
<p>一种顺序实现如下</p>
<p><img src="seq.png" alt=""></p>
<h3 id="SEQ实现"><a href="#SEQ实现" class="headerlink" title="SEQ实现"></a>SEQ实现</h3><p>所使用的常数如下（除了指令之外还包括了状态码）</p>
<p><img src="seqconstant.png" alt=""></p>
<h4 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h4><ul>
<li>instr_valid：合法指令</li>
<li>need_regids：包括寄存器指示符</li>
<li>need_valC：包含常数</li>
</ul>
<p><img src="seqfetch.png" alt=""></p>
<p>增加器产生值p+1+need_rigids+4*need_valC</p>
<h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><p><img src="seqfetch.png" alt=""></p>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p><img src="seqexecute.png" alt=""></p>
<h4 id="访存阶段"><a href="#访存阶段" class="headerlink" title="访存阶段"></a>访存阶段</h4><p><img src="seqmemory.png" alt=""></p>
<h4 id="更新PC阶段"><a href="#更新PC阶段" class="headerlink" title="更新PC阶段"></a>更新PC阶段</h4><p>HCL描述如下</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">int <span class="attr">new_pc</span> = [</span><br><span class="line">	<span class="attr">icode</span> == ICALL: valC; <span class="comment"># 调用</span></span><br><span class="line">	<span class="attr">icode</span> == IJXX &amp;&amp; Cnd: valC; <span class="comment"># 跳转</span></span><br><span class="line">	<span class="attr">icode</span> == IRET: valM; <span class="comment"># 返回</span></span><br><span class="line">	<span class="number">1</span>: valP; <span class="comment"># 默认</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>SEQ的问题在于每个单元只在整个时钟周期的一部分时间里被使用</p>
<p>理想流水线：划分成n个相互独立的周期，每个阶段需要的时间是原来的1/n，其他因素：</p>
<ul>
<li>不一致的划分</li>
<li>流水线过深，反而降低收益（寄存器的延迟）</li>
</ul>
<p>现代处理器采用15或更深的流水线，因而需要划分指令的执行减小延迟、设计更好的流水线寄存器、设计时钟传播网络</p>
<p><u>带反馈的流水线：处理有数据相关的相邻指令</u></p>
<h3 id="Y86流水线的实现"><a href="#Y86流水线的实现" class="headerlink" title="Y86流水线的实现"></a>Y86流水线的实现</h3><h4 id="SEQ-：重新安排计算阶段"><a href="#SEQ-：重新安排计算阶段" class="headerlink" title="SEQ+：重新安排计算阶段"></a>SEQ+：重新安排计算阶段</h4><p>PC计算移到了时钟周期开始</p>
<p><img src="seq+.png" alt=""></p>
<h4 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h4><p><img src="pipe.png" alt=""></p>
<p>寄存器按以下方式标号</p>
<ul>
<li>F 保存计数器的预测值</li>
<li>D 保存指令信息</li>
<li>E 保存指令和寄存器文件读出的值</li>
<li>M 保存执行指令的结果</li>
<li>W 提供计算出来的值，提供返回地址</li>
</ul>
<h4 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h4><p>除了条件转移指令和ret之外，我们能够根据取指信息确定下一条指令地址。</p>
<p>这里分支预测总是预测选择了条件分支，预测PC为valC。 <u>这种预测成功率约为60%。其他还有根据分支地址高低进行预测（分支地址低则预测选择分支），成功率约为65%，这种改进源自循环是由后向分支结束这一事实。</u></p>
<p>ret只是简单地暂停处理新指令。<u>大多数程序可以利用栈顶的值作为预测的返回值。</u></p>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>加入暂停（nop）自动产生的nop指令为气泡（bubble）</p>
<p><img src="bubble.png" alt=""></p>
<p>但这会导致流水线暂停过长，降低整体吞吐量。</p>
<p>解决方法是将要写的值传到流水线寄存器E作为源操作数。在译码阶段发现有写回阶段对寄存器未进行的写，则用这个值作为源操作数。</p>
<p>这样就有5个转发源e_valE,m_valM,M_valE,W_valM,W_valE</p>
<p>有两个不同的转发目的valA, valB</p>
<p>在结构中就是加入Sel+Fwd A和Fwd B的模块更新valA和valB</p>
<p><u>加载互锁和转发技术结合起来处理所有可能的数据冒险</u></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>没有实际的异常指令</p>
<p>异常处理的几个细节</p>
<ul>
<li>多条指令引起异常</li>
<li>分支预测错误取消了异常指令</li>
<li>异常指令之后的指令改变了部分状态</li>
</ul>
<p><u>当处于访存或写回阶段中的指令导致异常时，流线控制逻辑必须禁止更新条件码或数据存储器。</u></p>
<h4 id="PIPE各阶段"><a href="#PIPE各阶段" class="headerlink" title="PIPE各阶段"></a>PIPE各阶段</h4><ul>
<li><p>取指：增加了f_pred</p>
</li>
<li><p>译码和写回：使用sel+fwd A和fwd B </p>
<p>五个转发源的顺序很重要，应该是e_dstE, m_valM, M_valE, W_valM, W_valE</p>
</li>
<li><p>执行阶段</p>
</li>
<li><p>访存阶段</p>
</li>
</ul>
<h4 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h4><p>处理4种控制</p>
<ul>
<li><p>ret</p>
<p>ret后加入三个bubble</p>
<p>但是取指阶段没有办法插入bubble，实际处理中ret后加入三个rrmovl+bubble效果等价</p>
</li>
<li><p>加载/使用冒险</p>
<p>气泡+转发</p>
</li>
<li><p>预测错误的分支</p>
<p>在下一个周期译码和执行阶段加入bubble 指令排除预测错误的指令</p>
</li>
<li><p>异常</p>
</li>
</ul>
<p>我们可以由此产生各个流水线控制信号的HCL描述</p>
<p><u>遇到加载/使用冒险和ret指令组合时，寄存器D不应该插入气泡。</u></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><script type="math/tex; mode=display">
CPI（每指令周期数）=1+C_b/C_i 
=1+\sum 指令频率*条件频率*气泡数</script><p>其中C_b是气泡数，C_i是指令数，分加载/使用、预测错误、ret三种情况考虑。</p>
<h4 id="未完成工作"><a href="#未完成工作" class="headerlink" title="未完成工作"></a>未完成工作</h4><ul>
<li>多周期指令：计算单元做不同运算所需时间不同</li>
<li>存储系统的接口</li>
</ul>
<p><a href="/2020/01/29/csapp5/">下一篇：从二开始的汇编</a></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的汇编</title>
    <url>/2020/01/02/csapp3/</url>
    <content><![CDATA[<h3 id="汇编代码后缀"><a href="#汇编代码后缀" class="headerlink" title="汇编代码后缀"></a>汇编代码后缀</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>代码</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>b</td>
<td>1个字节</td>
</tr>
<tr>
<td>short</td>
<td>w</td>
<td>2个字节</td>
</tr>
<tr>
<td>int/long int/char*</td>
<td>l</td>
<td>4个字节</td>
</tr>
<tr>
<td>float</td>
<td>s</td>
<td>4个字节</td>
</tr>
<tr>
<td>double</td>
<td>l</td>
<td>8个字节</td>
</tr>
<tr>
<td>long double</td>
<td>t</td>
<td>8/10/12个字节(根据系统)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>寄存器是用来存储整数数据和指针的。<br><img src="cpu.png" alt=""></p>
<h3 id="三种操作数指示符："><a href="#三种操作数指示符：" class="headerlink" title="三种操作数指示符："></a>三种操作数指示符：</h3><p>第一种：立即数 $<br>格式 $Imm 操作数值 Imm<br>第二种：寄存器 用E来表示寄存器，R[E]来表示它的值<br>格式 E 操作数值 R[E]<br>第三种：存储器 用M_b[Addr]来表示从Addr开始b个字节的引用<br>一般格式 Imm(E_b, E_l, s) 操作数值 M[Imm+R[E_b]+R[E_l]\dot s]</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>mov<br>movb/movw/movl 传送字节/字/双字<br>movs 符号扩展<br>movsbw/movsbl/movswl<br>movz 零扩展<br>movzbw/movzbl/movzwl</p>
<p>pushl 双字压栈<br>popl 双字出栈</p>
<p>leal S D 加载有效地址 &amp;S-&gt;D<br>和movl的区别在于leal赋值的是地址，movl赋值的是值</p>
<a id="more"></a>
<h3 id="整数算术操作"><a href="#整数算术操作" class="headerlink" title="整数算术操作"></a>整数算术操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>INC D</td>
<td>加一</td>
</tr>
<tr>
<td>DEC D</td>
<td>减一</td>
</tr>
<tr>
<td>NEG D</td>
<td>取负</td>
</tr>
<tr>
<td>NOT D</td>
<td>取补</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>ADD S, D</td>
<td>相加</td>
</tr>
<tr>
<td>SUB S, D</td>
<td>相减 D-S</td>
</tr>
<tr>
<td>IMUL S, D</td>
<td>相乘</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>XOR S, D</td>
<td>异或</td>
</tr>
<tr>
<td>OR S, D</td>
<td></td>
</tr>
<tr>
<td>AND S, D</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>SAL k, D</td>
<td>左移 D&lt;&lt;k</td>
</tr>
<tr>
<td>SHL k, D</td>
<td>同上</td>
</tr>
<tr>
<td>SAR k, D</td>
<td>算术右移 D&gt;&gt;k （填上符号位），特别的，SAR D为SAR $1, D的简写</td>
</tr>
<tr>
<td>SHR k, D</td>
<td>逻辑右移 D&gt;&gt;k  （填上0）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="特殊算术操作"><a href="#特殊算术操作" class="headerlink" title="特殊算术操作"></a>特殊算术操作</h3><p>imull S 有符号全64位乘法 S*R[%eax]-&gt;R[%edx]:R[%eax]<br>mull S 无符号全64位乘法 S*R[%eax]-&gt;R[%edx]:R[%eax]<br>cltd 转为四字 R[%eax]-&gt;R[%edx]:R[%eax]<br>idivl S 有符号除法 R[%edx]:R[%eax] mod S -&gt; R[%edx]<br>                             R[%edx]:R[%eax] / S -&gt; R[%eax]<br>divl S 无符号除法 同上</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CF 进位 ZF 零 SF 负数 OF 补码溢出</p>
<p>只设置条件码而不改变目的寄存器的值</p>
<ul>
<li>CMP S2, S1 基于S1-S2</li>
<li>TEST S2, S1 基于S1&amp;S2</li>
</ul>
<p>SET系列指令 操作条件码存储一个字节的存储器位置</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>无条件跳转 jmp</p>
<ul>
<li>jmp .L1 直接跳转</li>
<li>jmp *%eax 间接跳转</li>
</ul>
<p>条件跳转(只能是直接跳转）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>跳转条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>je/jz</td>
<td>ZF</td>
<td>相等或零</td>
</tr>
<tr>
<td>jne/jnz</td>
<td>~ZF</td>
<td></td>
</tr>
<tr>
<td>js</td>
<td>SF</td>
<td>负数</td>
</tr>
<tr>
<td>jns</td>
<td>~SF</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>jg/jnle</td>
<td>~(SF^OF)&amp;~ZF</td>
<td>大于（有符号）</td>
</tr>
<tr>
<td>jge/jnl</td>
<td>~(SF^OF)</td>
<td>大于等于（有符号）</td>
</tr>
<tr>
<td>jl/jnge</td>
<td>SF^OF</td>
<td>小于（有符号）</td>
</tr>
<tr>
<td>jle/jng</td>
<td>(SF^OF)&#124;ZF</td>
<td>小于等于（有符号）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ja/jnbe</td>
<td>~CF&amp;~ZF</td>
<td>大于（无符号）</td>
</tr>
<tr>
<td>jae/jnb</td>
<td>~CF</td>
<td>大于等于（无符号）</td>
</tr>
<tr>
<td>jb/jnae</td>
<td>CF</td>
<td>小于（无符号）</td>
</tr>
<tr>
<td>jbe/jna</td>
<td>CF&#124;ZF</td>
<td>小于等于（无符号）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><p>cmovl S, R 如果&lt;，用S代替R<br>cmov系列指令和上面j系列相似<br><strong>不是所有的条件表达式可以用条件传送来编译</strong>，因为代码会对then-expr和else-expr求值，如果有一个值不存在或者操作了全局变量，即使测试为假，也会导致错误</p>
<h3 id="switch方法"><a href="#switch方法" class="headerlink" title="switch方法"></a>switch方法</h3><p>在.rodata(Read-Only Data)里声明switch情况分配地址<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">.L7</span>:</span><br><span class="line">  <span class="string">.long</span> <span class="string">.L3</span></span><br><span class="line">  <span class="string">.long</span> <span class="string">.L2</span></span><br><span class="line">  <span class="string">.long</span> <span class="string">.L4</span></span><br><span class="line">  <span class="string">...</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><br>然后使用间接跳转<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jmp</span> *.L7(, %eax, <span class="number">4</span>) <span class="meta"># Goto *jt[index]</span></span><br></pre></td></tr></table></figure><br>值得注意的是，<strong>当switch的case值不连续且跨度足够大的时候，会编译成multi-if的形式</strong></p>
<p><em>有传闻显示，编译器还有二分区间这样的骚操作</em></p>
<h3 id="程序栈"><a href="#程序栈" class="headerlink" title="程序栈"></a>程序栈</h3><p>单个过程分配的那部分栈称为栈帧，最顶端以两个指针界定<br>%ebp为帧指针，%esp为栈指针，程序执行时，栈指针可以移动，一般相对于帧指针进行访问<br><img src="stackframe.png" alt=""></p>
<p>转移控制指令</p>
<ul>
<li>call Label 过程调用</li>
<li>call *Operand 过程调用</li>
<li>leave 为返回准备栈</li>
<li>ret 从过程调用中返回<br>call指令将控制转移到一个函数开始，ret指令返回到call指令之后的那条指令<br>leave指令将%esp移到%ebp然后弹出%ebp。如果函数要返回整数或指针的话，寄存器%eax可以用来返回值。</li>
</ul>
<p>一个典型的过程调用示例</p>
<p><img src="stackframeExample.png" alt=""></p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">caller</span>:</span><br><span class="line">  pushl %ebp</span><br><span class="line">  movl %esp, %ebp</span><br><span class="line">  subl $24, %esp</span><br><span class="line">  ... <span class="comment"># 赋值</span></span><br><span class="line">  call swap_add</span><br><span class="line">swap_add:</span><br><span class="line">  pushl %ebp <span class="comment"># Save old %ebp</span></span><br><span class="line">  movl %esp, %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  ... <span class="comment"># 主体代码</span></span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret <span class="comment"># 返回值在%eax</span></span><br><span class="line"><span class="keyword">caller</span>: <span class="comment"># 之后的代码</span></span><br><span class="line">  ... </span><br><span class="line">  imull %edx, %eax</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p><em>leave效果上等价于几个popl</em>，但效率上更高</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>声明方式：T A[N]</p>
<p>假设整型数组E存在%edx，整数索引i存在%ecx</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>int*</td>
<td>x_E</td>
<td>movl %edx, %eax</td>
</tr>
<tr>
<td>E[i]</td>
<td>int</td>
<td>M[x_E+4i]</td>
<td>movl (%edx,%ecx,4), %eax</td>
</tr>
<tr>
<td>&amp;E[i]</td>
<td>int*</td>
<td>x_E+4i</td>
<td>leal (%edx, %ecx, 4), %eax</td>
</tr>
</tbody>
</table>
</div>
<h3 id="异质数据结构"><a href="#异质数据结构" class="headerlink" title="异质数据结构"></a>异质数据结构</h3><p>struct声明数据结构类型</p>
<p>union允许以多种类型引用一个对象-&gt;一般需要创建一个标签字段</p>
<p><u>数据对齐：要求short地址必须为2的倍数，int等地址必须为4的倍数</u></p>
<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><ul>
<li>开始和停止：<ul>
<li>quit</li>
<li>run</li>
<li>kill</li>
</ul>
</li>
<li>断点：<ul>
<li>break sum</li>
<li>break *0x00000000</li>
<li>delete 1</li>
</ul>
</li>
<li>执行：<ul>
<li>stepi n 执行n条指令，默认1条</li>
<li>nexti 以程序为单位执行</li>
<li>continue</li>
<li>finish</li>
</ul>
</li>
<li>检查代码（反汇编）：<ul>
<li>disas</li>
<li>disas sum</li>
<li>disas 0x00000000 反汇编地址附近的函数</li>
<li>disas 0x00000000 0x000000ff</li>
</ul>
</li>
<li>检查数值 <ul>
<li>print $eax（十进制）</li>
<li>print /x $eax(十六进制)</li>
<li>print <em>(int </em>)($ebp+8) 输出%ebp+8处的整数</li>
</ul>
</li>
<li>有用的信息<ul>
<li>info frame 当前栈帧</li>
<li>info registers 所有寄存器</li>
</ul>
</li>
</ul>
<h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><ul>
<li>栈随机化</li>
<li>栈保护</li>
<li>限制存储可执行代码的存储器</li>
</ul>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>指针和声明为长整型的变量都是64位，用movq和addq代替movl和addl</p>
<p>相应的运算和控制也要加上q</p>
<p>返回值放在寄存器%rax中</p>
<p>许多函数没有生成栈帧，通过寄存器传递参数，参数传递见下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作数大小</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>%rdi</td>
<td>%rsi</td>
<td>%rdx</td>
<td>%rcx</td>
<td>%r8</td>
<td>%r9</td>
</tr>
<tr>
<td>32</td>
<td>%edi</td>
<td>%esi</td>
<td>%edx</td>
<td>%ecx</td>
<td>%r8d</td>
<td>%r9d</td>
</tr>
<tr>
<td>16</td>
<td>%di</td>
<td>%si</td>
<td>%dx</td>
<td>%cx</td>
<td>%r8w</td>
<td>%r9w</td>
</tr>
<tr>
<td>8</td>
<td>%dil</td>
<td>%sil</td>
<td>%dl</td>
<td>%cl</td>
<td>%r8b</td>
<td>%r9b</td>
</tr>
</tbody>
</table>
</div>
<p>需要帧栈的情况如下</p>
<ul>
<li>局部变量太多</li>
<li>局部变量是数组或结构</li>
<li>用&amp;计算局部变量地址</li>
<li>需要传递栈上的参数</li>
<li>需要保存它的状态</li>
</ul>
<p>此时x86-64一般会在过程开始后固定栈指针%rsp，并通过栈指针访问</p>
<p><strong>相比之下，x86-64的代码比IA32更简洁且需要较少存储器访问</strong></p>
<p><img src="cpu64.png" alt=""></p>
<p>16个通用目的寄存器中，6个用来传递参数（%rdi,%rsi,%rdx,%rcx,%r8,%r9），6个被调用者保存的临时寄存器（%rbx,%rbp,%r12~%r15)，1个保存返回值(%rax)，1个栈指针(%rsp)，剩下的是调用者保存的寄存器（%r10,%r11）</p>
<p>由于没有帧指针寄存器，可以用寄存器%rbp作为通用寄存器</p>
<p><em>跳转到ret前会加rep作为空操作（使处理器适当预测ret目的以加速）</em></p>
<p><a href="/2020/01/10/csapp4/">下一篇：从一开始的汇编</a></p>
]]></content>
      <categories>
        <category>猫爪记</category>
        <category>Computer-Science</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>吉斯尼亚传奇N</title>
    <url>/2019/09/28/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%870n/</url>
    <content><![CDATA[<p>​    经过漫漫长夜的飞行，飞机缓缓地降落在跑道上。地面上星星点点的小房子渐渐明晰起来，地上还在闪耀着的跑道灯，在晨曦中显得暗淡无力，罗一成恍惚间意识到，他终于来到了吉斯尼娅，这个古老而年轻的国度，这个陌生而熟悉的城市了。</p>
<a id="more"></a>
<p>​    飞机在跑道上开始减速，随着一抹晨光从飞机的后弦方向斜斜地照射过来，整个飞机仿佛也开始苏醒了。乘客们的交谈声渐渐响了起来，打破了延续十七个小时的安静；机舱里再次活跃了起来，有些乘客已经开始急急忙忙地收拾自己的行李了。</p>
<p>​    不过，这些都似乎与罗一成毫无关系。</p>
<p>​    罗一成也开始清醒过来，十七个小时的飞行中，他完完全全地沉浸在自己的迷梦里，这是一个旖旎多姿的梦，如果他的梦有颜色的话，那一定是金色的：从小罗一成就听闻吉斯尼娅的种种传奇，带着对吉斯尼娅美好的想象，只不过他从没想过，他会如今天一般真正来到吉斯尼娅，至少，不会来得那么快。</p>
<p>​    在他的印象里，或者说，在大多数人眼里，吉斯尼娅是危险而神秘的，而罗一成似乎对这样捉摸不定的东西尤其有好感；那些有关吉斯尼娅的美丽传说就仿佛五光十色的肥皂泡，越是缥缈、越是虚幻、越是引人入迷。</p>
]]></content>
      <categories>
        <category>吉斯尼亚传奇</category>
      </categories>
      <tags>
        <tag>琉璃猫</tag>
      </tags>
  </entry>
  <entry>
    <title>A review of Hamlet</title>
    <url>/2019/04/09/claudius/</url>
    <content><![CDATA[<p><strong>Claudius</strong> - The villain of the play, a calculating, ambitious politician, driven by his sexual appetites and his lust for power, but he occasionally shows signs of guilt and human feeling—his love for Gertrude, for instance, seems sincere. </p>
<p><strong>Hamlet</strong> - melancholy, bitter, and cynical, full of hatred for his uncle’s scheming and his mother’s frailty. </p>
<p><strong>Gertrude</strong> - Danish queen, the prince’s own mother. Pharaoh died she remarried Claudius. </p>
<p><strong>Ophelia</strong> - Polonius’s daughter, a beautiful young lady with whom Hamlet has been in love. Ophelia is a sweet and innocent young girl, who obeys her father and her brother, Laertes. </p>
<p><strong>The Ghost</strong> - The spectre of Hamlet’s recently deceased father. The ghost, who claims to have been murdered by Claudius, calls upon Hamlet to avenge him. </p>
<p><strong>Laertes</strong> - Polonius’s son. For his father and his sister’s death with swords killed Hamlet. He also died in the poison of the sword, though Hamlet didn’t realize sword is poisoned.</p>
<a id="more"></a>
<p><strong>Hamlet’s Madness is Feigned</strong></p>
<p>Some hold that Shakespeare never intended to represent Hamlet as mad but expressly a feigner of madness, and even created the real madness of Ophelia, to contrast it with feigned madness. In every single instance in which Hamlet’s madness is manifested, he has good reason for assuming that madness: while, on the other hand, whenever there was no need to hoodwink anyone, his thought, language and action, bear no resemblance to unsoundness of intellect.” In Act I, Scene V, Hamlet tells Horatio and others that from now on he shall behave like a mad. His feigned madness provides him a great opportunity to find out the reality.:</p>
<p><strong><em>Here, as before, never, so help you mercy,\</em></strong><br> <strong><em>How strange or odd so e’er I bear myself,\</em></strong><br> <strong><em>As I perchance hereafter shall think meet,\</em></strong><br> <strong><em>To put an antic disposition on……..\</em></strong></p>
<p>Hamlet’s madness is feigned on the ground that, on various occasions, he is seen in a good temper. His usage of phrases and ideas are not like that of an insane man. He rarely talks in a manner that compels us to say that Hamlet’s madness is real. In the Closet Scene, Hamlet tells his mother:</p>
<p><strong><em>That I essentially am not in madness\</em></strong><br> <strong><em>But mad in craft.\</em></strong></p>
<p>To prove the words of the ghost, Hamlet is going to stage a mock-play. No mad person can handle such things. Moreover, Hamlet also directs the actors about the play they are going to enact before the King. Hamlet also tells his friend, Horatio, to keep an eye on the King to catch his conscience, which no one can manage but a man of sense and intellect. Even Guildenstern and Rosencrantz do not think that Hamlet is mad. They describe his behaviour as a “crafty madness.” </p>
<p>In the Closet Scene, Hamlet convinces her mother in such a manner that she is compelled to accept her guilt.</p>
<blockquote>
<p> She says:</p>
<p><strong><em>O Hamlet, speak no more:\</em></strong><br> <strong><em>Thou turn’st mine eyes into my very soul;\</em></strong><br> <strong><em>And there I see such black and grained spots\</em></strong><br> <strong><em>As will not leave their tinct.\</em></strong></p>
<p>Hamlet’s comments on the art of acting are so effective and precise that such kinds of statements could not have come from the lips of an insane man. He advises the actors in the following manner:</p>
<p><strong><em>Speak the speech, I pray you, as I pronounced it to\</em></strong><br> <strong><em>you, trippingly on the tongue: but if you mouth it,\</em></strong><br> <strong><em>as many of your players do, I had as lief the\</em></strong><br> <strong><em>town-crier spoke my lines. Nor do not saw t***</em></strong>he air*<strong><br> *</strong>too much with your hand, thus, but use all gently;*<strong><br> *</strong>for in the very torrent, tempest, and, as I may say,*<strong><br> *</strong>the whirlwind of passion, you must acquire and beget*<strong><br> *</strong>a temperance that may give it smoothness..…….***</p>
</blockquote>
<p>Polonius is so much impressed with the replies of Hamlet that he remarks:</p>
<p>“ How pregnant sometimes his replies are! a happiness that often madness his on, which reason and sanity could not so prosperously be delivered of.”</p>
<p><strong>Hamlet’s Madness is Real</strong></p>
<p>Many critics are of the opinion that Hamlet’s madness is real on the basis of some grounds. Though, in the beginning of the play, he tells his friends that he is going to pretend as mad, yet due to the circumstances, his melancholic nature and grief over hasty marriage of his mother bring about drastic changes in his mental behaviour. Look at the following lines taken from Act II, Scene I, wherein Ophelia gives an account of the strange behaviour of Hamlet:</p>
<p><strong><em>My lord, as I was sewing in my closet,\</em></strong><br> <strong><em>Lord Hamlet, with his doublet all unbraced;\</em></strong><br> <strong><em>No hat upon his head; his stockings foul’d,\</em></strong><br> <strong><em>Ungarter’d, and down-gyved to his ancle;\</em></strong><br> <strong><em>Pale as his shirt; his knees knocking each other;\</em></strong><br> <strong><em>And with a look so piteous in purport\</em></strong><br> <strong><em>As if he had been loosed out of hell\</em></strong><br> <strong><em>To speak of horrors,—he comes before me.\</em></strong></p>
<p>She also tells her father that he took her by hand and took such a sigh, which was “so piteous and profound as it did seem to shatter all his bulk.” Polonius, when hears her statement about the strange behaviour of Hamlet, concludes that the strange behaviour of Hamlet is due to disappointment in love. Polonius calls his strange behaviour as “the very ecstasy of love.” </p>
<p>And in the nunnery scene, Hamlet insults Ophelia in the same manner as he insulted her earlier in the play. He advises her not to marry but to go to nunnery.</p>
<p>(“If thou dost marry, I’ll give thee this plague for thy dowry. Be thou as chaste as ice, as pure as snow, thou shalt not escape calumny. Get thee to a nunnery, go. Farewell. Or, if thou wilt needs marry, marry a fool, for wise men know well enough what monsters you make of them. To a nunnery, go, and quickly too. Farewell.”)</p>
<p>This strange behaviour of Hamlet convinces Ophelia that he has really gone mad. She expresses her grief over the mental ailment of Hamlet in the following words:</p>
<p><strong><em>Oh, what a noble mind is here o’erthrown!—\</em></strong><br> <strong>*The courtier’s, soldier’s, scholar’s, eye, to</strong>ngue, sword,……*<strong><br> *</strong>Oh, woe is me,*<strong><br> *</strong>T’ have seen what I have seen, see what I see!***</p>
<p>On the “vile king” Claudius.</p>
<p>Actually both Claudius and Hamlet ultimately sacrifice humanity and humaneness in the acquisition of their goals. But what makes Claudius a villain is that he is wrong to kill people merely to fulfill his own thirst for power and sex, and Hamlet is right for the vengeance on the vile king with a flag of integrity; Claudius is a sneak who murdered and lied. Hamlet commits his murders in the open and suffers the pangs of his own conscience. Claudius subverts his conscience and refuses to ask for divine forgiveness; Hamlet seeks contrition and absolves himself of guilt before he dies; Claudius receives no absolution and seeks none. Hamlet will spend eternity in Heaven; Claudius will burn in Hell.</p>
]]></content>
      <categories>
        <category>喵后记</category>
      </categories>
      <tags>
        <tag>小刁猫</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/12/hello-world/</url>
    <content><![CDATA[<p>惯例hello world。</p>
<a id="more"></a>
<h1 id="Hexo-official-start（看看就好）"><a href="#Hexo-official-start（看看就好）" class="headerlink" title="Hexo official start（看看就好）"></a>Hexo official start（看看就好）</h1><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h1 id="Quick-Start-of-This-Blog"><a href="#Quick-Start-of-This-Blog" class="headerlink" title="Quick Start of This Blog"></a>Quick Start of This Blog</h1><p><strong>先安装hexo</strong></p>
<p>First you need to clone from git.</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">***.git</span></span><br></pre></td></tr></table></figure>
<p>then checkout branch hexo</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git checkout hexo</span></span><br></pre></td></tr></table></figure>
<p>you can add a post by</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> post_name</span><br></pre></td></tr></table></figure>
<p>or modify a post by directly modifying the .md in source/_post</p>
<p>then you can preview the modified blog by running on local server</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> s --<span class="literal">debug</span></span><br><span class="line"><span class="comment"># on localhost:4000</span></span><br></pre></td></tr></table></figure>
<p>If you want to deploy</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> clean <span class="comment"># if delete something</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<p>then don’t forget to update branch hexo </p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> *</span><br><span class="line">git commit -m <span class="string">"why you update"</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>
<h1 id="阿尔托莉雅的Hexo"><a href="#阿尔托莉雅的Hexo" class="headerlink" title="阿尔托莉雅的Hexo"></a>阿尔托莉雅的Hexo</h1><h2 id="标题规范"><a href="#标题规范" class="headerlink" title="标题规范"></a>标题规范</h2><p>可以不用一级标题开始，但是必须保证级别连续</p>
<p>比如最大的用三级，则下一级是四级</p>
<h2 id="文章之间的连接"><a href="#文章之间的连接" class="headerlink" title="文章之间的连接"></a>文章之间的连接</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">显示文字</span>](<span class="link">连接地址，从主页后开始写，例如本篇为/2020/01/12/hello-world</span>)</span><br></pre></td></tr></table></figure>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><p>首页上不显示全部内容</p>
<p><code>&lt;!--more--&gt;</code></p>
<h2 id="config的设置"><a href="#config的设置" class="headerlink" title="_config的设置"></a>_config的设置</h2><h3 id="LocalSearch"><a href="#LocalSearch" class="headerlink" title="LocalSearch"></a>LocalSearch</h3><p>在<code>_config.yml</code>中将localsearch的<code>enable: true</code></p>
<h3 id="图片放大可查看"><a href="#图片放大可查看" class="headerlink" title="图片放大可查看"></a>图片放大可查看</h3><p><code>fancybox: true</code></p>
<h1 id="阿尔托莉雅的重建计划"><a href="#阿尔托莉雅的重建计划" class="headerlink" title="阿尔托莉雅的重建计划"></a>阿尔托莉雅的重建计划</h1><p>大致分为四个目录和yml配置</p>
<ul>
<li>layout：</li>
<li>source：</li>
<li>language：主题配置语言的翻译</li>
<li>scripts</li>
<li>_config.yml：这个yml的配置可以通过theme.xxx来获取</li>
</ul>
<p>前端模板主要有<code>ejs</code>和<code>swig</code>，前者是landscape使用的，后者是next使用的</p>
<p><code>ejs</code>模板下，在 <code>layout</code> 目录下的 <code>index.ejs</code> 会自动继承 <code>layout.ejs</code>，并将其中的内容填入 <code>&lt; %- body % &gt;</code> 的位置。</p>
`swig`模板下通过`{% extends 'xxx.swig' %}`对swig进行继承，再通过`{% block blockname %} xxx {% endblock %}`控制填入的位置。
<p>%号后加-表明block里的内容删去前后空格</p>
]]></content>
  </entry>
</search>
